// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Microsoft.Windows.CsWin32
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Reflection.Metadata;
    using System.Reflection.PortableExecutable;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Threading;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.Windows.SDK.Win32Docs;
    using static FastSyntaxFactory;

    /// <summary>
    /// The core of the source generator.
    /// </summary>
    public class Generator : IDisposable
    {
        internal const string InteropDecorationNamespace = "Windows.Win32.Interop";
        internal const string NativeArrayInfoAttribute = "NativeArrayInfoAttribute";
        internal const string RAIIFreeAttribute = "RAIIFreeAttribute";
        internal const string GlobalNamespacePrefix = "global::";
        internal const string GlobalWin32NamespaceAlias = "win32";

        internal static readonly SyntaxAnnotation IsManagedTypeAnnotation = new SyntaxAnnotation("IsManagedType");
        internal static readonly SyntaxAnnotation IsSafeHandleTypeAnnotation = new SyntaxAnnotation("IsSafeHandleType");
        internal static readonly SyntaxAnnotation IsRetValAnnotation = new SyntaxAnnotation("RetVal");

        internal static readonly Dictionary<string, TypeSyntax> BclInteropStructs = new Dictionary<string, TypeSyntax>(StringComparer.Ordinal)
        {
            { nameof(System.Runtime.InteropServices.ComTypes.FILETIME), ParseTypeName("global::System.Runtime.InteropServices.ComTypes.FILETIME") },
            { nameof(Guid), ParseTypeName("global::System.Guid") },
            { "OLD_LARGE_INTEGER", PredefinedType(Token(SyntaxKind.LongKeyword)) },
            { "LARGE_INTEGER", PredefinedType(Token(SyntaxKind.LongKeyword)) },
            { "ULARGE_INTEGER", PredefinedType(Token(SyntaxKind.ULongKeyword)) },
        };

        internal static readonly Dictionary<string, TypeSyntax> AdditionalBclInteropStructsMarshaled = new Dictionary<string, TypeSyntax>(StringComparer.Ordinal)
        {
            { "BOOL", PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)) },
        };

        internal static readonly Dictionary<string, TypeSyntax> BclInteropSafeHandles = new Dictionary<string, TypeSyntax>(StringComparer.Ordinal)
        {
            { "CloseHandle", ParseTypeName("Microsoft.Win32.SafeHandles.SafeFileHandle").WithAdditionalAnnotations(IsManagedTypeAnnotation, IsSafeHandleTypeAnnotation) },
        };

        private const string CommonNamespaceDot = "Windows.Win32.";
        private const string CommonNamespace = "Windows.Win32";
        private const string SystemRuntimeCompilerServices = "System.Runtime.CompilerServices";
        private const string SystemRuntimeInteropServices = "System.Runtime.InteropServices";
        private const string NativeTypedefAttribute = "NativeTypedefAttribute";
        private const string SimpleFileNameAnnotation = "SimpleFileName";
        private const string NamespaceContainerAnnotation = "NamespaceContainer";
        private const string OriginalDelegateAnnotation = "OriginalDelegate";

        private static readonly string AutoGeneratedHeader = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

".Replace("\r\n", "\n");

        private static readonly string PartialPInvokeContentComment = @"
/// <content>
/// Contains extern methods from ""{0}.dll"".
/// </content>
".Replace("\r\n", "\n");

        private static readonly SyntaxTriviaList InlineArrayUnsafeAsSpanComment = ParseLeadingTrivia(@"/// <summary>
/// Gets this inline array as a span.
/// </summary>
/// <remarks>
/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
/// </remarks>
");

        private static readonly SyntaxTriviaList InlineArrayUnsafeIndexerComment = ParseLeadingTrivia(@"/// <summary>
/// Gets a ref to an individual element of the inline array.
/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
/// </summary>
");

        private static readonly XmlTextSyntax DocCommentStart = XmlText(" ").WithLeadingTrivia(DocumentationCommentExterior("///"));
        private static readonly XmlTextSyntax DocCommentEnd = XmlText(XmlTextNewLine("\r\n", continueXmlDocumentationComment: false));

        private static readonly SyntaxToken SemicolonWithLineFeed = TokenWithLineFeed(SyntaxKind.SemicolonToken);
        private static readonly IdentifierNameSyntax ConstantsClassName = IdentifierName("Constants");
        private static readonly IdentifierNameSyntax InlineArrayIndexerExtensionsClassName = IdentifierName("InlineArrayIndexerExtensions");
        private static readonly IdentifierNameSyntax ComInterfaceFriendlyExtensionsClassName = IdentifierName("FriendlyOverloadExtensions");
        private static readonly TypeSyntax SafeHandleTypeSyntax = IdentifierName("SafeHandle");
        private static readonly IdentifierNameSyntax IntPtrTypeSyntax = IdentifierName(nameof(IntPtr));
        private static readonly AttributeSyntax ComImportAttribute = Attribute(IdentifierName("ComImport"));
        private static readonly AttributeSyntax PreserveSigAttribute = Attribute(IdentifierName("PreserveSig"));
        private static readonly AttributeSyntax SupportedOSPlatformAttribute = Attribute(IdentifierName("SupportedOSPlatform"));
        private static readonly AttributeListSyntax DefaultDllImportSearchPathsAttributeList = AttributeList()
            .WithCloseBracketToken(TokenWithLineFeed(SyntaxKind.CloseBracketToken))
            .AddAttributes(Attribute(IdentifierName("DefaultDllImportSearchPaths")).AddArgumentListArguments(AttributeArgument(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(nameof(DllImportSearchPath)), IdentifierName(nameof(DllImportSearchPath.System32))))));

        private static readonly HashSet<string> ImplicitConversionTypeDefs = new HashSet<string>(StringComparer.Ordinal)
        {
            "PWSTR",
            "PSTR",
            "LPARAM",
            "WPARAM",
        };

        private static readonly HashSet<string> SpecialTypeDefNames = new HashSet<string>(StringComparer.Ordinal)
        {
            "PCWSTR",
            "PCSTR",
        };

        /// <summary>
        /// This is the preferred capitalizations for modules and class names.
        /// If they are not in this list, the capitalization will come from the metadata assembly.
        /// </summary>
        private static readonly ImmutableHashSet<string> CanonicalCapitalizations = ImmutableHashSet.Create<string>(
            StringComparer.OrdinalIgnoreCase,
            "AdvApi32",
            "AuthZ",
            "BCrypt",
            "Cabinet",
            "CfgMgr32",
            "Chakra",
            "CodeGeneration",
            "CodeGeneration.Debugging",
            "CodeGenerationAttributes",
            "ComCtl32",
            "ComDlg32",
            "Crypt32",
            "CryptNet",
            "D3D11",
            "D3D12",
            "D3DCompiler_47",
            "DbgHelp",
            "DfsCli",
            "DhcpCSvc",
            "DhcpCSvc6",
            "DnsApi",
            "DsParse",
            "DSRole",
            "DwmApi",
            "DXGI",
            "Esent",
            "FltLib",
            "Fusion",
            "Gdi32",
            "Hid",
            "Icu",
            "ImageHlp",
            "InkObjCore",
            "IPHlpApi",
            "Kernel32",
            "LogonCli",
            "Magnification",
            "MFSensorGroup",
            "Mpr",
            "MSCms",
            "MSCorEE",
            "Msi",
            "MswSock",
            "NCrypt",
            "NetApi32",
            "NetUtils",
            "NewDev",
            "NTDll",
            "Ole32",
            "OleAut32",
            "PowrProf",
            "PropSys",
            "Psapi",
            "RpcRT4",
            "SamCli",
            "SchedCli",
            "SetupApi",
            "SHCore",
            "Shell32",
            "ShlwApi",
            "SrvCli",
            "TokenBinding",
            "UrlMon",
            "User32",
            "UserEnv",
            "UxTheme",
            "Version",
            "WebAuthN",
            "WebServices",
            "WebSocket",
            "Win32",
            "Win32MetaGeneration",
            "Windows.Core",
            "Windows.ShellScalingApi",
            "WinHttp",
            "WinMM",
            "WinUsb",
            "WksCli",
            "WLanApi",
            "WldAp32",
            "WtsApi32");

        private static readonly HashSet<string> CSharpKeywords = new HashSet<string>(StringComparer.Ordinal)
        {
            "object",
            "event",
            "override",
            "public",
            "private",
            "protected",
            "internal",
            "virtual",
            "string",
            "base",
            "ref",
            "in",
            "out",
            "decimal",
            "as",
            "params",
        };

        private static readonly HashSet<string> ObjectMembers = new HashSet<string>(StringComparer.Ordinal)
        {
            "GetType",
        };

        private static readonly string[] WarningsToSuppressInGeneratedCode = new string[]
        {
            "CS1591", // missing docs
            "CS1573", // missing docs for an individual parameter
            "CS0465", // Avoid methods named "Finalize", which can't be helped
            "CS0649", // fields never assigned to
            "CS8019", // unused usings
            "CS1570", // XML comment has badly formed XML
            "CS1584", // C# bug: https://github.com/microsoft/CsWin32/issues/24
            "CS1658", // C# bug: https://github.com/microsoft/CsWin32/issues/24
        };

        private static readonly AttributeSyntax OptionalAttributeSyntax = Attribute(IdentifierName("Optional")).WithArgumentList(null);
        private static readonly AttributeSyntax FlagsAttributeSyntax = Attribute(IdentifierName("Flags")).WithArgumentList(null);
        private static readonly AttributeSyntax FieldOffsetAttributeSyntax = Attribute(IdentifierName("FieldOffset"));

        private readonly TypeSyntaxSettings generalTypeSettings;
        private readonly TypeSyntaxSettings fieldTypeSettings;
        private readonly TypeSyntaxSettings delegateSignatureTypeSettings;
        private readonly TypeSyntaxSettings enumTypeSettings;
        private readonly TypeSyntaxSettings fieldOfHandleTypeDefTypeSettings;
        private readonly TypeSyntaxSettings externSignatureTypeSettings;
        private readonly TypeSyntaxSettings externReleaseSignatureTypeSettings;
        private readonly TypeSyntaxSettings comSignatureTypeSettings;
        private readonly TypeSyntaxSettings extensionMethodSignatureTypeSettings;
        private readonly TypeSyntaxSettings functionPointerTypeSettings;
        private readonly TypeSyntaxSettings errorMessageTypeSettings;

        private readonly Dictionary<TypeReferenceHandle, TypeDefinitionHandle> refToDefCache = new();

        private readonly GeneratorOptions options;
        private readonly CSharpCompilation? compilation;
        private readonly CSharpParseOptions? parseOptions;
        private readonly bool canCallCreateSpan;
        private readonly bool generateSupportedOSPlatformAttributes;
        private readonly bool generateSupportedOSPlatformAttributesOnInterfaces; // only supported on net6.0 (https://github.com/dotnet/runtime/pull/48838)
        private readonly bool generateDefaultDllImportSearchPathsAttribute;
        private readonly GeneratedCode committedCode = new();
        private readonly GeneratedCode volatileCode;

        /// <summary>
        /// Initializes a new instance of the <see cref="Generator"/> class.
        /// </summary>
        /// <param name="metadataLibraryPath">The path to the winmd metadata to generate APIs from.</param>
        /// <param name="apiDocsPath">The path to the API docs file.</param>
        /// <param name="options">Options that influence the result of generation.</param>
        /// <param name="compilation">The compilation that the generated code will be added to.</param>
        /// <param name="parseOptions">The parse options that will be used for the generated code.</param>
        public Generator(string metadataLibraryPath, string? apiDocsPath, GeneratorOptions? options = null, CSharpCompilation? compilation = null, CSharpParseOptions? parseOptions = null)
        {
            this.MetadataIndex = MetadataIndex.Get(metadataLibraryPath, compilation?.Options.Platform);
            this.ApiDocs = apiDocsPath is object ? Docs.Get(apiDocsPath) : null;

            this.options = options ??= new GeneratorOptions();
            this.options.Validate();
            this.compilation = compilation;
            this.parseOptions = parseOptions;
            this.volatileCode = new(this.committedCode);

            this.canCallCreateSpan = this.compilation?.GetTypeByMetadataName(typeof(MemoryMarshal).FullName)?.GetMembers("CreateSpan").Any() is true;
            this.generateDefaultDllImportSearchPathsAttribute = this.compilation?.GetTypeByMetadataName(typeof(DefaultDllImportSearchPathsAttribute).FullName) is object;
            if (this.compilation?.GetTypeByMetadataName("System.Runtime.Versioning.SupportedOSPlatformAttribute") is { } attribute)
            {
                this.generateSupportedOSPlatformAttributes = true;
                AttributeData usageAttribute = attribute.GetAttributes().Single(att => att.AttributeClass?.Name == nameof(AttributeUsageAttribute));
                var targets = (AttributeTargets)usageAttribute.ConstructorArguments[0].Value!;
                this.generateSupportedOSPlatformAttributesOnInterfaces = (targets & AttributeTargets.Interface) == AttributeTargets.Interface;
            }

            if (options.AllowMarshaling)
            {
                this.BannedAPIs.Add("VARIANT", "Use `object` instead of VARIANT when in COM interface mode. VARIANT can only be emitted when emitting COM interfaces as structs.");
            }

            bool useComInterfaces = options.AllowMarshaling;
            this.generalTypeSettings = new TypeSyntaxSettings(
                this,
                PreferNativeInt: this.LanguageVersion >= LanguageVersion.CSharp9,
                PreferMarshaledTypes: false,
                AllowMarshaling: options.AllowMarshaling,
                QualifyNames: false);
            this.fieldTypeSettings = this.generalTypeSettings with { QualifyNames = true };
            this.delegateSignatureTypeSettings = this.generalTypeSettings with { QualifyNames = true };
            this.enumTypeSettings = this.generalTypeSettings;
            this.fieldOfHandleTypeDefTypeSettings = this.generalTypeSettings with { PreferNativeInt = false };
            this.externSignatureTypeSettings = this.generalTypeSettings with { QualifyNames = true, PreferMarshaledTypes = true };
            this.externReleaseSignatureTypeSettings = this.externSignatureTypeSettings with { PreferNativeInt = false, PreferMarshaledTypes = false };
            this.comSignatureTypeSettings = this.generalTypeSettings with { QualifyNames = true };
            this.extensionMethodSignatureTypeSettings = this.generalTypeSettings with { QualifyNames = true };
            this.functionPointerTypeSettings = this.generalTypeSettings with { QualifyNames = true };
            this.errorMessageTypeSettings = this.generalTypeSettings with { QualifyNames = true };
        }

        private enum FriendlyOverloadOf
        {
            ExternMethod,
            StructMethod,
            InterfaceMethod,
        }

        internal Dictionary<string, string> BannedAPIs { get; } = new Dictionary<string, string>
        {
            { "GetLastError", "Do not generate GetLastError. Call Marshal.GetLastWin32Error() instead. Learn more from https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.marshal.getlastwin32error" },
            { "OLD_LARGE_INTEGER", "Use the C# long keyword instead." },
            { "LARGE_INTEGER", "Use the C# long keyword instead." },
            { "ULARGE_INTEGER", "Use the C# ulong keyword instead." },
        };

        internal MetadataIndex MetadataIndex { get; }

        internal Docs? ApiDocs { get; }

        internal ReadOnlyCollection<TypeDefinition> Apis => this.MetadataIndex.Apis;

        internal MetadataReader Reader => this.MetadataIndex.Reader;

        internal LanguageVersion LanguageVersion => this.parseOptions?.LanguageVersion ?? LanguageVersion.CSharp9;

        private bool WideCharOnly => this.options.WideCharOnly;

        private bool GroupByModule => string.IsNullOrEmpty(this.options.ClassName);

        private string Namespace => this.options.Namespace;

        private string SingleClassName => this.options.ClassName ?? throw new InvalidOperationException("Not in one-class mode.");

        private SyntaxKind Visibility => this.options.Public ? SyntaxKind.PublicKeyword : SyntaxKind.InternalKeyword;

        private IEnumerable<MemberDeclarationSyntax> NamespaceMembers
        {
            get
            {
                IEnumerable<MemberDeclarationSyntax> result = this.GroupByModule
                    ? this.ExternMethodsByModuleClassName.Select(kv =>
                        ClassDeclaration(Identifier(GetClassNameForModule(kv.Key)))
                        .AddModifiers(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.PartialKeyword))
                        .AddMembers(kv.ToArray()))
                    : from entry in this.committedCode.MembersByModule
                      select ClassDeclaration(Identifier(this.SingleClassName))
                        .AddModifiers(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.PartialKeyword))
                        .AddMembers(entry.ToArray())
                        .WithLeadingTrivia(ParseLeadingTrivia(string.Format(CultureInfo.InvariantCulture, PartialPInvokeContentComment, entry.Key)))
                        .WithAdditionalAnnotations(new SyntaxAnnotation(SimpleFileNameAnnotation, $"{this.SingleClassName}.{entry.Key}"));
                result = result.Concat(this.committedCode.GeneratedTypes);

                ClassDeclarationSyntax constantClass = this.DeclareConstantDefiningClass();
                if (constantClass.Members.Count > 0)
                {
                    result = result.Concat(new MemberDeclarationSyntax[] { constantClass });
                }

                ClassDeclarationSyntax inlineArrayIndexerExtensionsClass = this.DeclareInlineArrayIndexerExtensionsClass();
                if (inlineArrayIndexerExtensionsClass.Members.Count > 0)
                {
                    result = result.Concat(new MemberDeclarationSyntax[] { inlineArrayIndexerExtensionsClass });
                }

                ClassDeclarationSyntax comInterfaceFriendlyExtensionsClass = this.DeclareComInterfaceFriendlyExtensionsClass();
                if (comInterfaceFriendlyExtensionsClass.Members.Count > 0)
                {
                    result = result.Concat(new MemberDeclarationSyntax[] { comInterfaceFriendlyExtensionsClass });
                }

                return result;
            }
        }

        private IEnumerable<IGrouping<string, MemberDeclarationSyntax>> ExternMethodsByModuleClassName =>
            from entry in this.committedCode.MembersByModule
            from method in entry
            group method by GetClassNameForModule(entry.Key) into x
            select x;

        /// <inheritdoc/>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Generates all extern methods, structs, delegates, constants as defined by the source metadata.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAll(CancellationToken cancellationToken)
        {
            this.GenerateAllExternMethods(cancellationToken);

            // Also generate all structs/enum types too, even if not referenced by a method,
            // since some methods use `void*` types and require structs at runtime.
            this.RequestAllInteropTypes(cancellationToken);

            this.GenerateAllConstants(cancellationToken);
        }

        /// <summary>
        /// Generates code for a given API.
        /// </summary>
        /// <param name="apiNameOrModuleWildcard">The name of the method, struct or constant. Or the name of a module with a ".*" suffix in order to generate all methods and supporting types for the specified module.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns><see langword="true" /> if any matching APIs were found and generated; <see langword="false"/> otherwise.</returns>
        public bool TryGenerate(string apiNameOrModuleWildcard, CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(apiNameOrModuleWildcard))
            {
                throw new ArgumentException("API cannot be null or empty.", nameof(apiNameOrModuleWildcard));
            }

            if (apiNameOrModuleWildcard.EndsWith(".*", StringComparison.Ordinal))
            {
                return this.TryGenerateAllExternMethods(apiNameOrModuleWildcard.Substring(0, apiNameOrModuleWildcard.Length - 2), cancellationToken);
            }
            else
            {
                return
                    this.TryGenerateNamespace(apiNameOrModuleWildcard) ||
                    this.TryGenerateExternMethod(apiNameOrModuleWildcard) ||
                    this.TryGenerateType(apiNameOrModuleWildcard) ||
                    this.TryGenerateConstant(apiNameOrModuleWildcard);
            }
        }

        /// <summary>
        /// Generates all APIs within a given namespace, and their dependencies.
        /// </summary>
        /// <param name="namespace">The namespace to generate APIs for.</param>
        /// <returns><see langword="true"/> if a matching namespace was found; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateNamespace(string @namespace)
        {
            if (@namespace is null)
            {
                throw new ArgumentNullException(nameof(@namespace));
            }

            NamespaceMetadata? metadata;
            if (!this.MetadataIndex.MetadataByNamespace.TryGetValue(@namespace, out metadata))
            {
                // Fallback to case insensitive search if it looks promising to do so.
                if (@namespace.StartsWith(CommonNamespace, StringComparison.OrdinalIgnoreCase))
                {
                    foreach (var item in this.MetadataIndex.MetadataByNamespace)
                    {
                        if (string.Equals(item.Key, @namespace, StringComparison.OrdinalIgnoreCase))
                        {
                            metadata = item.Value;
                            break;
                        }
                    }
                }
            }

            if (metadata is object)
            {
                this.volatileCode.GenerationTransaction(delegate
                {
                    foreach (var method in metadata.Methods)
                    {
                        this.RequestExternMethod(method.Value);
                    }

                    foreach (var type in metadata.Types)
                    {
                        this.RequestInteropType(type.Value);
                    }

                    foreach (var field in metadata.Fields)
                    {
                        this.RequestConstant(field.Value);
                    }
                });

                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the name of the declaring enum if a supplied value matches the name of an enum's value.
        /// </summary>
        /// <param name="enumValueName">A string that may match an enum value name.</param>
        /// <param name="declaringEnum">Receives the name of the declaring enum if a match is found.</param>
        /// <returns><see langword="true"/> if a match was found; otherwise <see langword="false"/>.</returns>
        public bool TryGetEnumName(string enumValueName, [NotNullWhen(true)] out string? declaringEnum)
        {
            // First find the type reference for System.Enum
            TypeReferenceHandle? enumTypeRefHandle = null;
            foreach (TypeReferenceHandle typeRefHandle in this.Reader.TypeReferences)
            {
                TypeReference typeRef = this.Reader.GetTypeReference(typeRefHandle);
                if (this.Reader.StringComparer.Equals(typeRef.Name, nameof(Enum)) && this.Reader.StringComparer.Equals(typeRef.Namespace, nameof(System)))
                {
                    enumTypeRefHandle = typeRefHandle;
                    break;
                }
            }

            Debug.Assert(enumTypeRefHandle.HasValue, "We always expect at least one enum.");
            if (enumTypeRefHandle is null)
            {
                // No enums -> it couldn't be what the caller is looking for.
                declaringEnum = null;
                return false;
            }

            foreach (TypeDefinitionHandle typeDefHandle in this.Reader.TypeDefinitions)
            {
                TypeDefinition typeDef = this.Reader.GetTypeDefinition(typeDefHandle);
                if (typeDef.BaseType.IsNil)
                {
                    continue;
                }

                if (typeDef.BaseType.Kind != HandleKind.TypeReference)
                {
                    continue;
                }

                var baseTypeHandle = (TypeReferenceHandle)typeDef.BaseType;
                if (!baseTypeHandle.Equals(enumTypeRefHandle.Value))
                {
                    continue;
                }

                foreach (FieldDefinitionHandle fieldDefHandle in typeDef.GetFields())
                {
                    FieldDefinition fieldDef = this.Reader.GetFieldDefinition(fieldDefHandle);
                    if (this.Reader.StringComparer.Equals(fieldDef.Name, enumValueName))
                    {
                        declaringEnum = this.Reader.GetString(typeDef.Name);
                        return true;
                    }
                }
            }

            declaringEnum = null;
            return false;
        }

        /// <summary>
        /// Generates a projection of all extern methods and their supporting types.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAllExternMethods(CancellationToken cancellationToken)
        {
            foreach (MethodDefinitionHandle methodHandle in this.Apis.SelectMany(api => api.GetMethods()))
            {
                cancellationToken.ThrowIfCancellationRequested();

                MethodDefinition methodDef = this.Reader.GetMethodDefinition(methodHandle);
                if (this.IsCompatibleWithPlatform(methodDef.GetCustomAttributes()))
                {
                    try
                    {
                        this.volatileCode.GenerationTransaction(delegate
                        {
                            this.RequestExternMethod(methodHandle);
                        });
                    }
                    catch (GenerationFailedException ex) when (IsPlatformCompatibleException(ex))
                    {
                        // Something transitively required for this method is not available for this platform, so skip this method.
                    }
                }
            }
        }

        /// <summary>
        /// Generates a projection of all constants.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAllConstants(CancellationToken cancellationToken)
        {
            foreach (FieldDefinitionHandle fieldDefHandle in this.Apis.SelectMany(api => api.GetFields()))
            {
                cancellationToken.ThrowIfCancellationRequested();

                FieldDefinition fieldDef = this.Reader.GetFieldDefinition(fieldDefHandle);
                if (this.IsCompatibleWithPlatform(fieldDef.GetCustomAttributes()))
                {
                    try
                    {
                        this.volatileCode.GenerationTransaction(delegate
                        {
                            this.RequestConstant(fieldDefHandle);
                        });
                    }
                    catch (GenerationFailedException ex) when (IsPlatformCompatibleException(ex))
                    {
                        // Something transitively required for this field is not available for this platform, so skip this method.
                    }
                }
            }
        }

        /// <summary>
        /// Generates all extern methods exported from a particular module, along with all their supporting types.
        /// </summary>
        /// <param name="moduleName">The name of the module for whose exports extern methods should be generated for.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns><see langword="true"/> if a matching module name was found and extern methods generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateAllExternMethods(string moduleName, CancellationToken cancellationToken)
        {
            bool successful = false;
            foreach (MethodDefinitionHandle methodHandle in this.Apis.SelectMany(api => api.GetMethods()))
            {
                cancellationToken.ThrowIfCancellationRequested();

                MethodDefinition methodDef = this.Reader.GetMethodDefinition(methodHandle);
                ModuleReferenceHandle moduleHandle = methodDef.GetImport().Module;
                if (moduleHandle.IsNil)
                {
                    continue;
                }

                ModuleReference module = this.Reader.GetModuleReference(moduleHandle);
                if (this.Reader.StringComparer.Equals(module.Name, moduleName, ignoreCase: true))
                {
                    string? bannedReason = null;
                    foreach (var bannedApi in this.BannedAPIs)
                    {
                        if (this.Reader.StringComparer.Equals(methodDef.Name, bannedApi.Key))
                        {
                            // Skip a banned API.
                            bannedReason = bannedApi.Value;
                            continue;
                        }
                    }

                    if (bannedReason is object)
                    {
                        continue;
                    }

                    if (this.IsCompatibleWithPlatform(methodDef.GetCustomAttributes()))
                    {
                        try
                        {
                            this.volatileCode.GenerationTransaction(delegate
                            {
                                this.RequestExternMethod(methodHandle);
                            });
                        }
                        catch (GenerationFailedException ex) when (IsPlatformCompatibleException(ex))
                        {
                            // Something transitively required for this method is not available for this platform, so skip this method.
                        }
                    }

                    successful = true;
                }
            }

            return successful;
        }

        /// <summary>
        /// Generate code for the named extern method, if it is recognized.
        /// </summary>
        /// <param name="possiblyQualifiedName">The name of the extern method, optionally qualified with a namespace.</param>
        /// <returns><see langword="true"/> if a match was found and the extern method generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateExternMethod(string possiblyQualifiedName)
        {
            if (possiblyQualifiedName is null)
            {
                throw new ArgumentNullException(nameof(possiblyQualifiedName));
            }

            if (this.GetMethodByName(possiblyQualifiedName) is MethodDefinitionHandle methodDefHandle)
            {
                MethodDefinition methodDef = this.Reader.GetMethodDefinition(methodDefHandle);
                string methodName = this.Reader.StringComparer.Equals(methodDef.Name, possiblyQualifiedName) ? possiblyQualifiedName : this.Reader.GetString(methodDef.Name);
                if (this.BannedAPIs.TryGetValue(methodName, out string? reason))
                {
                    throw new NotSupportedException(reason);
                }

                this.volatileCode.GenerationTransaction(delegate
                {
                    this.RequestExternMethod(methodDefHandle);
                });

                return true;
            }

            return false;
        }

        /// <summary>
        /// Generate code for the named type, if it is recognized.
        /// </summary>
        /// <param name="possiblyQualifiedName">The name of the interop type, optionally qualified with a namespace.</param>
        /// <returns><see langword="true"/> if a match was found and the type generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateType(string possiblyQualifiedName)
        {
            if (possiblyQualifiedName is null)
            {
                throw new ArgumentNullException(nameof(possiblyQualifiedName));
            }

            TrySplitPossiblyQualifiedName(possiblyQualifiedName, out string? typeNamespace, out string typeName);
            var matchingTypeHandles = new List<TypeDefinitionHandle>();
            var namespaces = this.GetNamespacesToSearch(typeNamespace);
            bool foundApiWithMismatchedPlatform = false;

            foreach (var nsMetadata in namespaces)
            {
                if (nsMetadata.Types.TryGetValue(typeName, out TypeDefinitionHandle handle))
                {
                    matchingTypeHandles.Add(handle);
                }
                else if (nsMetadata.TypesForOtherPlatform.Contains(typeName))
                {
                    foundApiWithMismatchedPlatform = true;
                }
            }

            if (matchingTypeHandles.Count == 1)
            {
                this.volatileCode.GenerationTransaction(delegate
                {
                    this.RequestInteropType(matchingTypeHandles[0]);
                });

                return true;
            }
            else if (matchingTypeHandles.Count > 1)
            {
                string matches = string.Join(
                    ", ",
                    matchingTypeHandles.Select(h =>
                    {
                        TypeDefinition td = this.Reader.GetTypeDefinition(h);
                        return $"{this.Reader.GetString(td.Namespace)}.{this.Reader.GetString(td.Name)}";
                    }));
                throw new ArgumentException("The type name is ambiguous. Use the fully-qualified name instead. Possible matches: " + matches);
            }

            if (foundApiWithMismatchedPlatform)
            {
                throw new PlatformIncompatibleException($"The requested API ({possiblyQualifiedName}) was found but is not available given the target platform ({this.compilation?.Options.Platform}).");
            }

            return false;
        }

        /// <summary>
        /// Generate code for the named constant, if it is recognized.
        /// </summary>
        /// <param name="possiblyQualifiedName">The name of the constant, optionally qualified with a namespace.</param>
        /// <returns><see langword="true"/> if a match was found and the constant generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateConstant(string possiblyQualifiedName)
        {
            if (possiblyQualifiedName is null)
            {
                throw new ArgumentNullException(nameof(possiblyQualifiedName));
            }

            TrySplitPossiblyQualifiedName(possiblyQualifiedName, out string? constantNamespace, out string constantName);
            var matchingFieldHandles = new List<FieldDefinitionHandle>();
            var namespaces = this.GetNamespacesToSearch(constantNamespace);

            foreach (var nsMetadata in namespaces)
            {
                if (nsMetadata.Fields.TryGetValue(constantName, out FieldDefinitionHandle fieldDefHandle))
                {
                    matchingFieldHandles.Add(fieldDefHandle);
                }
            }

            if (matchingFieldHandles.Count == 1)
            {
                this.volatileCode.GenerationTransaction(delegate
                {
                    this.RequestConstant(matchingFieldHandles[0]);
                });

                return true;
            }
            else if (matchingFieldHandles.Count > 1)
            {
                string matches = string.Join(
                    ", ",
                    matchingFieldHandles.Select(h =>
                    {
                        FieldDefinition fd = this.Reader.GetFieldDefinition(h);
                        TypeDefinition td = this.Reader.GetTypeDefinition(fd.GetDeclaringType());
                        return $"{this.Reader.GetString(td.Namespace)}.{this.Reader.GetString(fd.Name)}";
                    }));
                throw new ArgumentException("The type name is ambiguous. Use the fully-qualified name instead. Possible matches: " + matches);
            }

            return false;
        }

        /// <summary>
        /// Produces a sequence of suggested APIs with a similar name to the specified one.
        /// </summary>
        /// <param name="name">The user-supplied name.</param>
        /// <returns>A sequence of API names.</returns>
        public IEnumerable<string> GetSuggestions(string name)
        {
            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            // Trim suffixes off the name.
            var suffixes = new List<string> { "A", "W", "32", "64", "Ex" };
            foreach (string suffix in suffixes)
            {
                if (name.EndsWith(suffix, StringComparison.Ordinal))
                {
                    name = name.Substring(0, name.Length - suffix.Length);
                }
            }

            // We should match on any API for which the given string is a substring.
            foreach (NamespaceMetadata nsMetadata in this.MetadataIndex.MetadataByNamespace.Values)
            {
                foreach (string candidate in nsMetadata.Fields.Keys.Concat(nsMetadata.Types.Keys).Concat(nsMetadata.Methods.Keys))
                {
                    if (candidate.Contains(name))
                    {
                        yield return candidate;
                    }
                }
            }
        }

        /// <summary>
        /// Collects the result of code generation.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>All the generated source files, keyed by filename.</returns>
        public IReadOnlyDictionary<string, CompilationUnitSyntax> GetCompilationUnits(CancellationToken cancellationToken)
        {
            var starterNamespace = NamespaceDeclaration(ParseName(this.Namespace));

            // .g.cs because the resulting files are not user-created.
            const string FilenamePattern = "{0}.g.cs";
            var results = new Dictionary<string, NamespaceDeclarationSyntax>(StringComparer.OrdinalIgnoreCase);

            IEnumerable<MemberDeclarationSyntax> GroupMembersByNamespace(IEnumerable<MemberDeclarationSyntax> members)
            {
                return members.GroupBy(member =>
                    member.HasAnnotations(NamespaceContainerAnnotation) ? member.GetAnnotations(NamespaceContainerAnnotation).Single().Data : null)
                    .SelectMany(nsContents =>
                        nsContents.Key is object
                            ? new MemberDeclarationSyntax[] { NamespaceDeclaration(ParseName(nsContents.Key)).AddMembers(nsContents.ToArray()) }
                            : nsContents.ToArray());
            }

            if (this.options.EmitSingleFile)
            {
                results.Add(
                    string.Format(CultureInfo.InvariantCulture, FilenamePattern, "NativeMethods"),
                    starterNamespace.AddMembers(GroupMembersByNamespace(this.NamespaceMembers).ToArray()));
            }
            else
            {
                var membersByFile = this.NamespaceMembers.GroupBy(
                    member => member.HasAnnotations(SimpleFileNameAnnotation)
                            ? member.GetAnnotations(SimpleFileNameAnnotation).Single().Data
                            : member switch
                            {
                                ClassDeclarationSyntax classDecl => classDecl.Identifier.ValueText,
                                StructDeclarationSyntax structDecl => structDecl.Identifier.ValueText,
                                InterfaceDeclarationSyntax ifaceDecl => ifaceDecl.Identifier.ValueText,
                                EnumDeclarationSyntax enumDecl => enumDecl.Identifier.ValueText,
                                DelegateDeclarationSyntax delegateDecl => "Delegates", // group all delegates in one file
                                _ => throw new NotSupportedException("Unsupported member type: " + member.GetType().Name),
                            },
                    StringComparer.OrdinalIgnoreCase);

                foreach (var fileSimpleName in membersByFile)
                {
                    try
                    {
                        results.Add(
                            string.Format(CultureInfo.InvariantCulture, FilenamePattern, fileSimpleName.Key),
                            starterNamespace.AddMembers(GroupMembersByNamespace(fileSimpleName).ToArray()));
                    }
                    catch (ArgumentException ex)
                    {
                        throw new GenerationFailedException($"Failed adding \"{fileSimpleName.Key}\".", ex);
                    }
                }
            }

            var usingDirectives = new List<UsingDirectiveSyntax>
            {
                UsingDirective(AliasQualifiedName(IdentifierName(Token(SyntaxKind.GlobalKeyword)), IdentifierName(nameof(System)))),
                UsingDirective(AliasQualifiedName(IdentifierName(Token(SyntaxKind.GlobalKeyword)), IdentifierName(nameof(System) + "." + nameof(System.Diagnostics)))),
                UsingDirective(ParseName(GlobalNamespacePrefix + SystemRuntimeCompilerServices)),
                UsingDirective(ParseName(GlobalNamespacePrefix + SystemRuntimeInteropServices)),
            };

            if (this.generateSupportedOSPlatformAttributes)
            {
                usingDirectives.Add(UsingDirective(ParseName(GlobalNamespacePrefix + "System.Runtime.Versioning")));
            }

            usingDirectives.Add(UsingDirective(NameEquals(GlobalWin32NamespaceAlias), ParseName(GlobalNamespacePrefix + this.Namespace)));

            var normalizedResults = new Dictionary<string, CompilationUnitSyntax>(StringComparer.OrdinalIgnoreCase);
            results.AsParallel().WithCancellation(cancellationToken).ForAll(kv =>
            {
                var compilationUnit = ((CompilationUnitSyntax)CompilationUnit()
                    .AddMembers(
                        kv.Value.AddUsings(usingDirectives.ToArray()))
                    .Accept(new WhitespaceRewriter())!)
                    .WithLeadingTrivia(ParseLeadingTrivia(AutoGeneratedHeader).Add(
                        Trivia(PragmaWarningDirectiveTrivia(
                            disableOrRestoreKeyword: TokenWithSpace(SyntaxKind.DisableKeyword),
                            errorCodes: SeparatedList<ExpressionSyntax>(WarningsToSuppressInGeneratedCode.Select(code => IdentifierName(code))),
                            isActive: true))));

                lock (normalizedResults)
                {
                    normalizedResults.Add(kv.Key, compilationUnit);
                }
            });

            return normalizedResults;
        }

        [return: NotNullIfNotNull("marshalAs")]
        internal static AttributeSyntax? MarshalAs(MarshalAsAttribute? marshalAs)
        {
            if (marshalAs is null)
            {
                return null;
            }

            // TODO: fill in more properties to match the original
            return MarshalAs(marshalAs.Value);
        }

        internal static TypeSyntax MakeSpanOfT(TypeSyntax typeArgument) => GenericName("Span").AddTypeArgumentListArguments(typeArgument);

        internal static TypeSyntax MakeReadOnlySpanOfT(TypeSyntax typeArgument) => GenericName("ReadOnlySpan").AddTypeArgumentListArguments(typeArgument);

        internal static string ReplaceCommonNamespaceWithAlias(string fullNamespace) => TryStripCommonNamespace(fullNamespace, out string? stripped) ? $"{GlobalWin32NamespaceAlias}.{stripped}" : fullNamespace;

        internal static bool TryStripCommonNamespace(string fullNamespace, [NotNullWhen(true)] out string? strippedNamespace)
        {
            if (fullNamespace.StartsWith(CommonNamespaceDot, StringComparison.Ordinal))
            {
                strippedNamespace = fullNamespace.Substring(CommonNamespaceDot.Length);
                return true;
            }
            else if (fullNamespace == CommonNamespace)
            {
                strippedNamespace = string.Empty;
                return true;
            }

            strippedNamespace = null;
            return false;
        }

        /// <summary>
        /// Checks whether an exception was originally thrown because of a target platform incompatibility.
        /// </summary>
        /// <param name="ex">An exception that may be or contain a <see cref="PlatformIncompatibleException"/>.</param>
        /// <returns><see langword="true"/> if <paramref name="ex"/> or an inner exception is a <see cref="PlatformIncompatibleException"/>; otherwise <see langword="false" />.</returns>
        internal static bool IsPlatformCompatibleException(Exception? ex)
        {
            if (ex is null)
            {
                return false;
            }

            return ex is PlatformIncompatibleException || IsPlatformCompatibleException(ex?.InnerException);
        }

        internal bool IsAttribute(CustomAttribute attribute, string ns, string name) => MetadataUtilities.IsAttribute(this.Reader, attribute, ns, name);

        internal bool TryGetHandleReleaseMethod(EntityHandle handleStructDefHandle, [NotNullWhen(true)] out string? releaseMethod)
        {
            if (handleStructDefHandle.IsNil)
            {
                releaseMethod = null;
                return false;
            }

            if (handleStructDefHandle.Kind == HandleKind.TypeReference)
            {
                if (this.TryGetTypeDefHandle((TypeReferenceHandle)handleStructDefHandle, out TypeDefinitionHandle typeDefHandle))
                {
                    return this.TryGetHandleReleaseMethod(typeDefHandle, out releaseMethod);
                }
            }
            else if (handleStructDefHandle.Kind == HandleKind.TypeDefinition)
            {
                return this.TryGetHandleReleaseMethod((TypeDefinitionHandle)handleStructDefHandle, out releaseMethod);
            }

            releaseMethod = null;
            return false;
        }

        internal bool TryGetHandleReleaseMethod(TypeDefinitionHandle handleStructDefHandle, [NotNullWhen(true)] out string? releaseMethod)
        {
            return this.MetadataIndex.HandleTypeReleaseMethod.TryGetValue(handleStructDefHandle, out releaseMethod);
        }

        internal void RequestAllInteropTypes(CancellationToken cancellationToken)
        {
            foreach (TypeDefinitionHandle typeDefinitionHandle in this.Reader.TypeDefinitions)
            {
                cancellationToken.ThrowIfCancellationRequested();
                TypeDefinition typeDef = this.Reader.GetTypeDefinition(typeDefinitionHandle);
                if (typeDef.BaseType.IsNil)
                {
                    continue;
                }

                if (this.IsCompatibleWithPlatform(typeDef.GetCustomAttributes()))
                {
                    try
                    {
                        this.volatileCode.GenerationTransaction(delegate
                        {
                            this.RequestInteropType(typeDefinitionHandle);
                        });
                    }
                    catch (GenerationFailedException ex) when (IsPlatformCompatibleException(ex))
                    {
                        // Something transitively required for this type is not available for this platform, so skip this method.
                    }
                }
            }
        }

        internal void RequestExternMethod(MethodDefinitionHandle methodDefinitionHandle)
        {
            if (methodDefinitionHandle.IsNil)
            {
                return;
            }

            MethodDefinition methodDefinition = this.Reader.GetMethodDefinition(methodDefinitionHandle);
            if (!this.IsCompatibleWithPlatform(methodDefinition.GetCustomAttributes()))
            {
                // We've been asked for an interop type that does not apply. This happens because the metadata
                // may use a TypeReferenceHandle or TypeDefinitionHandle to just one of many arch-specific definitions of this type.
                // Try to find the appropriate definition for our target architecture.
                TypeDefinition declaringTypeDef = this.Reader.GetTypeDefinition(methodDefinition.GetDeclaringType());
                string ns = this.Reader.GetString(declaringTypeDef.Namespace);
                string methodName = this.Reader.GetString(methodDefinition.Name);
                if (this.MetadataIndex.MetadataByNamespace[ns].MethodsForOtherPlatform.Contains(methodName))
                {
                    throw new PlatformIncompatibleException($"Request for method ({methodName}) that is not available given the target platform.");
                }
            }

            this.volatileCode.GenerateMethod(methodDefinitionHandle, () => this.DeclareExternMethod(methodDefinitionHandle));
        }

        internal bool IsInterface(HandleTypeHandleInfo typeInfo)
        {
            TypeDefinitionHandle tdh = default;
            if (typeInfo.Handle.Kind == HandleKind.TypeReference)
            {
                var trh = (TypeReferenceHandle)typeInfo.Handle;
                this.TryGetTypeDefHandle(trh, out tdh);
            }
            else if (typeInfo.Handle.Kind == HandleKind.TypeDefinition)
            {
                tdh = (TypeDefinitionHandle)typeInfo.Handle;
            }

            return !tdh.IsNil && (this.Reader.GetTypeDefinition(tdh).Attributes & TypeAttributes.Interface) == TypeAttributes.Interface;
        }

        internal bool IsInterface(TypeHandleInfo handleInfo)
        {
            if (handleInfo is HandleTypeHandleInfo typeInfo)
            {
                return this.IsInterface(typeInfo);
            }
            else if (handleInfo is PointerTypeHandleInfo { ElementType: HandleTypeHandleInfo typeInfo2 })
            {
                return this.IsInterface(typeInfo2);
            }

            return false;
        }

        internal bool IsInterface(TypeReferenceHandle typeRefHandle)
        {
            if (this.TryGetTypeDefHandle(typeRefHandle, out TypeDefinitionHandle typeDefHandle))
            {
                TypeDefinition typeDef = this.Reader.GetTypeDefinition(typeDefHandle);
                return (typeDef.Attributes & TypeAttributes.Interface) == TypeAttributes.Interface;
            }

            return false;
        }

        internal void RequestInteropType(TypeDefinitionHandle typeDefHandle)
        {
            TypeDefinition typeDef = this.Reader.GetTypeDefinition(typeDefHandle);
            if (typeDef.GetDeclaringType() is { IsNil: false } nestingParentHandle)
            {
                // We should only generate this type into its parent type.
                this.RequestInteropType(nestingParentHandle);
                return;
            }

            string ns = this.Reader.GetString(typeDef.Namespace);
            if (!this.IsCompatibleWithPlatform(typeDef.GetCustomAttributes()))
            {
                // We've been asked for an interop type that does not apply. This happens because the metadata
                // may use a TypeReferenceHandle or TypeDefinitionHandle to just one of many arch-specific definitions of this type.
                // Try to find the appropriate definition for our target architecture.
                string name = this.Reader.GetString(typeDef.Name);
                NamespaceMetadata namespaceMetadata = this.MetadataIndex.MetadataByNamespace[ns];
                if (!namespaceMetadata.Types.TryGetValue(name, out typeDefHandle) && namespaceMetadata.TypesForOtherPlatform.Contains(name))
                {
                    throw new PlatformIncompatibleException($"Request for type ({ns}.{name}) that is not available given the target platform.");
                }
            }

            this.volatileCode.GenerateType(typeDefHandle, delegate
            {
                if (this.RequestInteropType(typeDefHandle, null) is MemberDeclarationSyntax typeDeclaration)
                {
                    if (!TryStripCommonNamespace(ns, out string? shortNamespace))
                    {
                        throw new GenerationFailedException("Unexpected namespace: " + ns);
                    }

                    if (shortNamespace.Length > 0)
                    {
                        typeDeclaration = typeDeclaration.WithAdditionalAnnotations(
                            new SyntaxAnnotation(NamespaceContainerAnnotation, shortNamespace));
                    }

                    this.volatileCode.AddInteropType(typeDefHandle, typeDeclaration);
                }
            });
        }

        internal TypeDefinitionHandle? RequestInteropType(TypeReferenceHandle typeRefHandle)
        {
            if (this.TryGetTypeDefHandle(typeRefHandle, out TypeDefinitionHandle typeDefHandle))
            {
                this.RequestInteropType(typeDefHandle);
                return typeDefHandle;
            }
            else
            {
                // System.Guid reaches here, but doesn't need to be generated.
                ////throw new NotSupportedException($"Could not find a type def for: {this.mr.GetString(typeRef.Namespace)}.{name}");
                return null;
            }
        }

        internal void RequestConstant(FieldDefinitionHandle fieldDefHandle)
        {
            this.volatileCode.GenerateConstant(fieldDefHandle, delegate
            {
                FieldDeclarationSyntax constantDeclaration = this.DeclareConstant(fieldDefHandle);
                constantDeclaration = this.AddApiDocumentation(constantDeclaration.Declaration.Variables[0].Identifier.ValueText, constantDeclaration);
                this.volatileCode.AddConstant(fieldDefHandle, constantDeclaration);
            });
        }

        internal TypeSyntax? RequestSafeHandle(string releaseMethod)
        {
            if (this.volatileCode.TryGetSafeHandleForReleaseMethod(releaseMethod, out TypeSyntax? safeHandleType))
            {
                return safeHandleType;
            }

            if (BclInteropSafeHandles.TryGetValue(releaseMethod, out TypeSyntax? bclType))
            {
                return bclType;
            }

            string safeHandleClassName = $"{releaseMethod}SafeHandle";

            MethodDefinitionHandle? releaseMethodHandle = this.GetMethodByName(releaseMethod);
            if (!releaseMethodHandle.HasValue)
            {
                throw new GenerationFailedException("Unable to find release method named: " + releaseMethod);
            }

            MethodDefinition releaseMethodDef = this.Reader.GetMethodDefinition(releaseMethodHandle.Value);
            string releaseMethodModule = this.GetNormalizedModuleName(releaseMethodDef.GetImport());

            var safeHandleTypeIdentifier = IdentifierName(safeHandleClassName);
            safeHandleType = this.GroupByModule
                ? QualifiedName(IdentifierName(releaseMethodModule), safeHandleTypeIdentifier)
                : safeHandleTypeIdentifier;
            safeHandleType = safeHandleType.WithAdditionalAnnotations(IsManagedTypeAnnotation, IsSafeHandleTypeAnnotation);

            MethodSignature<TypeHandleInfo> releaseMethodSignature = releaseMethodDef.DecodeSignature(SignatureHandleProvider.Instance, null);
            var releaseMethodParameterType = releaseMethodSignature.ParameterTypes[0].ToTypeSyntax(this.externSignatureTypeSettings, default);

            // If the release method takes more than one parameter, we can't generate a SafeHandle for it.
            if (releaseMethodSignature.RequiredParameterCount != 1)
            {
                safeHandleType = null;
            }

            this.volatileCode.AddSafeHandleNameForReleaseMethod(releaseMethod, safeHandleType);

            if (safeHandleType is null)
            {
                return safeHandleType;
            }

            if (this.FindSymbolIfAlreadyAvailable($"{this.Namespace}.{safeHandleType}") is object)
            {
                return safeHandleType;
            }

            this.RequestExternMethod(releaseMethodHandle.Value);

            var atts = this.GetReturnTypeCustomAttributes(releaseMethodDef);
            var releaseMethodReturnType = releaseMethodSignature.ReturnType.ToTypeSyntax(this.externSignatureTypeSettings, atts);

            this.TryGetRenamedMethod(releaseMethod, out string? renamedReleaseMethod);

            var members = new List<MemberDeclarationSyntax>();

            MemberAccessExpressionSyntax thisHandle = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("handle"));
            ExpressionSyntax intptrZero = DefaultExpression(IntPtrTypeSyntax);
            ExpressionSyntax intptrMinusOne = ObjectCreationExpression(IntPtrTypeSyntax).AddArgumentListArguments(Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(-1))));

            // private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            IdentifierNameSyntax invalidValueFieldName = IdentifierName("INVALID_HANDLE_VALUE");
            members.Add(FieldDeclaration(VariableDeclaration(IntPtrTypeSyntax).AddVariables(
                VariableDeclarator(invalidValueFieldName.Identifier).WithInitializer(EqualsValueClause(intptrMinusOne))))
                .AddModifiers(TokenWithSpace(SyntaxKind.PrivateKeyword), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.ReadOnlyKeyword)));

            // public SafeHandle() : base(INVALID_HANDLE_VALUE, true)
            members.Add(ConstructorDeclaration(safeHandleTypeIdentifier.Identifier)
                .AddModifiers(TokenWithSpace(this.Visibility))
                .WithInitializer(ConstructorInitializer(SyntaxKind.BaseConstructorInitializer, ArgumentList().AddArguments(
                    Argument(invalidValueFieldName),
                    Argument(LiteralExpression(SyntaxKind.TrueLiteralExpression)))))
                .WithBody(Block()));

            // public SafeHandle(IntPtr preexistingHandle, bool ownsHandle = true) : base(INVALID_HANDLE_VALUE, ownsHandle) { this.SetHandle(preexistingHandle); }
            const string preexistingHandleName = "preexistingHandle";
            const string ownsHandleName = "ownsHandle";
            members.Add(ConstructorDeclaration(safeHandleTypeIdentifier.Identifier)
                .AddModifiers(TokenWithSpace(this.Visibility))
                .AddParameterListParameters(
                    Parameter(Identifier(preexistingHandleName)).WithType(IntPtrTypeSyntax.WithTrailingTrivia(TriviaList(Space))),
                    Parameter(Identifier(ownsHandleName)).WithType(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)))
                        .WithDefault(EqualsValueClause(LiteralExpression(SyntaxKind.TrueLiteralExpression))))
                .WithInitializer(ConstructorInitializer(SyntaxKind.BaseConstructorInitializer, ArgumentList().AddArguments(
                    Argument(invalidValueFieldName),
                    Argument(IdentifierName(ownsHandleName)))))
                .WithBody(Block().AddStatements(
                    ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("SetHandle")))
                        .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(IdentifierName(preexistingHandleName)))))))));

            // public override bool IsInvalid => this.handle == default || this.Handle == INVALID_HANDLE_VALUE;
            members.Add(PropertyDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)), nameof(SafeHandle.IsInvalid))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(
                    BinaryExpression(
                        SyntaxKind.LogicalOrExpression,
                        BinaryExpression(SyntaxKind.EqualsExpression, thisHandle, intptrZero),
                        BinaryExpression(SyntaxKind.EqualsExpression, thisHandle, invalidValueFieldName))))
                .WithSemicolonToken(SemicolonWithLineFeed));

            // protected override bool ReleaseHandle() => ReleaseMethod((struct)this.handle);
            // Special case release functions based on their return type as follows: (https://github.com/microsoft/win32metadata/issues/25)
            //  * bool => true is success
            //  * int => zero is success
            //  * uint => zero is success
            //  * byte => non-zero is success
            ExpressionSyntax releaseInvocation = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(this.GroupByModule ? releaseMethodModule : this.SingleClassName),
                    IdentifierName(renamedReleaseMethod ?? releaseMethod)),
                ArgumentList().AddArguments(Argument(CastExpression(releaseMethodParameterType.Type, MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("handle"))))));
            BlockSyntax? releaseBlock = null;
            if (!(releaseMethodReturnType.Type is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.BoolKeyword } } ||
                releaseMethodReturnType.Type is IdentifierNameSyntax { Identifier: { ValueText: "BOOL" } }))
            {
                switch (releaseMethodReturnType.Type)
                {
                    case PredefinedTypeSyntax predefined:
                        SyntaxKind returnType = predefined.Keyword.Kind();
                        if (returnType == SyntaxKind.IntKeyword)
                        {
                            releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                        }
                        else if (returnType == SyntaxKind.UIntKeyword)
                        {
                            releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                        }
                        else if (returnType == SyntaxKind.ByteKeyword)
                        {
                            releaseInvocation = BinaryExpression(SyntaxKind.NotEqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                        }
                        else if (returnType == SyntaxKind.VoidKeyword)
                        {
                            releaseBlock = Block(
                                ExpressionStatement(releaseInvocation),
                                ReturnStatement(LiteralExpression(SyntaxKind.TrueLiteralExpression)));
                        }
                        else
                        {
                            throw new NotSupportedException($"Return type {returnType} on release method {releaseMethod} not supported.");
                        }

                        break;
                    case QualifiedNameSyntax { Right: IdentifierNameSyntax identifierName }:
                        switch (identifierName.Identifier.ValueText)
                        {
                            case "LSTATUS":
                                this.TryGenerateTypeOrThrow("WIN32_ERROR");
                                ExpressionSyntax errorSuccess = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ParseTypeName(GlobalWin32NamespaceAlias + ".System.Diagnostics.Debug.WIN32_ERROR"), IdentifierName("ERROR_SUCCESS"));
                                releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, CastExpression(ParseTypeName(GlobalWin32NamespaceAlias + ".Foundation.LSTATUS"), CastExpression(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword)), errorSuccess)));
                                break;
                            case "NTSTATUS":
                                this.TryGenerateConstantOrThrow("STATUS_SUCCESS");
                                ExpressionSyntax statusSuccess = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ConstantsClassName, IdentifierName("STATUS_SUCCESS"));
                                releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, statusSuccess);
                                break;
                            case "HRESULT":
                                this.TryGenerateConstantOrThrow("S_OK");
                                ExpressionSyntax ok = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ConstantsClassName, IdentifierName("S_OK"));
                                releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, ok);
                                break;
                            default:
                                throw new NotSupportedException($"Return type {identifierName.Identifier.ValueText} on release method {releaseMethod} not supported.");
                        }

                        break;
                }
            }

            MethodDeclarationSyntax releaseHandleDeclaration = MethodDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)), Identifier("ReleaseHandle"))
                .AddModifiers(TokenWithSpace(SyntaxKind.ProtectedKeyword), TokenWithSpace(SyntaxKind.OverrideKeyword));
            releaseHandleDeclaration = releaseBlock is null
                ? releaseHandleDeclaration
                     .WithExpressionBody(ArrowExpressionClause(releaseInvocation))
                     .WithSemicolonToken(SemicolonWithLineFeed)
                : releaseHandleDeclaration
                    .WithBody(releaseBlock);
            members.Add(releaseHandleDeclaration);

            ClassDeclarationSyntax safeHandleDeclaration = ClassDeclaration(Identifier(safeHandleClassName))
                .AddModifiers(TokenWithSpace(this.Visibility))
                .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(SimpleBaseType(SafeHandleTypeSyntax))))
                .AddMembers(members.ToArray())
                .WithLeadingTrivia(ParseLeadingTrivia($@"
        /// <summary>
        /// Represents a Win32 handle that can be closed with <see cref=""{(this.GroupByModule ? releaseMethodModule : this.SingleClassName)}.{renamedReleaseMethod ?? releaseMethod}""/>.
        /// </summary>
"));

            this.volatileCode.AddSafeHandleType(safeHandleDeclaration);
            if (this.GroupByModule)
            {
                this.volatileCode.AddMemberToModule(releaseMethodModule, safeHandleDeclaration);
            }

            return safeHandleType;
        }

        internal void GetBaseTypeInfo(TypeDefinition typeDef, out StringHandle baseTypeName, out StringHandle baseTypeNamespace)
        {
            if (typeDef.BaseType.IsNil)
            {
                baseTypeName = default;
                baseTypeNamespace = default;
            }
            else
            {
                switch (typeDef.BaseType.Kind)
                {
                    case HandleKind.TypeReference:
                        TypeReference baseTypeRef = this.Reader.GetTypeReference((TypeReferenceHandle)typeDef.BaseType);
                        baseTypeName = baseTypeRef.Name;
                        baseTypeNamespace = baseTypeRef.Namespace;
                        break;
                    case HandleKind.TypeDefinition:
                        TypeDefinition baseTypeDef = this.Reader.GetTypeDefinition((TypeDefinitionHandle)typeDef.BaseType);
                        baseTypeName = baseTypeDef.Name;
                        baseTypeNamespace = baseTypeDef.Namespace;
                        break;
                    default:
                        throw new NotSupportedException("Unsupported base type handle: " + typeDef.BaseType.Kind);
                }
            }
        }

        internal MemberDeclarationSyntax? RequestSpecialTypeDefStruct(string specialName, out string fullyQualifiedName)
        {
            string subNamespace = "Foundation";
            string ns = $"{this.Namespace}.{subNamespace}";
            fullyQualifiedName = $"{ns}.{specialName}";

            // Skip if the compilation already defines this type or can access it from elsewhere.
            if (this.FindSymbolIfAlreadyAvailable(fullyQualifiedName) is object)
            {
                // The type already exists either in this project or a referenced one.
                return null;
            }

            MemberDeclarationSyntax? specialDeclaration = null;
            this.volatileCode.GenerateSpecialType(specialName, delegate
            {
                switch (specialName)
                {
                    case "PCWSTR":
                        specialDeclaration = this.FetchTemplate($"{specialName}");
                        this.TryGenerateType("PWSTR"); // the template references this type
                        break;
                    case "PCSTR":
                        specialDeclaration = this.FetchTemplate($"{specialName}");
                        this.TryGenerateType("PSTR"); // the template references this type
                        break;
                    default:
                        throw new ArgumentException($"This special name is not recognized: \"{specialName}\".", nameof(specialName));
                }

                if (specialDeclaration is null)
                {
                    throw new GenerationFailedException("Failed to parse template.");
                }

                specialDeclaration = specialDeclaration.WithAdditionalAnnotations(new SyntaxAnnotation(NamespaceContainerAnnotation, subNamespace));

                this.volatileCode.AddSpecialType(specialName, specialDeclaration);
            });
            return specialDeclaration;
        }

        internal CustomAttribute? FindNativeArrayInfoAttribute(CustomAttributeHandleCollection customAttributeHandles)
        {
            foreach (var handle in customAttributeHandles)
            {
                CustomAttribute att = this.Reader.GetCustomAttribute(handle);
                if (this.IsAttribute(att, InteropDecorationNamespace, NativeArrayInfoAttribute))
                {
                    return att;
                }
            }

            return null;
        }

        internal CustomAttribute? FindInteropDecorativeAttribute(CustomAttributeHandleCollection customAttributeHandles, string attributeName)
        {
            foreach (var handle in customAttributeHandles)
            {
                CustomAttribute att = this.Reader.GetCustomAttribute(handle);
                if (this.IsAttribute(att, InteropDecorationNamespace, attributeName))
                {
                    return att;
                }
            }

            return null;
        }

        /// <summary>
        /// Attempts to translate a <see cref="TypeReferenceHandle"/> to a <see cref="TypeDefinitionHandle"/>.
        /// </summary>
        /// <param name="typeRefHandle">The reference handle.</param>
        /// <param name="typeDefHandle">Receives the type def handle, if one was discovered.</param>
        /// <returns><see langword="true"/> if a TypeDefinition was found; otherwise <see langword="false"/>.</returns>
        internal bool TryGetTypeDefHandle(TypeReferenceHandle typeRefHandle, out TypeDefinitionHandle typeDefHandle)
        {
            if (this.refToDefCache.TryGetValue(typeRefHandle, out typeDefHandle))
            {
                return !typeDefHandle.IsNil;
            }

            var typeRef = this.Reader.GetTypeReference(typeRefHandle);

            // PERF: check that the ResolutionScope is Module before proceeding.
            foreach (TypeDefinitionHandle tdh in this.Reader.TypeDefinitions)
            {
                TypeDefinition typeDef = this.Reader.GetTypeDefinition(tdh);
                if (typeDef.Name == typeRef.Name && typeDef.Namespace == typeRef.Namespace)
                {
                    if (typeRef.ResolutionScope.Kind == HandleKind.TypeReference)
                    {
                        // The ref is nested. Verify that the type we found is nested in the same type as well.
                        if (this.TryGetTypeDefHandle((TypeReferenceHandle)typeRef.ResolutionScope, out TypeDefinitionHandle nestingTypeDef) && nestingTypeDef == typeDef.GetDeclaringType())
                        {
                            typeDefHandle = tdh;
                            break;
                        }
                    }
                    else if (typeRef.ResolutionScope.Kind == HandleKind.ModuleDefinition && typeDef.GetDeclaringType().IsNil)
                    {
                        typeDefHandle = tdh;
                        break;
                    }
                    else
                    {
                        throw new NotSupportedException("Unrecognized ResolutionScope: " + typeRef.ResolutionScope);
                    }
                }
            }

            this.refToDefCache.Add(typeRefHandle, typeDefHandle);
            return !typeDefHandle.IsNil;
        }

        internal bool IsNonCOMInterface(TypeDefinition interfaceTypeDef)
        {
            if (this.Reader.StringComparer.Equals(interfaceTypeDef.Name, "IUnknown"))
            {
                return false;
            }

            // A conforming interface must have IUnknown as or an ancestor of its first base type.
            InterfaceImplementationHandle firstBaseInterface = interfaceTypeDef.GetInterfaceImplementations().FirstOrDefault();
            if (firstBaseInterface.IsNil)
            {
                return true;
            }

            InterfaceImplementation baseIFace = this.Reader.GetInterfaceImplementation(firstBaseInterface);
            TypeDefinitionHandle baseIFaceTypeDefHandle;
            if (baseIFace.Interface.Kind == HandleKind.TypeDefinition)
            {
                baseIFaceTypeDefHandle = (TypeDefinitionHandle)baseIFace.Interface;
            }
            else if (baseIFace.Interface.Kind == HandleKind.TypeReference)
            {
                if (!this.TryGetTypeDefHandle((TypeReferenceHandle)baseIFace.Interface, out baseIFaceTypeDefHandle))
                {
                    return false;
                }
            }
            else
            {
                return false;
            }

            return this.IsNonCOMInterface(this.Reader.GetTypeDefinition(baseIFaceTypeDefHandle));
        }

        internal bool IsNonCOMInterface(TypeReferenceHandle interfaceTypeRefHandle) => this.TryGetTypeDefHandle(interfaceTypeRefHandle, out TypeDefinitionHandle tdh) && this.IsNonCOMInterface(this.Reader.GetTypeDefinition(tdh));

        internal bool TryFindCustomAttribute(CustomAttributeHandleCollection customAttributes, string @namespace, string name, out CustomAttribute customAttribute)
        {
            foreach (CustomAttributeHandle attHandle in customAttributes)
            {
                customAttribute = this.Reader.GetCustomAttribute(attHandle);
                if (this.IsAttribute(customAttribute, @namespace, name))
                {
                    return true;
                }
            }

            customAttribute = default;
            return false;
        }

        internal FunctionPointerTypeSyntax FunctionPointer(TypeDefinition delegateType)
        {
            CustomAttribute ufpAtt = delegateType.GetCustomAttributes().Select(ah => this.Reader.GetCustomAttribute(ah)).Single(a => this.IsAttribute(a, SystemRuntimeInteropServices, nameof(UnmanagedFunctionPointerAttribute)));
            var attArgs = ufpAtt.DecodeValue(CustomAttributeTypeProvider.Instance);
            CallingConvention callingConvention = (CallingConvention)attArgs.FixedArguments[0].Value!;

            this.GetSignatureForDelegate(delegateType, out MethodDefinition invokeMethodDef, out MethodSignature<TypeHandleInfo> signature, out CustomAttributeHandleCollection? returnTypeAttributes);
            if (returnTypeAttributes?.Any(h => this.IsAttribute(this.Reader.GetCustomAttribute(h), SystemRuntimeInteropServices, nameof(MarshalAsAttribute))) is true)
            {
                throw new NotSupportedException("Marshaling is not supported for function pointers.");
            }

            return this.FunctionPointer(invokeMethodDef, signature);
        }

        internal bool IsDelegate(TypeDefinition typeDef) => (typeDef.Attributes & TypeAttributes.Class) == TypeAttributes.Class && typeDef.BaseType.Kind == HandleKind.TypeReference && this.Reader.StringComparer.Equals(this.Reader.GetTypeReference((TypeReferenceHandle)typeDef.BaseType).Name, nameof(MulticastDelegate));

        internal bool IsManagedType(TypeHandleInfo typeHandleInfo)
        {
            TypeHandleInfo elementType =
                typeHandleInfo is PointerTypeHandleInfo ptr ? ptr.ElementType :
                typeHandleInfo is ArrayTypeHandleInfo array ? array.ElementType :
                typeHandleInfo;
            if (elementType is PointerTypeHandleInfo ptr2)
            {
                return this.IsManagedType(ptr2.ElementType);
            }
            else if (elementType is PrimitiveTypeHandleInfo)
            {
                return false;
            }
            else if (elementType is HandleTypeHandleInfo { Handle: { Kind: HandleKind.TypeDefinition } typeDefHandle })
            {
                return this.IsManagedType((TypeDefinitionHandle)typeDefHandle);
            }
            else if (elementType is HandleTypeHandleInfo { Handle: { Kind: HandleKind.TypeReference } typeRefHandle } handleElement)
            {
                var trh = (TypeReferenceHandle)typeRefHandle;
                if (this.TryGetTypeDefHandle(trh, out TypeDefinitionHandle tdr))
                {
                    return this.IsManagedType(tdr);
                }

                // If the type comes from an external assembly, assume that structs are blittable and anything else is not.
                var tr = this.Reader.GetTypeReference(trh);
                if (tr.ResolutionScope.Kind == HandleKind.AssemblyReference && handleElement.RawTypeKind is byte kind)
                {
                    // Structs set 0x1, classes set 0x2.
                    return (kind & 0x1) == 0;
                }
            }

            throw new GenerationFailedException("Unrecognized type.");
        }

        /// <summary>
        /// Disposes of managed and unmanaged resources.
        /// </summary>
        /// <param name="disposing"><see langword="true"/> if being disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                MetadataIndex.Return(this.MetadataIndex);
            }
        }

        private static SyntaxToken TokenWithNoSpace(SyntaxKind syntaxKind) => SyntaxFactory.Token(TriviaList(), syntaxKind, TriviaList());

        private static SyntaxToken TokenWithSpace(SyntaxKind syntaxKind) => SyntaxFactory.Token(TriviaList(), syntaxKind, TriviaList(Space));

        private static SyntaxToken TokenWithSpaces(SyntaxKind syntaxKind) => SyntaxFactory.Token(TriviaList(Space), syntaxKind, TriviaList(Space));

        private static SyntaxToken TokenWithLineFeed(SyntaxKind syntaxKind) => SyntaxFactory.Token(TriviaList(), syntaxKind, TriviaList(LineFeed));

        private static bool RequiresUnsafe(TypeSyntax? typeSyntax) => typeSyntax is PointerTypeSyntax || typeSyntax is FunctionPointerTypeSyntax;

        private static string GetClassNameForModule(string moduleName) =>
            moduleName.StartsWith("api-", StringComparison.Ordinal) || moduleName.StartsWith("ext-", StringComparison.Ordinal) ? "ApiSets" : moduleName.Replace('-', '_');

        private static AttributeSyntax FieldOffset(int offset) => FieldOffsetAttributeSyntax.AddArgumentListArguments(AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(offset))));

        private static AttributeSyntax StructLayout(TypeAttributes typeAttributes, TypeLayout layout)
        {
            LayoutKind layoutKind = (typeAttributes & TypeAttributes.ExplicitLayout) == TypeAttributes.ExplicitLayout ? LayoutKind.Explicit : LayoutKind.Sequential;
            var structLayoutAttribute = Attribute(IdentifierName("StructLayout")).AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(LayoutKind)),
                    IdentifierName(Enum.GetName(typeof(LayoutKind), layoutKind)!))));

            if (layout.PackingSize > 0)
            {
                structLayoutAttribute = structLayoutAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(layout.PackingSize)))
                        .WithNameEquals(NameEquals(nameof(StructLayoutAttribute.Pack))));
            }

            if (layout.Size > 0)
            {
                structLayoutAttribute = structLayoutAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(layout.Size)))
                        .WithNameEquals(NameEquals(nameof(StructLayoutAttribute.Size))));
            }

            return structLayoutAttribute;
        }

        private static AttributeSyntax GUID(Guid guid)
        {
            return Attribute(IdentifierName("Guid")).AddArgumentListArguments(
                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(guid.ToString().ToUpperInvariant()))));
        }

        private static AttributeSyntax InterfaceType(ComInterfaceType interfaceType)
        {
            return Attribute(IdentifierName("InterfaceType")).AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(ComInterfaceType)),
                    IdentifierName(Enum.GetName(typeof(ComInterfaceType), interfaceType)!))));
        }

        private static AttributeSyntax DllImport(MethodImport import, string moduleName, string? entrypoint)
        {
            var dllImportAttribute = Attribute(IdentifierName("DllImport"))
                .WithArgumentList(FixTrivia(AttributeArgumentList().AddArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(moduleName))),
                    AttributeArgument(LiteralExpression(SyntaxKind.TrueLiteralExpression)).WithNameEquals(NameEquals(nameof(DllImportAttribute.ExactSpelling))))));

            if (entrypoint is object)
            {
                dllImportAttribute = dllImportAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(entrypoint)))
                        .WithNameEquals(NameEquals(nameof(DllImportAttribute.EntryPoint))));
            }

            if ((import.Attributes & MethodImportAttributes.SetLastError) == MethodImportAttributes.SetLastError)
            {
                dllImportAttribute = dllImportAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.TrueLiteralExpression))
                        .WithNameEquals(NameEquals(nameof(DllImportAttribute.SetLastError))));
            }

            return dllImportAttribute;
        }

        private static AttributeSyntax UnmanagedFunctionPointer(CallingConvention callingConvention)
        {
            return Attribute(IdentifierName(nameof(UnmanagedFunctionPointerAttribute)))
                .AddArgumentListArguments(AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(CallingConvention)),
                    IdentifierName(Enum.GetName(typeof(CallingConvention), callingConvention)!))));
        }

        private static AttributeSyntax MarshalAs(UnmanagedType unmanagedType)
        {
            return Attribute(IdentifierName("MarshalAs"))
                .AddArgumentListArguments(AttributeArgument(
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(nameof(UnmanagedType)),
                        IdentifierName(Enum.GetName(typeof(UnmanagedType), unmanagedType)!))));
        }

        private static AttributeSyntax DebuggerBrowsable(DebuggerBrowsableState state)
        {
            return Attribute(IdentifierName("DebuggerBrowsable"))
                .AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(DebuggerBrowsableState)),
                    IdentifierName(Enum.GetName(typeof(DebuggerBrowsableState), state)!))));
        }

        private static AttributeSyntax DebuggerDisplay(string format)
        {
            return Attribute(IdentifierName("DebuggerDisplay"))
                .AddArgumentListArguments(
                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(format))));
        }

        private static SyntaxToken SafeIdentifier(string name) => SafeIdentifierName(name).Identifier;

        private static IdentifierNameSyntax SafeIdentifierName(string name) => IdentifierName(CSharpKeywords.Contains(name) ? "@" + name : name);

        private static string GetHiddenFieldName(string fieldName) => $"__{fieldName}";

        private static CrefParameterListSyntax ToCref(ParameterListSyntax parameterList) => CrefParameterList(FixTrivia(SeparatedList(parameterList.Parameters.Select(ToCref))));

        private static CrefParameterSyntax ToCref(ParameterSyntax parameter)
            => CrefParameter(
                parameter.Modifiers.Any(SyntaxKind.InKeyword) ? TokenWithSpace(SyntaxKind.InKeyword) :
                parameter.Modifiers.Any(SyntaxKind.RefKeyword) ? TokenWithSpace(SyntaxKind.RefKeyword) :
                parameter.Modifiers.Any(SyntaxKind.OutKeyword) ? TokenWithSpace(SyntaxKind.OutKeyword) :
                default,
                parameter.Type!.WithoutTrailingTrivia());

        private static FunctionPointerUnmanagedCallingConventionSyntax ToUnmanagedCallingConventionSyntax(CallingConvention callingConvention)
        {
            return callingConvention switch
            {
                CallingConvention.StdCall => FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall")),
                CallingConvention.Winapi => FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall")), // Winapi isn't a valid string, and only .NET 5 supports runtime-determined calling conventions like Winapi does.
                _ => throw new NotImplementedException(),
            };
        }

        private static bool IsVoid(TypeSyntax typeSyntax) => typeSyntax is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.VoidKeyword } };

        private static bool IsWideFunction(string methodName)
        {
            if (methodName.Length > 1 && methodName.EndsWith("W", StringComparison.Ordinal) && char.IsLower(methodName[methodName.Length - 2]))
            {
                // The name looks very much like an Wide-char method.
                // If further confidence is ever needed, we could look at the parameter and return types
                // to see if they have charset-related metadata in their marshaling metadata.
                return true;
            }

            return false;
        }

        private static bool IsAnsiFunction(string methodName)
        {
            if (methodName.Length > 1 && methodName.EndsWith("A", StringComparison.Ordinal) && char.IsLower(methodName[methodName.Length - 2]))
            {
                // The name looks very much like an Ansi method.
                // If further confidence is ever needed, we could look at the parameter and return types
                // to see if they have charset-related metadata in their marshaling metadata.
                return true;
            }

            return false;
        }

        private static unsafe string ToHex<T>(T value)
            where T : unmanaged
        {
            int fullHexLength = sizeof(T) * 2;
            string hex = string.Format(CultureInfo.InvariantCulture, "0x{0:X" + fullHexLength + "}", value);
            return hex;
        }

        private static ObjectCreationExpressionSyntax GuidValue(CustomAttribute guidAttribute)
        {
            CustomAttributeValue<TypeSyntax> args = guidAttribute.DecodeValue(CustomAttributeTypeProvider.Instance);
            var a = (uint)args.FixedArguments[0].Value!;
            var b = (ushort)args.FixedArguments[1].Value!;
            var c = (ushort)args.FixedArguments[2].Value!;
            var d = (byte)args.FixedArguments[3].Value!;
            var e = (byte)args.FixedArguments[4].Value!;
            var f = (byte)args.FixedArguments[5].Value!;
            var g = (byte)args.FixedArguments[6].Value!;
            var h = (byte)args.FixedArguments[7].Value!;
            var i = (byte)args.FixedArguments[8].Value!;
            var j = (byte)args.FixedArguments[9].Value!;
            var k = (byte)args.FixedArguments[10].Value!;

            return ObjectCreationExpression(IdentifierName(nameof(Guid))).AddArgumentListArguments(
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(a), a))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(b), b))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(c), c))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(d), d))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(e), e))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(f), f))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(g), g))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(h), h))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(i), i))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(j), j))),
                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(k), k))));
        }

        private static ObjectCreationExpressionSyntax PropertyKeyValue(CustomAttribute propertyKeyAttribute)
        {
            CustomAttributeValue<TypeSyntax> args = propertyKeyAttribute.DecodeValue(CustomAttributeTypeProvider.Instance);
            var a = (uint)args.FixedArguments[0].Value!;
            var b = (ushort)args.FixedArguments[1].Value!;
            var c = (ushort)args.FixedArguments[2].Value!;
            var d = (byte)args.FixedArguments[3].Value!;
            var e = (byte)args.FixedArguments[4].Value!;
            var f = (byte)args.FixedArguments[5].Value!;
            var g = (byte)args.FixedArguments[6].Value!;
            var h = (byte)args.FixedArguments[7].Value!;
            var i = (byte)args.FixedArguments[8].Value!;
            var j = (byte)args.FixedArguments[9].Value!;
            var k = (byte)args.FixedArguments[10].Value!;
            var pid = (uint)args.FixedArguments[11].Value!;

            return ObjectCreationExpression(IdentifierName("win32.System.PropertiesSystem.PROPERTYKEY")).WithInitializer(
                InitializerExpression(SyntaxKind.ObjectInitializerExpression, SeparatedList<ExpressionSyntax>(new[]
                {
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("fmtid"), GuidValue(propertyKeyAttribute)),
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("pid"), LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(pid))),
                })));
        }

        /// <summary>
        /// Checks for periods in a name and if found, splits off the last element as the name and considers everything before it to be a namespace.
        /// </summary>
        /// <param name="possiblyQualifiedName">A name or qualified name (e.g. "String" or "System.String").</param>
        /// <param name="namespace">Receives the namespace portion if present in <paramref name="possiblyQualifiedName"/> (e.g. "System"); otherwise <see langword="null"/>.</param>
        /// <param name="name">Receives the name portion from <paramref name="possiblyQualifiedName"/>.</param>
        /// <returns>A value indicating whether a namespace was present in <paramref name="possiblyQualifiedName"/>.</returns>
        private static bool TrySplitPossiblyQualifiedName(string possiblyQualifiedName, [NotNullWhen(true)] out string? @namespace, out string name)
        {
            int nameIdx = possiblyQualifiedName.LastIndexOf('.');
            @namespace = nameIdx >= 0 ? possiblyQualifiedName.Substring(0, nameIdx) : null;
            name = nameIdx >= 0 ? possiblyQualifiedName.Substring(nameIdx) : possiblyQualifiedName;
            return @namespace is object;
        }

        private T AddApiDocumentation<T>(string api, T memberDeclaration)
            where T : MemberDeclarationSyntax
        {
            if (this.ApiDocs is object && this.ApiDocs.TryGetApiDocs(api, out var docs))
            {
                var docCommentsBuilder = new StringBuilder();
                if (docs.Description is object)
                {
                    docCommentsBuilder.Append($@"/// <summary>");
                    EmitDoc(docs.Description, docCommentsBuilder, docs, string.Empty);
                    docCommentsBuilder.AppendLine("</summary>");
                }

                if (docs.Parameters is object)
                {
                    if (memberDeclaration is BaseMethodDeclarationSyntax methodDecl)
                    {
                        foreach (var entry in docs.Parameters)
                        {
                            if (!methodDecl.ParameterList.Parameters.Any(p => string.Equals(p.Identifier.ValueText, entry.Key, StringComparison.Ordinal)))
                            {
                                // Skip documentation for parameters that do not actually exist on the method.
                                continue;
                            }

                            docCommentsBuilder.Append($@"/// <param name=""{entry.Key}"">");
                            EmitDoc(entry.Value, docCommentsBuilder, docs, "parameters");
                            docCommentsBuilder.AppendLine("</param>");
                        }
                    }
                }

                if (docs.Fields is object)
                {
                    var fieldsDocBuilder = new StringBuilder();
                    switch (memberDeclaration)
                    {
                        case StructDeclarationSyntax structDeclaration:
                            memberDeclaration = memberDeclaration.ReplaceNodes(
                                structDeclaration.Members.OfType<FieldDeclarationSyntax>(),
                                (_, field) =>
                                {
                                    var variable = field.Declaration.Variables.Single();
                                    if (docs.Fields.TryGetValue(variable.Identifier.ValueText, out string? fieldDoc))
                                    {
                                        fieldsDocBuilder.Append("/// <summary>");
                                        EmitDoc(fieldDoc, fieldsDocBuilder, docs, "members");
                                        fieldsDocBuilder.AppendLine("</summary>");
                                        if (field.Declaration.Type.HasAnnotations(OriginalDelegateAnnotation))
                                        {
                                            fieldsDocBuilder.AppendLine(@$"/// <remarks>See the <see cref=""{field.Declaration.Type.GetAnnotations(OriginalDelegateAnnotation).Single().Data}"" /> delegate for more about this function.</remarks>");
                                        }

                                        field = field.WithLeadingTrivia(ParseLeadingTrivia(fieldsDocBuilder.ToString().Replace("\r\n", "\n")));
                                        fieldsDocBuilder.Clear();
                                    }

                                    return field;
                                });
                            break;
                        case EnumDeclarationSyntax enumDeclaration:
                            memberDeclaration = memberDeclaration.ReplaceNodes(
                                enumDeclaration.Members,
                                (_, field) =>
                                {
                                    if (docs.Fields.TryGetValue(field.Identifier.ValueText, out string? fieldDoc))
                                    {
                                        fieldsDocBuilder.Append($@"/// <summary>");
                                        EmitDoc(fieldDoc, fieldsDocBuilder, docs, "members");
                                        fieldsDocBuilder.AppendLine("</summary>");
                                        field = field.WithLeadingTrivia(ParseLeadingTrivia(fieldsDocBuilder.ToString().Replace("\r\n", "\n")));
                                        fieldsDocBuilder.Clear();
                                    }

                                    return field;
                                });
                            break;
                    }
                }

                if (docs.ReturnValue is object)
                {
                    docCommentsBuilder.Append("/// <returns>");
                    EmitDoc(docs.ReturnValue, docCommentsBuilder, docs: null, string.Empty);
                    docCommentsBuilder.AppendLine("</returns>");
                }

                if (docs.Remarks is object || docs.HelpLink is object)
                {
                    docCommentsBuilder.Append($"/// <remarks>");
                    if (docs.Remarks is object)
                    {
                        EmitDoc(docs.Remarks, docCommentsBuilder, docs, string.Empty);
                    }
                    else if (docs.HelpLink is object)
                    {
                        docCommentsBuilder.AppendLine();
                        docCommentsBuilder.AppendLine($@"/// <para><see href=""{docs.HelpLink}"">Learn more about this API from docs.microsoft.com</see>.</para>");
                        docCommentsBuilder.Append("/// ");
                    }

                    docCommentsBuilder.AppendLine($"</remarks>");
                }

                memberDeclaration = memberDeclaration.WithLeadingTrivia(
                    ParseLeadingTrivia(docCommentsBuilder.ToString().Replace("\r\n", "\n")));
            }

            return memberDeclaration;

            static void EmitLine(StringBuilder stringBuilder, string yamlDocSrc)
            {
                stringBuilder.Append(yamlDocSrc.Trim());
            }

            static void EmitDoc(string yamlDocSrc, StringBuilder docCommentsBuilder, ApiDetails? docs, string docsAnchor)
            {
                if (yamlDocSrc.Contains('\n'))
                {
                    docCommentsBuilder.AppendLine();
                    var docReader = new StringReader(yamlDocSrc);
                    string? paramDocLine;

                    bool inParagraph = false;
                    bool inComment = false;
                    int blankLineCounter = 0;
                    while ((paramDocLine = docReader.ReadLine()) is object)
                    {
                        if (string.IsNullOrWhiteSpace(paramDocLine))
                        {
                            if (++blankLineCounter >= 2 && inParagraph)
                            {
                                docCommentsBuilder.AppendLine("</para>");
                                inParagraph = false;
                                inComment = false;
                            }

                            continue;
                        }
                        else if (blankLineCounter > 0)
                        {
                            blankLineCounter = 0;
                        }
                        else if (docCommentsBuilder.Length > 0 && docCommentsBuilder[docCommentsBuilder.Length - 1] != '\n')
                        {
                            docCommentsBuilder.Append(' ');
                        }

                        if (inParagraph)
                        {
                            if (docCommentsBuilder.Length > 0 && docCommentsBuilder[docCommentsBuilder.Length - 1] is not (' ' or '\n'))
                            {
                                docCommentsBuilder.Append(' ');
                            }
                        }
                        else
                        {
                            docCommentsBuilder.Append("/// <para>");
                            inParagraph = true;
                            inComment = true;
                        }

                        if (!inComment)
                        {
                            docCommentsBuilder.Append("/// ");
                        }

                        if (paramDocLine.IndexOf("<table", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<img", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<ul", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<ol", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("```", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<<", StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            // We don't try to format tables, so truncate at this point.
                            if (inParagraph)
                            {
                                docCommentsBuilder.AppendLine("</para>");
                                inParagraph = false;
                                inComment = false;
                            }

                            docCommentsBuilder.AppendLine($@"/// <para>This doc was truncated.</para>");

                            break; // is this the right way?
                        }

                        EmitLine(docCommentsBuilder, paramDocLine);
                    }

                    if (inParagraph)
                    {
                        if (!inComment)
                        {
                            docCommentsBuilder.Append("/// ");
                        }

                        docCommentsBuilder.AppendLine("</para>");
                        inParagraph = false;
                        inComment = false;
                    }

                    if (docs is object)
                    {
                        docCommentsBuilder.AppendLine($@"/// <para><see href=""{docs.HelpLink}#{docsAnchor}"">Read more on docs.microsoft.com</see>.</para>");
                    }

                    docCommentsBuilder.Append("/// ");
                }
                else
                {
                    EmitLine(docCommentsBuilder, yamlDocSrc);
                }
            }
        }

        private MemberDeclarationSyntax FetchTemplate(string name)
        {
            if (!this.TryFetchTemplate(name, out MemberDeclarationSyntax? result))
            {
                throw new KeyNotFoundException();
            }

            return result;
        }

        private bool TryFetchTemplate(string name, [NotNullWhen(true)] out MemberDeclarationSyntax? member)
        {
            using Stream? templateStream = Assembly.GetExecutingAssembly().GetManifestResourceStream($"{ThisAssembly.RootNamespace}.templates.{name.Replace('/', '.')}.cs");
            if (templateStream is null)
            {
                member = null;
                return false;
            }

            using StreamReader sr = new(templateStream);
            string template = sr.ReadToEnd().Replace("\r\n", "\n").Replace("\t", string.Empty);
            member = ParseMemberDeclaration(template) ?? throw new GenerationFailedException($"Unable to parse a type from a template: {name}");
            member = this.ElevateVisibility(member);
            return true;
        }

        private FunctionPointerTypeSyntax FunctionPointer(MethodDefinition methodDefinition, MethodSignature<TypeHandleInfo> signature)
        {
            FunctionPointerCallingConventionSyntax callingConventionSyntax = FunctionPointerCallingConvention(
                Token(SyntaxKind.UnmanagedKeyword),
                FunctionPointerUnmanagedCallingConventionList(SingletonSeparatedList(ToUnmanagedCallingConventionSyntax(CallingConvention.StdCall))));

            FunctionPointerParameterListSyntax parametersList = FunctionPointerParameterList();

            foreach (ParameterHandle parameterHandle in methodDefinition.GetParameters())
            {
                var parameter = this.Reader.GetParameter(parameterHandle);
                if (parameter.SequenceNumber == 0)
                {
                    continue;
                }

                var parameterTypeInfo = signature.ParameterTypes[parameter.SequenceNumber - 1];
                parametersList = parametersList.AddParameters(this.TranslateDelegateToFunctionPointer(parameterTypeInfo, parameter.GetCustomAttributes()));
            }

            parametersList = parametersList.AddParameters(this.TranslateDelegateToFunctionPointer(signature.ReturnType, this.GetReturnTypeCustomAttributes(methodDefinition)));

            return FunctionPointerType(callingConventionSyntax, parametersList);
        }

        private FunctionPointerParameterSyntax TranslateDelegateToFunctionPointer(TypeHandleInfo parameterTypeInfo, CustomAttributeHandleCollection? customAttributeHandles)
        {
            if (this.IsDelegateReference(parameterTypeInfo, out TypeDefinition delegateTypeDef))
            {
                return FunctionPointerParameter(this.FunctionPointer(delegateTypeDef));
            }

            return FunctionPointerParameter(parameterTypeInfo.ToTypeSyntax(this.functionPointerTypeSettings, customAttributeHandles).GetUnmarshaledType());
        }

        private bool TryGetRenamedMethod(string methodName, [NotNullWhen(true)] out string? newName)
        {
            if (this.WideCharOnly && IsWideFunction(methodName))
            {
                newName = methodName.Substring(0, methodName.Length - 1);
                return !this.GetMethodByName(newName, exactNameMatchOnly: true).HasValue;
            }

            newName = null;
            return false;
        }

        private CustomAttributeHandleCollection? GetReturnTypeCustomAttributes(MethodDefinition methodDefinition)
        {
            CustomAttributeHandleCollection? returnTypeAttributes = null;
            foreach (ParameterHandle parameterHandle in methodDefinition.GetParameters())
            {
                var parameter = this.Reader.GetParameter(parameterHandle);
                if (parameter.Name.IsNil)
                {
                    returnTypeAttributes = parameter.GetCustomAttributes();
                }

                // What we're looking for would always be the first element in the collection.
                break;
            }

            return returnTypeAttributes;
        }

        private bool IsCompilerGenerated(TypeDefinition typeDef)
        {
            bool isCompilerGenerated = false;
            foreach (CustomAttributeHandle attHandle in typeDef.GetCustomAttributes())
            {
                var att = this.Reader.GetCustomAttribute(attHandle);
                if (this.IsAttribute(att, SystemRuntimeCompilerServices, nameof(CompilerGeneratedAttribute)))
                {
                    isCompilerGenerated = true;
                    break;
                }
            }

            return isCompilerGenerated;
        }

        private ISymbol? FindSymbolIfAlreadyAvailable(string fullyQualifiedMetadataName)
        {
            if (this.compilation is object)
            {
                if (this.compilation.Assembly.GetTypeByMetadataName(fullyQualifiedMetadataName) is { } ownSymbol)
                {
                    // This assembly defines it.
                    // But if it defines it as a partial, we should not consider it as fully defined so we populate our side.
                    return ownSymbol.DeclaringSyntaxReferences.Any(sr => sr.GetSyntax() is BaseTypeDeclarationSyntax type && type.Modifiers.Any(SyntaxKind.PartialKeyword))
                        ? null
                        : ownSymbol;
                }

                foreach (var reference in this.compilation.References)
                {
                    if (this.compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol referencedAssembly)
                    {
                        if (referencedAssembly.GetTypeByMetadataName(fullyQualifiedMetadataName) is { } externalSymbol)
                        {
                            if (this.compilation.IsSymbolAccessibleWithin(externalSymbol, this.compilation.Assembly))
                            {
                                // A referenced assembly declares this symbol and it is accessible to our own.
                                return externalSymbol;
                            }
                        }
                    }
                }
            }

            return null;
        }

        private MemberDeclarationSyntax? RequestInteropType(TypeDefinitionHandle typeDefHandle, NameSyntax? declaringType)
        {
            TypeDefinition typeDef = this.Reader.GetTypeDefinition(typeDefHandle);
            if (this.IsCompilerGenerated(typeDef))
            {
                return null;
            }

            // Skip if the compilation already defines this type or can access it from elsewhere.
            string name = this.Reader.GetString(typeDef.Name);
            string ns = this.Reader.GetString(typeDef.Namespace);
            string fullyQualifiedName = ns + "." + name;
            if (this.FindSymbolIfAlreadyAvailable(fullyQualifiedName) is object)
            {
                // The type already exists either in this project or a referenced one.
                return null;
            }

            try
            {
                StringHandle baseTypeName, baseTypeNamespace;
                this.GetBaseTypeInfo(typeDef, out baseTypeName, out baseTypeNamespace);

                MemberDeclarationSyntax? typeDeclaration;

                if ((typeDef.Attributes & TypeAttributes.Interface) == TypeAttributes.Interface)
                {
                    typeDeclaration = this.DeclareInterface(typeDef);
                }
                else if (this.Reader.StringComparer.Equals(baseTypeName, nameof(ValueType)) && this.Reader.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    // Is this a special typedef struct?
                    if (this.IsTypeDefStruct(typeDef))
                    {
                        typeDeclaration = this.DeclareTypeDefStruct(typeDef);
                    }
                    else
                    {
                        StructDeclarationSyntax structDeclaration = this.DeclareStruct(typeDef);

                        // Proactively generate all nested types as well.
                        NameSyntax nestedDeclaringType = declaringType is null ? IdentifierName(name) : QualifiedName(declaringType, IdentifierName(name));
                        foreach (TypeDefinitionHandle nestedHandle in typeDef.GetNestedTypes())
                        {
                            if (this.RequestInteropType(nestedHandle, nestedDeclaringType) is { } nestedType)
                            {
                                structDeclaration = structDeclaration.AddMembers(nestedType);
                            }
                        }

                        typeDeclaration = structDeclaration;
                    }
                }
                else if (this.Reader.StringComparer.Equals(baseTypeName, nameof(Enum)) && this.Reader.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    // Consider reusing .NET types like FILE_SHARE_FLAGS -> System.IO.FileShare
                    typeDeclaration = this.DeclareEnum(typeDef);
                }
                else if (this.options.AllowMarshaling && this.Reader.StringComparer.Equals(baseTypeName, nameof(MulticastDelegate)) && this.Reader.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    typeDeclaration = this.DeclareDelegate(typeDef);
                }
                else
                {
                    // not yet supported.
                    return null;
                }

                return typeDeclaration;
            }
            catch (Exception ex)
            {
                throw new GenerationFailedException("Failed to generate " + this.Reader.GetString(typeDef.Name), ex);
            }
        }

        private bool IsTypeDefStruct(TypeDefinition typeDef) => typeDef.GetCustomAttributes().Any(att => this.IsAttribute(this.Reader.GetCustomAttribute(att), InteropDecorationNamespace, NativeTypedefAttribute));

        private void DeclareExternMethod(MethodDefinitionHandle methodDefinitionHandle)
        {
            MethodDefinition methodDefinition = this.Reader.GetMethodDefinition(methodDefinitionHandle);
            MethodImport import = methodDefinition.GetImport();
            if (import.Name.IsNil)
            {
                // Not an exported method.
                return;
            }

            var methodName = this.Reader.GetString(methodDefinition.Name);
            try
            {
                if (this.WideCharOnly && IsAnsiFunction(methodName))
                {
                    // Skip Ansi functions.
                    return;
                }

                var moduleName = this.GetNormalizedModuleName(import);

                string? entrypoint = null;
                if (this.TryGetRenamedMethod(methodName, out string? newName))
                {
                    entrypoint = methodName;
                    methodName = newName;
                }

                // If this method releases a handle, recreate the method signature such that we take the struct rather than the SafeHandle as a parameter.
                TypeSyntaxSettings typeSettings = this.MetadataIndex.ReleaseMethods.Contains(entrypoint ?? methodName) ? this.externReleaseSignatureTypeSettings : this.externSignatureTypeSettings;
                MethodSignature<TypeHandleInfo> signature = methodDefinition.DecodeSignature(SignatureHandleProvider.Instance, null);

                CustomAttributeHandleCollection? returnTypeAttributes = this.GetReturnTypeCustomAttributes(methodDefinition);
                var returnType = signature.ReturnType.ToTypeSyntax(typeSettings, returnTypeAttributes, ParameterAttributes.Out);

                MethodDeclarationSyntax methodDeclaration = MethodDeclaration(
                    List<AttributeListSyntax>()
                        .Add(AttributeList()
                            .WithCloseBracketToken(TokenWithLineFeed(SyntaxKind.CloseBracketToken))
                            .AddAttributes(DllImport(import, moduleName, entrypoint))),
                    modifiers: TokenList(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.ExternKeyword)),
                    returnType.Type.WithTrailingTrivia(TriviaList(Space)),
                    explicitInterfaceSpecifier: null!,
                    SafeIdentifier(methodName),
                    null!,
                    FixTrivia(this.CreateParameterList(methodDefinition, signature, typeSettings)),
                    List<TypeParameterConstraintClauseSyntax>(),
                    body: null!,
                    TokenWithLineFeed(SyntaxKind.SemicolonToken));
                methodDeclaration = returnType.AddReturnMarshalAs(methodDeclaration);

                if (this.generateDefaultDllImportSearchPathsAttribute)
                {
                    methodDeclaration = methodDeclaration.AddAttributeLists(DefaultDllImportSearchPathsAttributeList);
                }

                if (this.GetSupportedOSPlatformAttribute(methodDefinition.GetCustomAttributes()) is AttributeSyntax supportedOSPlatformAttribute)
                {
                    methodDeclaration = methodDeclaration.AddAttributeLists(AttributeList().AddAttributes(supportedOSPlatformAttribute));
                }

                // Add documentation if we can find it.
                methodDeclaration = this.AddApiDocumentation(entrypoint ?? methodName, methodDeclaration);

                if (RequiresUnsafe(methodDeclaration.ReturnType) || methodDeclaration.ParameterList.Parameters.Any(p => RequiresUnsafe(p.Type)))
                {
                    methodDeclaration = methodDeclaration.AddModifiers(TokenWithSpace(SyntaxKind.UnsafeKeyword));
                }

                NameSyntax declaringTypeName = ParseName(this.GroupByModule ? GetClassNameForModule(moduleName) : this.SingleClassName);
                this.volatileCode.AddMemberToModule(moduleName, this.DeclareFriendlyOverloads(methodDefinition, methodDeclaration, declaringTypeName, FriendlyOverloadOf.ExternMethod));
                this.volatileCode.AddMemberToModule(moduleName, methodDeclaration);
            }
            catch (Exception ex)
            {
                throw new GenerationFailedException($"Failed while generating extern method: {methodName}", ex);
            }
        }

        private bool IsCompatibleWithPlatform(CustomAttributeHandleCollection customAttributesOnMember) => MetadataUtilities.IsCompatibleWithPlatform(this.Reader, this.MetadataIndex, this.compilation?.Options.Platform, customAttributesOnMember);

        private AttributeSyntax? GetSupportedOSPlatformAttribute(CustomAttributeHandleCollection attributes)
        {
            AttributeSyntax? supportedOSPlatformAttribute = null;
            if (this.generateSupportedOSPlatformAttributes && this.FindInteropDecorativeAttribute(attributes, "SupportedOSPlatformAttribute") is CustomAttribute templateOSPlatformAttribute)
            {
                CustomAttributeValue<TypeSyntax> args = templateOSPlatformAttribute.DecodeValue(CustomAttributeTypeProvider.Instance);
                supportedOSPlatformAttribute = SupportedOSPlatformAttribute.AddArgumentListArguments(AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal((string)args.FixedArguments[0].Value!))));
            }

            return supportedOSPlatformAttribute;
        }

        /// <summary>
        /// Searches for an extern method.
        /// </summary>
        /// <param name="possiblyQualifiedName">A simple method name or one qualified with a namespace.</param>
        /// <param name="exactNameMatchOnly"><see langword="true"/> to only match on an exact method name; <see langword="false"/> to allow for fuzzy matching such as an omitted W or A suffix.</param>
        /// <returns>The matching method if exactly one is found, or <see langword="null"/> if none was found.</returns>
        /// <exception cref="ArgumentException">Thrown if the <paramref name="possiblyQualifiedName"/> argument is not qualified and more than one matching method name was found.</exception>
        private MethodDefinitionHandle? GetMethodByName(string possiblyQualifiedName, bool exactNameMatchOnly = false)
        {
            TrySplitPossiblyQualifiedName(possiblyQualifiedName, out string? methodNamespace, out string methodName);
            return this.GetMethodByName(methodNamespace, methodName, exactNameMatchOnly);
        }

        /// <summary>
        /// Searches for an extern method.
        /// </summary>
        /// <param name="methodNamespace">The namespace the method is found in, if known.</param>
        /// <param name="methodName">The simple name of the method.</param>
        /// <param name="exactNameMatchOnly"><see langword="true"/> to only match on an exact method name; <see langword="false"/> to allow for fuzzy matching such as an omitted W or A suffix.</param>
        /// <returns>The matching method if exactly one is found, or <see langword="null"/> if none was found.</returns>
        private MethodDefinitionHandle? GetMethodByName(string? methodNamespace, string methodName, bool exactNameMatchOnly = false)
        {
            IEnumerable<NamespaceMetadata> namespaces = this.GetNamespacesToSearch(methodNamespace);
            bool foundApiWithMismatchedPlatform = false;

            var matchingMethodHandles = new List<MethodDefinitionHandle>();
            foreach (var nsMetadata in namespaces)
            {
                if (nsMetadata.Methods.TryGetValue(methodName, out MethodDefinitionHandle handle))
                {
                    matchingMethodHandles.Add(handle);
                }
                else if (nsMetadata.MethodsForOtherPlatform.Contains(methodName))
                {
                    foundApiWithMismatchedPlatform = true;
                }
            }

            if (!exactNameMatchOnly && matchingMethodHandles.Count == 0)
            {
                foreach (var nsMetadata in namespaces)
                {
                    if (nsMetadata.Methods.TryGetValue(methodName + "W", out MethodDefinitionHandle handle) ||
                        nsMetadata.Methods.TryGetValue(methodName + "A", out handle))
                    {
                        matchingMethodHandles.Add(handle);
                    }
                }
            }

            if (matchingMethodHandles.Count == 1)
            {
                return matchingMethodHandles[0];
            }
            else if (matchingMethodHandles.Count > 1)
            {
                string matches = string.Join(
                    ", ",
                    matchingMethodHandles.Select(h =>
                    {
                        MethodDefinition md = this.Reader.GetMethodDefinition(h);
                        TypeDefinition td = this.Reader.GetTypeDefinition(md.GetDeclaringType());
                        return $"{this.Reader.GetString(td.Namespace)}.{this.Reader.GetString(md.Name)}";
                    }));
                throw new ArgumentException("The method name is ambiguous. Use the fully-qualified name instead. Possible matches: " + matches);
            }

            if (foundApiWithMismatchedPlatform)
            {
                throw new PlatformIncompatibleException($"The requested API ({methodName}) was found but is not available given the target platform ({this.compilation?.Options.Platform}).");
            }

            return null;
        }

        private void TryGenerateTypeOrThrow(string possiblyQualifiedName)
        {
            if (!this.TryGenerateType(possiblyQualifiedName))
            {
                throw new GenerationFailedException("Unable to find expected type: " + possiblyQualifiedName);
            }
        }

        private void TryGenerateConstantOrThrow(string possiblyQualifiedName)
        {
            if (!this.TryGenerateConstant(possiblyQualifiedName))
            {
                throw new GenerationFailedException("Unable to find expected constant: " + possiblyQualifiedName);
            }
        }

        private FieldDeclarationSyntax DeclareConstant(FieldDefinitionHandle fieldDefHandle)
        {
            FieldDefinition fieldDef = this.Reader.GetFieldDefinition(fieldDefHandle);
            string name = this.Reader.GetString(fieldDef.Name);
            try
            {
                bool isConst = (fieldDef.Attributes & FieldAttributes.HasDefault) == FieldAttributes.HasDefault;
                TypeHandleInfo fieldTypeInfo = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null) with { IsConstantField = true };
                var customAttributes = fieldDef.GetCustomAttributes();
                var fieldType = fieldTypeInfo.ToTypeSyntax(this.fieldTypeSettings, customAttributes);
                ExpressionSyntax value =
                    fieldDef.GetDefaultValue() is { IsNil: false } constantHandle ? this.ToExpressionSyntax(this.Reader.GetConstant(constantHandle)) :
                    this.FindInteropDecorativeAttribute(customAttributes, nameof(GuidAttribute)) is CustomAttribute guidAttribute ? GuidValue(guidAttribute) :
                    this.FindInteropDecorativeAttribute(customAttributes, "PropertyKeyAttribute") is CustomAttribute propertyKeyAttribute ? PropertyKeyValue(propertyKeyAttribute) :
                    throw new NotSupportedException("Unsupported constant: " + name);
                bool requiresUnsafe = false;
                if (fieldType.Type is not PredefinedTypeSyntax && value is not ObjectCreationExpressionSyntax)
                {
                    if (fieldTypeInfo is HandleTypeHandleInfo handleFieldTypeInfo && this.TryGetHandleReleaseMethod(handleFieldTypeInfo.Handle, out _))
                    {
                        // Cast to IntPtr first, then the actual handle struct.
                        value = CastExpression(fieldType.Type, CastExpression(IntPtrTypeSyntax, ParenthesizedExpression(value)));
                    }
                    else if (fieldType.Type is QualifiedNameSyntax { Right: { Identifier: { ValueText: "PCWSTR" } } })
                    {
                        value = CastExpression(PointerType(PredefinedType(Token(SyntaxKind.CharKeyword))), ParenthesizedExpression(value));
                        requiresUnsafe = true;
                    }
                    else
                    {
                        value = CastExpression(fieldType.Type, ParenthesizedExpression(value));
                    }
                }

                var modifiers = TokenList(TokenWithSpace(this.Visibility));
                if (this.IsTypeDefStruct(fieldTypeInfo) || value is ObjectCreationExpressionSyntax)
                {
                    modifiers = modifiers.Add(TokenWithSpace(SyntaxKind.StaticKeyword)).Add(TokenWithSpace(SyntaxKind.ReadOnlyKeyword));
                }
                else
                {
                    modifiers = modifiers.Add(TokenWithSpace(SyntaxKind.ConstKeyword));
                }

                if (requiresUnsafe)
                {
                    modifiers = modifiers.Add(TokenWithSpace(SyntaxKind.UnsafeKeyword));
                }

                var result = FieldDeclaration(VariableDeclaration(fieldType.Type).AddVariables(
                    VariableDeclarator(Identifier(name)).WithInitializer(EqualsValueClause(value))))
                    .WithModifiers(modifiers);
                result = fieldType.AddMarshalAs(result);
                return result;
            }
            catch (Exception ex)
            {
                TypeDefinition typeDef = this.Reader.GetTypeDefinition(fieldDef.GetDeclaringType());
                string typeName = this.Reader.GetString(typeDef.Name);
                string? ns = this.Reader.GetString(typeDef.Namespace);
                throw new GenerationFailedException($"Failed creating field: {ns}.{typeName}.{name}", ex);
            }
        }

        private ClassDeclarationSyntax DeclareConstantDefiningClass()
        {
            return ClassDeclaration(ConstantsClassName.Identifier)
                .AddMembers(this.committedCode.Fields.ToArray())
                .WithModifiers(TokenList(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.PartialKeyword)));
        }

        private ClassDeclarationSyntax DeclareInlineArrayIndexerExtensionsClass()
        {
            return ClassDeclaration(InlineArrayIndexerExtensionsClassName.Identifier)
                .AddMembers(this.committedCode.InlineArrayIndexerExtensions.ToArray())
                .WithModifiers(TokenList(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.PartialKeyword)));
        }

        private ClassDeclarationSyntax DeclareComInterfaceFriendlyExtensionsClass()
        {
            return ClassDeclaration(ComInterfaceFriendlyExtensionsClassName.Identifier)
                .AddMembers(this.committedCode.ComInterfaceExtensions.ToArray())
                .WithModifiers(TokenList(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.PartialKeyword)));
        }

        /// <summary>
        /// Generates a type to represent a COM interface.
        /// </summary>
        /// <param name="typeDef">The type definition of the interface.</param>
        /// <returns>The type declaration.</returns>
        /// <remarks>
        /// COM interfaces are represented as structs in order to maintain the "unmanaged type" trait
        /// so that all structs are blittable.
        /// </remarks>
        private TypeDeclarationSyntax? DeclareInterface(TypeDefinition typeDef)
        {
            Stack<TypeDefinitionHandle> baseTypes = new Stack<TypeDefinitionHandle>();
            InterfaceImplementationHandle baseTypeHandle = typeDef.GetInterfaceImplementations().SingleOrDefault();
            while (!baseTypeHandle.IsNil)
            {
                InterfaceImplementation baseTypeImpl = this.Reader.GetInterfaceImplementation(baseTypeHandle);
                if (!this.TryGetTypeDefHandle((TypeReferenceHandle)baseTypeImpl.Interface, out TypeDefinitionHandle baseTypeDefHandle))
                {
                    throw new GenerationFailedException("Failed to find base type.");
                }

                baseTypes.Push(baseTypeDefHandle);
                TypeDefinition baseType = this.Reader.GetTypeDefinition(baseTypeDefHandle);
                baseTypeHandle = baseType.GetInterfaceImplementations().SingleOrDefault();
            }

            return !this.options.AllowMarshaling || this.IsNonCOMInterface(typeDef)
                ? this.DeclareInterfaceAsStruct(typeDef, baseTypes)
                : this.DeclareInterfaceAsInterface(typeDef, baseTypes);
        }

        private TypeDeclarationSyntax DeclareInterfaceAsStruct(TypeDefinition typeDef, Stack<TypeDefinitionHandle> baseTypes)
        {
            IdentifierNameSyntax ifaceName = IdentifierName(this.Reader.GetString(typeDef.Name));
            IdentifierNameSyntax vtblFieldName = IdentifierName("lpVtbl");
            var members = new List<MemberDeclarationSyntax>();
            var vtblMembers = new List<MemberDeclarationSyntax>();
            TypeSyntaxSettings typeSettings = this.comSignatureTypeSettings;

            // It is imperative that we generate methods for all base interfaces as well, ahead of any implemented by *this* interface.
            var allMethods = new List<MethodDefinitionHandle>();
            while (baseTypes.Count > 0)
            {
                TypeDefinition baseType = this.Reader.GetTypeDefinition(baseTypes.Pop());
                allMethods.AddRange(baseType.GetMethods());
            }

            allMethods.AddRange(typeDef.GetMethods());
            int methodCounter = 0;
            foreach (MethodDefinitionHandle methodDefHandle in allMethods)
            {
                methodCounter++;
                var methodDefinition = this.Reader.GetMethodDefinition(methodDefHandle);
                string methodName = this.Reader.GetString(methodDefinition.Name);
                IdentifierNameSyntax innerMethodName = IdentifierName($"{methodName}_{methodCounter}");

                MethodSignature<TypeHandleInfo> signature = methodDefinition.DecodeSignature(SignatureHandleProvider.Instance, null);
                CustomAttributeHandleCollection? returnTypeAttributes = this.GetReturnTypeCustomAttributes(methodDefinition);
                var returnType = signature.ReturnType.ToTypeSyntax(typeSettings, returnTypeAttributes);

                ParameterListSyntax parameterList = this.CreateParameterList(methodDefinition, signature, typeSettings);
                FunctionPointerParameterListSyntax funcPtrParameters = FunctionPointerParameterList()
                    .AddParameters(FunctionPointerParameter(PointerType(ifaceName)))
                    .AddParameters(parameterList.Parameters.Select(p => FunctionPointerParameter(p.Type!).WithModifiers(p.Modifiers)).ToArray())
                    .AddParameters(FunctionPointerParameter(returnType.Type));

                FieldDeclarationSyntax vtblFunctionPtr = FieldDeclaration(
                    VariableDeclaration(
                        FunctionPointerType().WithCallingConvention(FunctionPointerCallingConvention(TokenWithSpace(SyntaxKind.UnmanagedKeyword))
                            .WithUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionList(
                                SingletonSeparatedList(FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall"))))))
                        .WithParameterList(funcPtrParameters))
                    .WithVariables(SingletonSeparatedList(VariableDeclarator(innerMethodName.Identifier))))
                    .WithModifiers(TokenList(TokenWithSpace(SyntaxKind.InternalKeyword)));
                vtblMembers.Add(vtblFunctionPtr);

                IdentifierNameSyntax pThisLocal = IdentifierName("pThis");
                InvocationExpressionSyntax vtblInvocation = InvocationExpression(MemberAccessExpression(SyntaxKind.PointerMemberAccessExpression, vtblFieldName, innerMethodName))
                    .WithArgumentList(FixTrivia(ArgumentList()
                        .AddArguments(Argument(pThisLocal))
                        .AddArguments(parameterList.Parameters.Select(p => Argument(IdentifierName(p.Identifier.ValueText)).WithRefKindKeyword(p.Modifiers.Count > 0 ? p.Modifiers[0] : default)).ToArray())));
                StatementSyntax vtblInvocationStatement = IsVoid(returnType.Type)
                    ? ExpressionStatement(vtblInvocation)
                    : ReturnStatement(vtblInvocation);
                var body = Block().AddStatements(
                    FixedStatement(
                        VariableDeclaration(PointerType(ifaceName)).AddVariables(
                            VariableDeclarator(pThisLocal.Identifier).WithInitializer(EqualsValueClause(PrefixUnaryExpression(SyntaxKind.AddressOfExpression, ThisExpression())))),
                        vtblInvocationStatement).WithFixedKeyword(TokenWithSpace(SyntaxKind.FixedKeyword)));

                MethodDeclarationSyntax methodDeclaration = MethodDeclaration(
                    List<AttributeListSyntax>(),
                    modifiers: TokenList(TokenWithSpace(this.Visibility)),
                    returnType.Type.WithTrailingTrivia(TriviaList(Space)),
                    explicitInterfaceSpecifier: null!,
                    SafeIdentifier(methodName),
                    null!,
                    parameterList,
                    List<TypeParameterConstraintClauseSyntax>(),
                    body: body,
                    semicolonToken: default);
                methodDeclaration = returnType.AddReturnMarshalAs(methodDeclaration);

                if (methodName == nameof(object.GetType) && parameterList.Parameters.Count == 0)
                {
                    methodDeclaration = methodDeclaration.AddModifiers(TokenWithSpace(SyntaxKind.NewKeyword));
                }

                if (methodDeclaration.ReturnType is PointerTypeSyntax || methodDeclaration.ParameterList.Parameters.Any(p => p.Type is PointerTypeSyntax))
                {
                    methodDeclaration = methodDeclaration.AddModifiers(TokenWithSpace(SyntaxKind.UnsafeKeyword));
                }

                // Add documentation if we can find it.
                methodDeclaration = this.AddApiDocumentation($"{ifaceName}.{methodName}", methodDeclaration);

                members.AddRange(this.DeclareFriendlyOverloads(methodDefinition, methodDeclaration, IdentifierName(ifaceName.Identifier.ValueText), FriendlyOverloadOf.StructMethod));
                members.Add(methodDeclaration);
            }

            var vtblStruct = StructDeclaration(Identifier("Vtbl"))
                .AddMembers(vtblMembers.ToArray())
                .AddModifiers(TokenWithSpace(SyntaxKind.PrivateKeyword));
            members.Add(vtblStruct);

            // private Vtbl* lpVtbl;
            members.Add(FieldDeclaration(VariableDeclaration(PointerType(IdentifierName(vtblStruct.Identifier))).AddVariables(VariableDeclarator(vtblFieldName.Identifier))).AddModifiers(TokenWithSpace(SyntaxKind.PrivateKeyword)));

            StructDeclarationSyntax iface = StructDeclaration(ifaceName.Identifier)
                .AddModifiers(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.UnsafeKeyword))
                .AddMembers(members.ToArray());

            if (this.FindGuidFromAttribute(typeDef) is Guid guid)
            {
                iface = iface.AddAttributeLists(AttributeList().AddAttributes(GUID(guid)));
            }

            if (this.GetSupportedOSPlatformAttribute(typeDef.GetCustomAttributes()) is AttributeSyntax supportedOSPlatformAttribute)
            {
                iface = iface.AddAttributeLists(AttributeList().AddAttributes(supportedOSPlatformAttribute));
            }

            return iface;
        }

        private TypeDeclarationSyntax? DeclareInterfaceAsInterface(TypeDefinition typeDef, Stack<TypeDefinitionHandle> baseTypes)
        {
            if (this.Reader.StringComparer.Equals(typeDef.Name, "IUnknown") || this.Reader.StringComparer.Equals(typeDef.Name, "IDispatch"))
            {
                // We do not generate interfaces for these COM base types.
                return null;
            }

            IdentifierNameSyntax ifaceName = IdentifierName(this.Reader.GetString(typeDef.Name));
            TypeSyntaxSettings typeSettings = this.comSignatureTypeSettings;

            // It is imperative that we generate methods for all base interfaces as well, ahead of any implemented by *this* interface.
            var allMethods = new List<MethodDefinitionHandle>();
            bool foundIUnknown = false;
            bool foundIDispatch = false;
            bool foundIInspectable = false;
            var baseTypeSyntaxList = new List<BaseTypeSyntax>();
            while (baseTypes.Count > 0)
            {
                TypeDefinitionHandle baseTypeHandle = baseTypes.Pop();
                TypeDefinition baseType = this.Reader.GetTypeDefinition(baseTypeHandle);
                if (!foundIUnknown)
                {
                    if (!this.Reader.StringComparer.Equals(baseType.Name, "IUnknown"))
                    {
                        throw new NotSupportedException("Unsupported base COM interface type: " + this.Reader.GetString(baseType.Name));
                    }

                    foundIUnknown = true;
                }
                else
                {
                    if (this.Reader.StringComparer.Equals(baseType.Name, "IDispatch"))
                    {
                        foundIDispatch = true;
                    }
                    else if (this.Reader.StringComparer.Equals(baseType.Name, "IInspectable"))
                    {
                        foundIInspectable = true;
                    }
                    else
                    {
                        this.RequestInteropType(baseTypeHandle);
                        baseTypeSyntaxList.Add(SimpleBaseType(new HandleTypeHandleInfo(this.Reader, baseTypeHandle).ToTypeSyntax(this.comSignatureTypeSettings, null).Type));
                        allMethods.AddRange(baseType.GetMethods());
                    }
                }
            }

            int inheritedMethods = allMethods.Count;
            allMethods.AddRange(typeDef.GetMethods());

            AttributeSyntax ifaceType = InterfaceType(
                foundIInspectable ? ComInterfaceType.InterfaceIsIInspectable :
                foundIDispatch ? ComInterfaceType.InterfaceIsIDispatch :
                foundIUnknown ? ComInterfaceType.InterfaceIsIUnknown :
                throw new NotSupportedException("No COM interface base type found."));

            var members = new List<MemberDeclarationSyntax>();
            var friendlyOverloads = new List<MethodDeclarationSyntax>();

            foreach (MethodDefinitionHandle methodDefHandle in allMethods)
            {
                var methodDefinition = this.Reader.GetMethodDefinition(methodDefHandle);
                string methodName = this.Reader.GetString(methodDefinition.Name);
                try
                {
                    IdentifierNameSyntax innerMethodName = IdentifierName(methodName);
                    MethodSignature<TypeHandleInfo> signature = methodDefinition.DecodeSignature(SignatureHandleProvider.Instance, null);

                    CustomAttributeHandleCollection? returnTypeAttributes = this.GetReturnTypeCustomAttributes(methodDefinition);
                    var (returnType, marshalAs) = signature.ReturnType.ToTypeSyntax(typeSettings, returnTypeAttributes);
                    AttributeSyntax? returnsAttribute = MarshalAs(marshalAs);

                    bool preserveSig = returnType is not QualifiedNameSyntax { Right: { Identifier: { ValueText: "HRESULT" } } }
                        || this.options.ComInterop.PreserveSigMethods.Contains($"{ifaceName}.{methodName}")
                        || this.options.ComInterop.PreserveSigMethods.Contains(ifaceName.ToString());

                    var parameterList = this.CreateParameterList(methodDefinition, signature, this.comSignatureTypeSettings);

                    if (!preserveSig)
                    {
                        ParameterSyntax? lastParameter = parameterList.Parameters.Count > 0 ? parameterList.Parameters[parameterList.Parameters.Count - 1] : null;
                        if (lastParameter?.HasAnnotation(IsRetValAnnotation) is true)
                        {
                            // Move the retval parameter to the return value position.
                            parameterList = parameterList.WithParameters(parameterList.Parameters.RemoveAt(parameterList.Parameters.Count - 1));
                            returnType = lastParameter.Modifiers.Any(SyntaxKind.OutKeyword) ? lastParameter.Type! : ((PointerTypeSyntax)lastParameter.Type!).ElementType;
                            returnsAttribute = lastParameter.DescendantNodes().OfType<AttributeSyntax>().FirstOrDefault(att => att.Name.ToString() == "MarshalAs");
                        }
                        else
                        {
                            // Remove the return type
                            returnType = PredefinedType(Token(SyntaxKind.VoidKeyword));
                        }
                    }

                    MethodDeclarationSyntax methodDeclaration = MethodDeclaration(returnType.WithTrailingTrivia(TriviaList(Space)), SafeIdentifier(methodName))
                        .WithParameterList(FixTrivia(parameterList))
                        .WithSemicolonToken(SemicolonWithLineFeed);
                    if (returnsAttribute is object)
                    {
                        methodDeclaration = methodDeclaration.AddAttributeLists(
                            AttributeList().WithTarget(AttributeTargetSpecifier(Token(SyntaxKind.ReturnKeyword))).AddAttributes(returnsAttribute));
                    }

                    if (preserveSig)
                    {
                        methodDeclaration = methodDeclaration.AddAttributeLists(AttributeList().AddAttributes(PreserveSigAttribute));
                    }

                    if (inheritedMethods-- > 0)
                    {
                        methodDeclaration = methodDeclaration.AddModifiers(TokenWithSpace(SyntaxKind.NewKeyword));
                    }

                    if (methodDeclaration.ReturnType is PointerTypeSyntax || methodDeclaration.ParameterList.Parameters.Any(p => p.Type is PointerTypeSyntax))
                    {
                        methodDeclaration = methodDeclaration.AddModifiers(TokenWithSpace(SyntaxKind.UnsafeKeyword));
                    }

                    // Add documentation if we can find it.
                    methodDeclaration = this.AddApiDocumentation($"{ifaceName}.{methodName}", methodDeclaration);
                    members.Add(methodDeclaration);

                    NameSyntax declaringTypeName = HandleTypeHandleInfo.GetNestingQualifiedName(this.Reader, typeDef);
                    friendlyOverloads.AddRange(
                        this.DeclareFriendlyOverloads(methodDefinition, methodDeclaration, declaringTypeName, FriendlyOverloadOf.InterfaceMethod));
                }
                catch (Exception ex)
                {
                    throw new GenerationFailedException($"Failed while generating the method: {methodName}", ex);
                }
            }

            InterfaceDeclarationSyntax ifaceDeclaration = InterfaceDeclaration(ifaceName.Identifier)
                .WithKeyword(TokenWithSpace(SyntaxKind.InterfaceKeyword))
                .AddModifiers(TokenWithSpace(this.Visibility))
                .AddMembers(members.ToArray());

            if (this.FindGuidFromAttribute(typeDef) is Guid guid)
            {
                ifaceDeclaration = ifaceDeclaration.AddAttributeLists(AttributeList().AddAttributes(GUID(guid), ifaceType, ComImportAttribute));
            }

            if (baseTypeSyntaxList.Count > 0)
            {
                ifaceDeclaration = ifaceDeclaration
                    .WithBaseList(BaseList(SeparatedList(baseTypeSyntaxList.ToArray())));
            }

            if (this.generateSupportedOSPlatformAttributesOnInterfaces && this.GetSupportedOSPlatformAttribute(typeDef.GetCustomAttributes()) is AttributeSyntax supportedOSPlatformAttribute)
            {
                ifaceDeclaration = ifaceDeclaration.AddAttributeLists(AttributeList().AddAttributes(supportedOSPlatformAttribute));
            }

            // Only add overloads to instance collections after everything else is done,
            // so we don't leave extension methods behind if we fail to generate the target interface.
            this.volatileCode.AddComInterfaceExtension(friendlyOverloads);

            return ifaceDeclaration;
        }

        private Guid? FindGuidFromAttribute(TypeDefinition typeDef) => this.FindGuidFromAttribute(typeDef.GetCustomAttributes());

        private Guid? FindGuidFromAttribute(CustomAttributeHandleCollection attributes)
        {
            Guid? guid = null;
            if (this.FindInteropDecorativeAttribute(attributes, nameof(GuidAttribute)) is CustomAttribute att)
            {
                CustomAttributeValue<TypeSyntax> args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                guid = new Guid(
                    (uint)args.FixedArguments[0].Value!,
                    (ushort)args.FixedArguments[1].Value!,
                    (ushort)args.FixedArguments[2].Value!,
                    (byte)args.FixedArguments[3].Value!,
                    (byte)args.FixedArguments[4].Value!,
                    (byte)args.FixedArguments[5].Value!,
                    (byte)args.FixedArguments[6].Value!,
                    (byte)args.FixedArguments[7].Value!,
                    (byte)args.FixedArguments[8].Value!,
                    (byte)args.FixedArguments[9].Value!,
                    (byte)args.FixedArguments[10].Value!);
            }

            return guid;
        }

        private DelegateDeclarationSyntax DeclareDelegate(TypeDefinition typeDef)
        {
            if (!this.options.AllowMarshaling)
            {
                throw new NotSupportedException("Delegates are not declared while in all-structs mode.");
            }

            string name = this.Reader.GetString(typeDef.Name);
            TypeSyntaxSettings typeSettings = this.delegateSignatureTypeSettings;

            CallingConvention? callingConvention = null;
            foreach (CustomAttributeHandle handle in typeDef.GetCustomAttributes())
            {
                var att = this.Reader.GetCustomAttribute(handle);
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(UnmanagedFunctionPointerAttribute)))
                {
                    var args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                    callingConvention = (CallingConvention)(int)args.FixedArguments[0].Value!;
                }
            }

            this.GetSignatureForDelegate(typeDef, out MethodDefinition invokeMethodDef, out MethodSignature<TypeHandleInfo> signature, out CustomAttributeHandleCollection? returnTypeAttributes);
            var returnValue = signature.ReturnType.ToTypeSyntax(typeSettings, returnTypeAttributes);

            DelegateDeclarationSyntax result = DelegateDeclaration(returnValue.Type, Identifier(name))
                .WithParameterList(FixTrivia(this.CreateParameterList(invokeMethodDef, signature, typeSettings)))
                .AddModifiers(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.UnsafeKeyword));
            result = returnValue.AddReturnMarshalAs(result);

            if (callingConvention.HasValue)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(UnmanagedFunctionPointer(callingConvention.Value)).WithCloseBracketToken(TokenWithLineFeed(SyntaxKind.CloseBracketToken)));
            }

            return result;
        }

        private void GetSignatureForDelegate(TypeDefinition typeDef, out MethodDefinition invokeMethodDef, out MethodSignature<TypeHandleInfo> signature, out CustomAttributeHandleCollection? returnTypeAttributes)
        {
            invokeMethodDef = typeDef.GetMethods().Select(this.Reader.GetMethodDefinition).Single(def => this.Reader.StringComparer.Equals(def.Name, "Invoke"));
            signature = invokeMethodDef.DecodeSignature(SignatureHandleProvider.Instance, null);
            returnTypeAttributes = this.GetReturnTypeCustomAttributes(invokeMethodDef);
        }

        private StructDeclarationSyntax DeclareStruct(TypeDefinition typeDef)
        {
            IdentifierNameSyntax name = IdentifierName(this.Reader.GetString(typeDef.Name));
            TypeSyntaxSettings typeSettings = this.fieldTypeSettings;

            var members = new List<MemberDeclarationSyntax>();
            SyntaxList<MemberDeclarationSyntax> additionalMembers = default;
            foreach (FieldDefinitionHandle fieldDefHandle in typeDef.GetFields())
            {
                FieldDefinition fieldDef = this.Reader.GetFieldDefinition(fieldDefHandle);
                string fieldName = this.Reader.GetString(fieldDef.Name);

                try
                {
                    CustomAttribute? fixedBufferAttribute = null;
                    foreach (CustomAttributeHandle attHandle in fieldDef.GetCustomAttributes())
                    {
                        CustomAttribute att = this.Reader.GetCustomAttribute(attHandle);
                        if (this.IsAttribute(att, SystemRuntimeCompilerServices, nameof(FixedBufferAttribute)))
                        {
                            fixedBufferAttribute = att;
                            break;
                        }
                    }

                    FieldDeclarationSyntax field;
                    VariableDeclaratorSyntax fieldDeclarator = VariableDeclarator(SafeIdentifier(fieldName));
                    if (fixedBufferAttribute.HasValue)
                    {
                        CustomAttributeValue<TypeSyntax> attributeArgs = fixedBufferAttribute.Value.DecodeValue(CustomAttributeTypeProvider.Instance);
                        TypeSyntax fieldType = (TypeSyntax)attributeArgs.FixedArguments[0].Value!;
                        ExpressionSyntax size = LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal((int)attributeArgs.FixedArguments[1].Value!));
                        field = FieldDeclaration(
                            VariableDeclaration(fieldType))
                            .AddDeclarationVariables(
                                fieldDeclarator
                                    .WithArgumentList(BracketedArgumentList(SingletonSeparatedList(Argument(size)))))
                            .AddModifiers(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.UnsafeKeyword), Token(SyntaxKind.FixedKeyword));
                    }
                    else
                    {
                        CustomAttributeHandleCollection fieldAttributes = fieldDef.GetCustomAttributes();
                        TypeHandleInfo fieldTypeInfo = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null);
                        TypeSyntaxAndMarshaling fieldTypeSyntax = fieldTypeInfo.ToTypeSyntax(typeSettings, fieldAttributes);
                        var fieldInfo = this.ReinterpretFieldType(fieldDef, fieldTypeSyntax.Type, fieldAttributes);
                        additionalMembers = additionalMembers.AddRange(fieldInfo.AdditionalMembers);

                        field = FieldDeclaration(VariableDeclaration(fieldInfo.FieldType).AddVariables(fieldDeclarator))
                            .AddModifiers(TokenWithSpace(this.Visibility));

                        if (fieldInfo.FieldType is PointerTypeSyntax || fieldInfo.FieldType is FunctionPointerTypeSyntax)
                        {
                            field = field.AddModifiers(TokenWithSpace(SyntaxKind.UnsafeKeyword));
                        }

                        if (ObjectMembers.Contains(fieldName))
                        {
                            field = field.AddModifiers(TokenWithSpace(SyntaxKind.NewKeyword));
                        }
                    }

                    int offset = fieldDef.GetOffset();
                    if (offset >= 0)
                    {
                        field = field.AddAttributeLists(AttributeList().AddAttributes(FieldOffset(offset)));
                    }

                    members.Add(field);
                }
                catch (Exception ex)
                {
                    throw new GenerationFailedException("Failed while generating field: " + fieldName, ex);
                }
            }

            // Add the additional members, taking care to not introduce redundant declarations.
            members.AddRange(additionalMembers.Where(c => c is not StructDeclarationSyntax cs || !members.OfType<StructDeclarationSyntax>().Any(m => m.Identifier.ValueText == cs.Identifier.ValueText)));

            StructDeclarationSyntax result = StructDeclaration(name.Identifier)
                .AddMembers(members.ToArray())
                .WithModifiers(TokenList(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.PartialKeyword)));

            TypeLayout layout = typeDef.GetLayout();
            if (!layout.IsDefault || (typeDef.Attributes & TypeAttributes.ExplicitLayout) == TypeAttributes.ExplicitLayout)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(StructLayout(typeDef.Attributes, layout)));
            }

            if (this.FindGuidFromAttribute(typeDef) is Guid guid)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(GUID(guid)));
            }

            result = this.AddApiDocumentation(name.Identifier.ValueText, result);

            return result;
        }

        /// <summary>
        /// Creates a struct that emulates a typedef in the C language headers.
        /// </summary>
        private StructDeclarationSyntax DeclareTypeDefStruct(TypeDefinition typeDef)
        {
            IdentifierNameSyntax name = IdentifierName(this.Reader.GetString(typeDef.Name));
            if (name.Identifier.ValueText == "BOOL")
            {
                return this.DeclareTypeDefBOOLStruct(typeDef);
            }

            bool isHandle = name.Identifier.ValueText == "HGDIOBJ";
            foreach (CustomAttributeHandle attHandle in typeDef.GetCustomAttributes())
            {
                CustomAttribute att = this.Reader.GetCustomAttribute(attHandle);

                // If this struct represents a handle, generate the SafeHandle-equivalent.
                if (this.IsAttribute(att, InteropDecorationNamespace, RAIIFreeAttribute))
                {
                    var args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                    if (args.FixedArguments[0].Value is string freeMethodName)
                    {
                        ////this.GenerateSafeHandle(freeMethodName);
                        this.TryGenerateExternMethod(freeMethodName);
                        isHandle = true;
                    }

                    break;
                }
            }

            TypeSyntaxSettings typeSettings = isHandle ? this.fieldOfHandleTypeDefTypeSettings : this.fieldTypeSettings;

            FieldDefinition fieldDef = this.Reader.GetFieldDefinition(typeDef.GetFields().Single());
            string fieldName = this.Reader.GetString(fieldDef.Name);
            IdentifierNameSyntax fieldIdentifierName = SafeIdentifierName(fieldName);
            VariableDeclaratorSyntax fieldDeclarator = VariableDeclarator(fieldIdentifierName.Identifier);
            var fieldAttributes = fieldDef.GetCustomAttributes();
            var fieldType = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null).ToTypeSyntax(typeSettings, fieldAttributes);
            (TypeSyntax FieldType, SyntaxList<MemberDeclarationSyntax> AdditionalMembers) fieldInfo =
                this.ReinterpretFieldType(fieldDef, fieldType.Type, fieldAttributes);
            SyntaxList<MemberDeclarationSyntax> members = List<MemberDeclarationSyntax>();

            FieldDeclarationSyntax fieldSyntax = FieldDeclaration(
                VariableDeclaration(fieldInfo.FieldType).AddVariables(fieldDeclarator))
                .AddModifiers(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.ReadOnlyKeyword));
            members = members.Add(fieldSyntax);

            // Add constructor
            IdentifierNameSyntax valueParameter = IdentifierName("value");
            MemberAccessExpressionSyntax fieldAccessExpression = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), fieldIdentifierName);
            members = members.Add(ConstructorDeclaration(name.Identifier)
                .AddModifiers(TokenWithSpace(this.Visibility))
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(fieldInfo.FieldType.WithTrailingTrivia(TriviaList(Space))))
                .WithExpressionBody(ArrowExpressionClause(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, fieldAccessExpression, valueParameter).WithOperatorToken(TokenWithSpaces(SyntaxKind.EqualsToken))))
                .WithSemicolonToken(SemicolonWithLineFeed));

            // If this typedef struct represents a pointer, add an IsNull property.
            if (fieldInfo.FieldType is IdentifierNameSyntax { Identifier: { Value: nameof(IntPtr) or nameof(UIntPtr) } })
            {
                // internal static bool IsNull => value == default;
                members = members.Add(PropertyDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)), "IsNull")
                    .AddModifiers(TokenWithSpace(this.Visibility))
                    .WithExpressionBody(ArrowExpressionClause(BinaryExpression(SyntaxKind.EqualsExpression, fieldIdentifierName, LiteralExpression(SyntaxKind.DefaultLiteralExpression))))
                    .WithSemicolonToken(SemicolonWithLineFeed));
            }

            // public static implicit operator int(HWND value) => value.Value;
            members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), fieldInfo.FieldType)
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(name.WithTrailingTrivia(TriviaList(Space))))
                .WithExpressionBody(ArrowExpressionClause(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, fieldIdentifierName)))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(SemicolonWithLineFeed));

            // public static explicit operator HWND(int value) => new HWND(value);
            // Except make converting char* or byte* to typedefs representing strings, and LPARAM/WPARAM to nint/nuint, implicit.
            SyntaxKind explicitOrImplicitModifier = ImplicitConversionTypeDefs.Contains(name.Identifier.ValueText) ? SyntaxKind.ImplicitKeyword : SyntaxKind.ExplicitKeyword;
            members = members.Add(ConversionOperatorDeclaration(Token(explicitOrImplicitModifier), name)
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(fieldInfo.FieldType.WithTrailingTrivia(TriviaList(Space))))
                .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(Argument(valueParameter))))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(SemicolonWithLineFeed));

            if (isHandle && fieldInfo.FieldType is not IdentifierNameSyntax { Identifier: { ValueText: nameof(IntPtr) } })
            {
                // Handle types must interop with IntPtr for SafeHandle support, so if IntPtr isn't the field type,
                // we need to create new conversion operators.
                ExpressionSyntax valueValueArg = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, fieldIdentifierName);
                if (fieldInfo.FieldType is IdentifierNameSyntax { Identifier: { ValueText: nameof(UIntPtr) } })
                {
                    valueValueArg = CastExpression(PredefinedType(TokenWithSpace(SyntaxKind.LongKeyword)), valueValueArg);
                }

                // public static implicit operator IntPtr(MSIHANDLE value) => new IntPtr(value.Value);
                members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), IntPtrTypeSyntax)
                    .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(name.WithTrailingTrivia(TriviaList(Space))))
                    .WithExpressionBody(ArrowExpressionClause(
                        ObjectCreationExpression(IntPtrTypeSyntax).AddArgumentListArguments(Argument(valueValueArg))))
                    .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                    .WithSemicolonToken(SemicolonWithLineFeed));

                if (fieldInfo.FieldType is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.UIntKeyword } })
                {
                    // public static explicit operator MSIHANDLE(IntPtr value) => new MSIHANDLE((uint)value.ToInt32());
                    members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ExplicitKeyword), name)
                        .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(IntPtrTypeSyntax.WithTrailingTrivia(TriviaList(Space))))
                        .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(
                            Argument(CastExpression(fieldInfo.FieldType, InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, IdentifierName(nameof(IntPtr.ToInt32)))))))))
                        .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                        .WithSemicolonToken(SemicolonWithLineFeed));
                }
                else if (fieldInfo.FieldType is PointerTypeSyntax)
                {
                    // public static explicit operator MSIHANDLE(IntPtr value) => new MSIHANDLE(value.ToPointer());
                    members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ExplicitKeyword), name)
                        .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(IntPtrTypeSyntax.WithTrailingTrivia(TriviaList(Space))))
                        .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(
                            Argument(CastExpression(fieldInfo.FieldType, InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, IdentifierName(nameof(IntPtr.ToPointer)))))))))
                        .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                        .WithSemicolonToken(SemicolonWithLineFeed));
                }
                else if (fieldInfo.FieldType is IdentifierNameSyntax { Identifier: { ValueText: nameof(UIntPtr) } })
                {
                    // public static explicit operator SOCKET(IntPtr value) => new SOCKET((UIntPtr)value.ToInt64());
                    members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ExplicitKeyword), name)
                        .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(IntPtrTypeSyntax.WithTrailingTrivia(TriviaList(Space))))
                        .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(
                            Argument(CastExpression(fieldInfo.FieldType, InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, IdentifierName(nameof(IntPtr.ToInt64)))))))))
                        .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                        .WithSemicolonToken(SemicolonWithLineFeed));
                }
            }

            // public static bool operator ==(HANDLE left, HANDLE right) => left.Value == right.Value;
            var leftParameter = IdentifierName("left");
            var rightParameter = IdentifierName("right");
            members = members.Add(OperatorDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)), TokenWithNoSpace(SyntaxKind.EqualsEqualsToken))
                .WithOperatorKeyword(TokenWithSpace(SyntaxKind.OperatorKeyword))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword))
                .AddParameterListParameters(
                    Parameter(leftParameter.Identifier).WithType(name.WithTrailingTrivia(TriviaList(Space))),
                    Parameter(rightParameter.Identifier).WithType(name.WithTrailingTrivia(TriviaList(Space))))
                .WithExpressionBody(ArrowExpressionClause(
                    BinaryExpression(
                        SyntaxKind.EqualsExpression,
                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, leftParameter, fieldIdentifierName),
                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, rightParameter, fieldIdentifierName))))
                .WithSemicolonToken(SemicolonWithLineFeed));

            // public static bool operator !=(HANDLE left, HANDLE right) => !(left == right);
            members = members.Add(OperatorDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)), Token(SyntaxKind.ExclamationEqualsToken))
                .WithOperatorKeyword(TokenWithSpace(SyntaxKind.OperatorKeyword))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword))
                .AddParameterListParameters(
                    Parameter(leftParameter.Identifier).WithType(name.WithTrailingTrivia(TriviaList(Space))),
                    Parameter(rightParameter.Identifier).WithType(name.WithTrailingTrivia(TriviaList(Space))))
                .WithExpressionBody(ArrowExpressionClause(
                    PrefixUnaryExpression(
                        SyntaxKind.LogicalNotExpression,
                        ParenthesizedExpression(BinaryExpression(SyntaxKind.EqualsExpression, leftParameter, rightParameter)))))
                .WithSemicolonToken(SemicolonWithLineFeed));

            // public bool Equals(HWND other) => this.Value == other.Value;
            IdentifierNameSyntax other = IdentifierName("other");
            members = members.Add(MethodDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)), Identifier(nameof(IEquatable<int>.Equals)))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword))
                .AddParameterListParameters(Parameter(other.Identifier).WithType(name.WithTrailingTrivia(TriviaList(Space))))
                .WithExpressionBody(ArrowExpressionClause(
                    BinaryExpression(
                        SyntaxKind.EqualsExpression,
                        fieldAccessExpression,
                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, other, fieldIdentifierName))))
                .WithSemicolonToken(SemicolonWithLineFeed));

            // public override bool Equals(object obj) => obj is HWND other && this.Equals(other);
            IdentifierNameSyntax objParam = IdentifierName("obj");
            members = members.Add(MethodDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword)), Identifier(nameof(IEquatable<int>.Equals)))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.OverrideKeyword))
                .AddParameterListParameters(Parameter(objParam.Identifier).WithType(PredefinedType(TokenWithSpace(SyntaxKind.ObjectKeyword))))
                .WithExpressionBody(ArrowExpressionClause(
                    BinaryExpression(
                        SyntaxKind.LogicalAndExpression,
                        IsPatternExpression(objParam, DeclarationPattern(name, SingleVariableDesignation(Identifier("other")))),
                        InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName(nameof(Equals))))
                            .WithArgumentList(ArgumentList().AddArguments(Argument(IdentifierName("other")))))))
                .WithSemicolonToken(SemicolonWithLineFeed));

            // public override int GetHashCode() => unchecked((int)this.Value); // if Value is a pointer
            // public override int GetHashCode() => this.Value.GetHashCode(); // if Value is not a pointer
            ExpressionSyntax hashExpr = fieldInfo.FieldType is PointerTypeSyntax ?
                CheckedExpression(SyntaxKind.UncheckedExpression, CastExpression(PredefinedType(TokenWithNoSpace(SyntaxKind.IntKeyword)), fieldAccessExpression)) :
                InvocationExpression(
                    MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, fieldAccessExpression, IdentifierName(nameof(object.GetHashCode))),
                    ArgumentList());

            members = members.Add(MethodDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword)), Identifier(nameof(object.GetHashCode)))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(hashExpr))
                .WithSemicolonToken(SemicolonWithLineFeed));

            switch (name.Identifier.ValueText)
            {
                case "BSTR":
                    members = members.AddRange(this.CreateAdditionalTypeDefBSTRMembers());
                    break;
                case "PWSTR":
                    members = members.AddRange(this.CreateAdditionalTypeDefPWSTRMembers());
                    break;
                case "HRESULT":
                case "NTSTATUS":
                    members = members.AddRange(this.ExtractMembersFromTemplate(name.Identifier.ValueText));
                    break;
                default:
                    break;
            }

            var structModifiers = TokenList(TokenWithSpace(this.Visibility));
            if (RequiresUnsafe(fieldInfo.FieldType))
            {
                structModifiers = structModifiers.Add(TokenWithSpace(SyntaxKind.UnsafeKeyword));
            }

            structModifiers = structModifiers.Add(TokenWithSpace(SyntaxKind.ReadOnlyKeyword)).Add(TokenWithSpace(SyntaxKind.PartialKeyword));
            StructDeclarationSyntax result = StructDeclaration(name.Identifier)
                .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(SimpleBaseType(GenericName(nameof(IEquatable<int>), TypeArgumentList().WithGreaterThanToken(TokenWithLineFeed(SyntaxKind.GreaterThanToken))).AddTypeArgumentListArguments(name)))).WithColonToken(TokenWithSpace(SyntaxKind.ColonToken)))
                .WithMembers(members)
                .WithModifiers(structModifiers)
                .AddAttributeLists(AttributeList().WithCloseBracketToken(TokenWithLineFeed(SyntaxKind.CloseBracketToken)).AddAttributes(DebuggerDisplay("{" + fieldName + "}")));

            result = this.AddApiDocumentation(name.Identifier.ValueText, result);
            return result;
        }

        private IEnumerable<MemberDeclarationSyntax> ExtractMembersFromTemplate(string name) => ((TypeDeclarationSyntax)this.FetchTemplate($"{name}")).Members;

        /// <summary>
        /// Promotes an <see langword="internal" /> member to be <see langword="public"/> if <see cref="Visibility"/> indicates that generated APIs should be public.
        /// This change is applied recursively.
        /// </summary>
        /// <param name="member">The member to potentially make public.</param>
        /// <returns>The modified or original <paramref name="member"/>.</returns>
        private MemberDeclarationSyntax ElevateVisibility(MemberDeclarationSyntax member)
        {
            if (this.Visibility == SyntaxKind.PublicKeyword)
            {
                int indexOfInternal = member.Modifiers.IndexOf(SyntaxKind.InternalKeyword);
                if (indexOfInternal >= 0)
                {
                    MemberDeclarationSyntax publicMember = member.WithModifiers(member.Modifiers.Replace(member.Modifiers[indexOfInternal], TokenWithSpace(this.Visibility)));

                    // Apply change recursively.
                    if (publicMember is TypeDeclarationSyntax memberContainer)
                    {
                        publicMember = memberContainer.WithMembers(List(memberContainer.Members.Select(this.ElevateVisibility)));
                    }

                    return publicMember;
                }
            }

            return member;
        }

        private IEnumerable<MemberDeclarationSyntax> CreateAdditionalTypeDefBSTRMembers()
        {
            ExpressionSyntax thisValue = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("Value"));

            // public override string ToString() => Marshal.PtrToStringBSTR(new IntPtr(this.Value));
            yield return MethodDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.StringKeyword)), Identifier(nameof(this.ToString)))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName(nameof(Marshal)),
                            IdentifierName(nameof(Marshal.PtrToStringBSTR))))
                .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(ObjectCreationExpression(IntPtrTypeSyntax).WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(thisValue))))))))))
                .WithSemicolonToken(SemicolonWithLineFeed);

            // public static implicit operator ReadOnlySpan<char>(BSTR bstr) => bstr.Value != null ? new ReadOnlySpan<char>(bstr.Value, *((int*)bstr.Value - 1) / 2) : default;
            TypeSyntax rosChar = MakeReadOnlySpanOfT(PredefinedType(Token(SyntaxKind.CharKeyword)));
            IdentifierNameSyntax bstrParam = IdentifierName("bstr");
            ExpressionSyntax bstrValue = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, bstrParam, IdentifierName("Value"));
            ExpressionSyntax length = BinaryExpression(
                SyntaxKind.DivideExpression,
                PrefixUnaryExpression(
                    SyntaxKind.PointerIndirectionExpression,
                    ParenthesizedExpression(
                        BinaryExpression(
                            SyntaxKind.SubtractExpression,
                            CastExpression(PointerType(PredefinedType(TokenWithNoSpace(SyntaxKind.IntKeyword))), bstrValue),
                            LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(1))))),
                LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(2)));
            ExpressionSyntax rosCreation = ObjectCreationExpression(rosChar).AddArgumentListArguments(Argument(bstrValue), Argument(length));
            ExpressionSyntax bstrNotNull = BinaryExpression(SyntaxKind.NotEqualsExpression, bstrValue, LiteralExpression(SyntaxKind.NullLiteralExpression));
            ExpressionSyntax conditional = ConditionalExpression(bstrNotNull, rosCreation, DefaultExpression(rosChar));
            yield return ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), rosChar)
                .AddParameterListParameters(Parameter(bstrParam.Identifier).WithType(IdentifierName("BSTR").WithTrailingTrivia(TriviaList(Space))))
                .WithExpressionBody(ArrowExpressionClause(conditional))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.UnsafeKeyword)) // operators MUST be public
                .WithSemicolonToken(SemicolonWithLineFeed);

            // internal ReadOnlySpan<char> AsSpan() => this;
            yield return MethodDeclaration(rosChar, Identifier("AsSpan"))
                .AddModifiers(TokenWithSpace(this.Visibility))
                .WithExpressionBody(ArrowExpressionClause(ThisExpression()))
                .WithSemicolonToken(SemicolonWithLineFeed);
        }

        private IEnumerable<MemberDeclarationSyntax> CreateAdditionalTypeDefPWSTRMembers()
        {
#pragma warning disable SA1114 // Parameter list should follow declaration
            ExpressionSyntax thisValue = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("Value"));
            ExpressionSyntax thisValueIsNull = IsPatternExpression(thisValue, ConstantPattern(LiteralExpression(SyntaxKind.NullLiteralExpression)));

            // internal int Length { get; }
            IdentifierNameSyntax localPointer = IdentifierName("p");
            yield return PropertyDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword)), Identifier("Length").WithTrailingTrivia(LineFeed))
                .AddModifiers(TokenWithSpace(this.Visibility))
                .WithAccessorList(AccessorList().AddAccessors(AccessorDeclaration(
                    SyntaxKind.GetAccessorDeclaration,
                    Block().AddStatements(
                        //// char* p = this.Value;
                        LocalDeclarationStatement(
                            VariableDeclaration(PointerType(PredefinedType(Token(SyntaxKind.CharKeyword))))
                                .AddVariables(VariableDeclarator(localPointer.Identifier).WithInitializer(EqualsValueClause(thisValue)))),
                        //// if (p is null) return 0;
                        IfStatement(
                            IsPatternExpression(localPointer, ConstantPattern(LiteralExpression(SyntaxKind.NullLiteralExpression))),
                            ReturnStatement(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)))).WithCloseParenToken(TokenWithLineFeed(SyntaxKind.CloseParenToken)),
                        //// while (*p != '\0') p++;
                        WhileStatement(
                            BinaryExpression(SyntaxKind.NotEqualsExpression, PrefixUnaryExpression(SyntaxKind.PointerIndirectionExpression, localPointer), LiteralExpression(SyntaxKind.CharacterLiteralExpression, Literal('\0'))),
                            ExpressionStatement(PostfixUnaryExpression(SyntaxKind.PostIncrementExpression, localPointer))),
                        //// return checked((int)(p - this.Value));
                        ReturnStatement(
                            CheckedExpression(
                                SyntaxKind.CheckedExpression,
                                CastExpression(
                                    PredefinedType(TokenWithNoSpace(SyntaxKind.IntKeyword)),
                                    ParenthesizedExpression(BinaryExpression(SyntaxKind.SubtractExpression, localPointer, thisValue))))))).WithKeyword(TokenWithLineFeed(SyntaxKind.GetKeyword))));

            // public override string? ToString() => this.Value is null ? null : new string(this.Value);
            yield return MethodDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.StringKeyword)), Identifier(nameof(this.ToString)))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(
                    ConditionalExpression(
                        thisValueIsNull,
                        LiteralExpression(SyntaxKind.NullLiteralExpression),
                        ObjectCreationExpression(PredefinedType(Token(SyntaxKind.StringKeyword)))
                            .AddArgumentListArguments(Argument(thisValue)))))
                .WithSemicolonToken(SemicolonWithLineFeed);

            // internal Span<char> AsSpan() => this.Value is null ? default : new Span<char>(this.Value, this.Length);
            TypeSyntax spanChar = MakeSpanOfT(PredefinedType(Token(SyntaxKind.CharKeyword)));
            ExpressionSyntax thisLength = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("Length"));
            ExpressionSyntax spanCreation = ObjectCreationExpression(spanChar).AddArgumentListArguments(Argument(thisValue), Argument(thisLength));
            ExpressionSyntax conditional = ConditionalExpression(thisValueIsNull, DefaultExpression(spanChar), spanCreation);
            yield return MethodDeclaration(spanChar, Identifier("AsSpan"))
                .AddModifiers(TokenWithSpace(this.Visibility))
                .WithExpressionBody(ArrowExpressionClause(conditional))
                .WithSemicolonToken(SemicolonWithLineFeed);
#pragma warning restore SA1114 // Parameter list should follow declaration
        }

        private StructDeclarationSyntax DeclareTypeDefBOOLStruct(TypeDefinition typeDef)
        {
            IdentifierNameSyntax name = IdentifierName("BOOL");

            FieldDefinition fieldDef = this.Reader.GetFieldDefinition(typeDef.GetFields().Single());
            var fieldAttributes = fieldDef.GetCustomAttributes();
            string fieldName = this.Reader.GetString(fieldDef.Name);
            VariableDeclaratorSyntax fieldDeclarator = VariableDeclarator(Identifier("value"));
            (TypeSyntax FieldType, SyntaxList<MemberDeclarationSyntax> AdditionalMembers) fieldInfo =
                this.ReinterpretFieldType(fieldDef, fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null).ToTypeSyntax(this.fieldTypeSettings, fieldAttributes).Type, fieldAttributes);
            SyntaxList<MemberDeclarationSyntax> members = List<MemberDeclarationSyntax>();

            FieldDeclarationSyntax fieldSyntax = FieldDeclaration(
                VariableDeclaration(fieldInfo.FieldType).AddVariables(fieldDeclarator))
                .AddModifiers(TokenWithSpace(SyntaxKind.PrivateKeyword), TokenWithSpace(SyntaxKind.ReadOnlyKeyword));
            members = members.Add(fieldSyntax);
            MemberAccessExpressionSyntax fieldAccessExpression = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("value"));

            // Add property accessor
            members = members.Add(PropertyDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword)), "Value")
                .WithExpressionBody(ArrowExpressionClause(fieldAccessExpression)).WithSemicolonToken(SemicolonWithLineFeed)
                .AddModifiers(TokenWithSpace(this.Visibility)));

            // BOOL(bool value) => this.value = value ? 1 : 0;
            IdentifierNameSyntax valueParameter = IdentifierName("value");
            ExpressionSyntax boolToInt = ConditionalExpression(valueParameter, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(1)), LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
            members = members.Add(ConstructorDeclaration(name.Identifier)
                .AddModifiers(TokenWithSpace(this.Visibility))
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword))))
                .WithExpressionBody(ArrowExpressionClause(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, fieldAccessExpression, boolToInt).WithOperatorToken(TokenWithSpaces(SyntaxKind.EqualsToken))))
                .WithSemicolonToken(SemicolonWithLineFeed));

            // BOOL(int value) => this.value = value;
            members = members.Add(ConstructorDeclaration(name.Identifier)
                .AddModifiers(TokenWithSpace(this.Visibility))
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword))))
                .WithExpressionBody(ArrowExpressionClause(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, fieldAccessExpression, valueParameter).WithOperatorToken(TokenWithSpaces(SyntaxKind.EqualsToken))))
                .WithSemicolonToken(SemicolonWithLineFeed));

            // public static implicit operator bool(BOOL value) => value.value != 0 ? true : false;
            members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), PredefinedType(Token(SyntaxKind.BoolKeyword)))
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(name.WithTrailingTrivia(TriviaList(Space))))
                .WithExpressionBody(ArrowExpressionClause(BinaryExpression(SyntaxKind.NotEqualsExpression, MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, IdentifierName(fieldName)), LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)))))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(SemicolonWithLineFeed));

            // public static implicit operator BOOL(bool value) => new BOOL(value);
            members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), name)
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword))))
                .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(Argument(valueParameter))))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(SemicolonWithLineFeed));

            // public static explicit operator BOOL(int value) => new BOOL(value);
            members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ExplicitKeyword), name)
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword))))
                .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(Argument(valueParameter))))
                .AddModifiers(TokenWithSpace(SyntaxKind.PublicKeyword), TokenWithSpace(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(SemicolonWithLineFeed));

            StructDeclarationSyntax result = StructDeclaration(name.Identifier)
                .WithMembers(members)
                .WithModifiers(TokenList(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.ReadOnlyKeyword), TokenWithSpace(SyntaxKind.PartialKeyword)));

            result = this.AddApiDocumentation(name.Identifier.ValueText, result);
            return result;
        }

        private EnumDeclarationSyntax DeclareEnum(TypeDefinition typeDef)
        {
            bool flagsEnum = false;
            foreach (CustomAttributeHandle attributeHandle in typeDef.GetCustomAttributes())
            {
                CustomAttribute attribute = this.Reader.GetCustomAttribute(attributeHandle);
                if (this.IsAttribute(attribute, nameof(System), "FlagsAttribute"))
                {
                    flagsEnum = true;
                    break;
                }
            }

            var enumValues = new List<SyntaxNodeOrToken>();
            TypeSyntax? enumBaseType = null;
            foreach (FieldDefinitionHandle fieldDefHandle in typeDef.GetFields())
            {
                FieldDefinition fieldDef = this.Reader.GetFieldDefinition(fieldDefHandle);
                string enumValueName = this.Reader.GetString(fieldDef.Name);
                ConstantHandle valueHandle = fieldDef.GetDefaultValue();
                if (valueHandle.IsNil)
                {
                    enumBaseType = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null).ToTypeSyntax(this.enumTypeSettings, null).Type;
                    continue;
                }

                Constant value = this.Reader.GetConstant(valueHandle);
                ExpressionSyntax enumValue = flagsEnum ? this.ToHexExpressionSyntax(value) : this.ToExpressionSyntax(value);
                EnumMemberDeclarationSyntax enumMember = EnumMemberDeclaration(SafeIdentifier(enumValueName))
                    .WithEqualsValue(EqualsValueClause(enumValue));
                enumValues.Add(enumMember);
                enumValues.Add(TokenWithLineFeed(SyntaxKind.CommaToken));
            }

            if (enumBaseType is null)
            {
                throw new NotSupportedException("Unknown enum type.");
            }

            var name = this.Reader.GetString(typeDef.Name);
            EnumDeclarationSyntax result = EnumDeclaration(Identifier(name))
                .WithMembers(SeparatedList<EnumMemberDeclarationSyntax>(enumValues))
                .WithModifiers(TokenList(TokenWithSpace(this.Visibility)));

            if (!(enumBaseType is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.IntKeyword } }))
            {
                result = result.WithIdentifier(result.Identifier.WithTrailingTrivia(Space))
                    .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(SimpleBaseType(enumBaseType).WithTrailingTrivia(LineFeed))).WithColonToken(TokenWithSpace(SyntaxKind.ColonToken)));
            }

            if (flagsEnum)
            {
                result = result.AddAttributeLists(
                    AttributeList().WithCloseBracketToken(TokenWithLineFeed(SyntaxKind.CloseBracketToken)).AddAttributes(FlagsAttributeSyntax));
            }

            result = this.AddApiDocumentation(name, result);

            return result;
        }

        private IEnumerable<MethodDeclarationSyntax> DeclareFriendlyOverloads(MethodDefinition methodDefinition, MethodDeclarationSyntax externMethodDeclaration, NameSyntax declaringTypeName, FriendlyOverloadOf overloadOf)
        {
            if (this.TryFetchTemplate(externMethodDeclaration.Identifier.ValueText, out MemberDeclarationSyntax? templateFriendlyOverload))
            {
                yield return (MethodDeclarationSyntax)templateFriendlyOverload;
            }

            if (this.options.AllowMarshaling && this.TryFetchTemplate("marshaling/" + externMethodDeclaration.Identifier.ValueText, out templateFriendlyOverload))
            {
                yield return (MethodDeclarationSyntax)templateFriendlyOverload;
            }

            if (!this.options.AllowMarshaling && this.TryFetchTemplate("no_marshaling/" + externMethodDeclaration.Identifier.ValueText, out templateFriendlyOverload))
            {
                yield return (MethodDeclarationSyntax)templateFriendlyOverload;
            }

#pragma warning disable SA1114 // Parameter list should follow declaration
            static ParameterSyntax StripAttributes(ParameterSyntax parameter) => parameter.WithAttributeLists(List<AttributeListSyntax>());
            static ExpressionSyntax GetSpanLength(ExpressionSyntax span) => MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, span, IdentifierName(nameof(Span<int>.Length)));
            bool isReleaseMethod = this.MetadataIndex.ReleaseMethods.Contains(externMethodDeclaration.Identifier.ValueText);

            var originalSignature = methodDefinition.DecodeSignature(SignatureHandleProvider.Instance, null);
            var parameters = externMethodDeclaration.ParameterList.Parameters.Select(StripAttributes).ToList();
            var lengthParamUsedBy = new Dictionary<int, int>();
            var arguments = externMethodDeclaration.ParameterList.Parameters.Select(p => Argument(IdentifierName(p.Identifier.Text)).WithRefKindKeyword(p.Modifiers.FirstOrDefault(p => p.Kind() is SyntaxKind.RefKeyword or SyntaxKind.OutKeyword or SyntaxKind.InKeyword))).ToList();
            var externMethodReturnType = externMethodDeclaration.ReturnType.WithoutLeadingTrivia();
            var fixedBlocks = new List<VariableDeclarationSyntax>();
            var leadingOutsideTryStatements = new List<StatementSyntax>();
            var leadingStatements = new List<StatementSyntax>();
            var trailingStatements = new List<StatementSyntax>();
            var finallyStatements = new List<StatementSyntax>();
            bool signatureChanged = false;
            foreach (ParameterHandle paramHandle in methodDefinition.GetParameters())
            {
                var param = this.Reader.GetParameter(paramHandle);
                if (param.SequenceNumber == 0 || param.SequenceNumber - 1 >= parameters.Count)
                {
                    continue;
                }

                bool isOptional = (param.Attributes & ParameterAttributes.Optional) == ParameterAttributes.Optional;
                bool isIn = (param.Attributes & ParameterAttributes.In) == ParameterAttributes.In;
                bool isConst = param.GetCustomAttributes().Any(ah => this.IsAttribute(this.Reader.GetCustomAttribute(ah), InteropDecorationNamespace, "ConstAttribute"));
                bool isComOutPtr = param.GetCustomAttributes().Any(ah => this.IsAttribute(this.Reader.GetCustomAttribute(ah), InteropDecorationNamespace, "ComOutPtrAttribute"));
                bool isOut = isComOutPtr || (param.Attributes & ParameterAttributes.Out) == ParameterAttributes.Out;

                // TODO:
                // * Review double/triple pointer scenarios.
                //   * Consider CredEnumerateA, which is a "pointer to an array of pointers" (3-asterisks!). How does FriendlyAttribute improve this, if at all? The memory must be freed through another p/invoke.
                ParameterSyntax externParam = parameters[param.SequenceNumber - 1];
                if (externParam.Type is null)
                {
                    throw new GenerationFailedException();
                }

                TypeHandleInfo parameterTypeInfo = originalSignature.ParameterTypes[param.SequenceNumber - 1];
                if (this.IsManagedType(parameterTypeInfo) && (externParam.Modifiers.Any(SyntaxKind.OutKeyword) || externParam.Modifiers.Any(SyntaxKind.RefKeyword)))
                {
                    bool hasOut = externParam.Modifiers.Any(SyntaxKind.OutKeyword);
                    arguments[param.SequenceNumber - 1] = arguments[param.SequenceNumber - 1].WithRefKindKeyword(TokenWithSpace(hasOut ? SyntaxKind.OutKeyword : SyntaxKind.RefKeyword));
                }
                else if (isOut && !isIn && !isReleaseMethod && parameterTypeInfo is PointerTypeHandleInfo { ElementType: HandleTypeHandleInfo pointedElementInfo } && this.TryGetHandleReleaseMethod(pointedElementInfo.Handle, out string? outReleaseMethod) && !this.Reader.StringComparer.Equals(methodDefinition.Name, outReleaseMethod))
                {
                    if (this.RequestSafeHandle(outReleaseMethod) is TypeSyntax safeHandleType)
                    {
                        signatureChanged = true;

                        IdentifierNameSyntax origName = IdentifierName(externParam.Identifier.ValueText);
                        IdentifierNameSyntax typeDefHandleName = IdentifierName(externParam.Identifier.ValueText + "Local");

                        // out SafeHandle
                        parameters[param.SequenceNumber - 1] = externParam
                            .WithType(safeHandleType.WithTrailingTrivia(TriviaList(Space)))
                            .WithModifiers(TokenList(TokenWithSpace(SyntaxKind.OutKeyword)));

                        // HANDLE SomeLocal;
                        leadingStatements.Add(LocalDeclarationStatement(VariableDeclaration(pointedElementInfo.ToTypeSyntax(this.externSignatureTypeSettings, null).Type).AddVariables(
                            VariableDeclarator(typeDefHandleName.Identifier))));

                        // Argument: &SomeLocal
                        arguments[param.SequenceNumber - 1] = Argument(PrefixUnaryExpression(SyntaxKind.AddressOfExpression, typeDefHandleName));

                        // Some = new SafeHandle(SomeLocal, ownsHandle: true);
                        trailingStatements.Add(ExpressionStatement(AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression,
                            origName,
                            ObjectCreationExpression(safeHandleType).AddArgumentListArguments(
                                Argument(typeDefHandleName),
                                Argument(LiteralExpression(SyntaxKind.TrueLiteralExpression)).WithNameColon(NameColon(IdentifierName("ownsHandle")))))));
                    }
                }
                else if (isIn && !isOut && !isReleaseMethod && parameterTypeInfo is HandleTypeHandleInfo parameterHandleTypeInfo && this.TryGetHandleReleaseMethod(parameterHandleTypeInfo.Handle, out string? releaseMethod) && !this.Reader.StringComparer.Equals(methodDefinition.Name, releaseMethod))
                {
                    IdentifierNameSyntax origName = IdentifierName(externParam.Identifier.ValueText);
                    IdentifierNameSyntax typeDefHandleName = IdentifierName(externParam.Identifier.ValueText + "Local");
                    signatureChanged = true;

                    IdentifierNameSyntax refAddedName = IdentifierName(externParam.Identifier.ValueText + "AddRef");

                    // bool hParamNameAddRef = false;
                    leadingOutsideTryStatements.Add(LocalDeclarationStatement(
                        VariableDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.BoolKeyword))).AddVariables(
                            VariableDeclarator(refAddedName.Identifier).WithInitializer(EqualsValueClause(LiteralExpression(SyntaxKind.FalseLiteralExpression))))));

                    // HANDLE hTemplateFileLocal;
                    leadingStatements.Add(LocalDeclarationStatement(VariableDeclaration(externParam.Type).AddVariables(
                        VariableDeclarator(typeDefHandleName.Identifier))));

                    // if (hTemplateFile is object)
                    leadingStatements.Add(IfStatement(
                        BinaryExpression(SyntaxKind.IsExpression, origName, PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                        Block().AddStatements(
                        //// hTemplateFile.DangerousAddRef(ref hTemplateFileAddRef);
                        ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName(nameof(SafeHandle.DangerousAddRef))))
                            .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(refAddedName).WithRefKindKeyword(TokenWithSpace(SyntaxKind.RefKeyword)))))),
                        //// hTemplateFileLocal = (HANDLE)hTemplateFile.DangerousGetHandle();
                        ExpressionStatement(
                            AssignmentExpression(
                                SyntaxKind.SimpleAssignmentExpression,
                                typeDefHandleName,
                                CastExpression(
                                    externParam.Type.WithoutTrailingTrivia(),
                                    InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName(nameof(SafeHandle.DangerousGetHandle))), ArgumentList())))
                            .WithOperatorToken(TokenWithSpaces(SyntaxKind.EqualsToken)))),
                        //// else hTemplateFileLocal = default;
                        ElseClause(ExpressionStatement(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, typeDefHandleName, DefaultExpression(externParam.Type.WithoutTrailingTrivia())).WithOperatorToken(TokenWithSpaces(SyntaxKind.EqualsToken))))));

                    // if (hTemplateFileAddRef)
                    //     hTemplateFile.DangerousRelease();
                    finallyStatements.Add(
                        IfStatement(
                            refAddedName,
                            ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName(nameof(SafeHandle.DangerousRelease))), ArgumentList())))
                        .WithCloseParenToken(TokenWithLineFeed(SyntaxKind.CloseParenToken)));

                    // Accept the SafeHandle instead.
                    parameters[param.SequenceNumber - 1] = externParam
                        .WithType(IdentifierName(nameof(SafeHandle)).WithTrailingTrivia(TriviaList(Space)));

                    // hParamNameLocal;
                    arguments[param.SequenceNumber - 1] = Argument(typeDefHandleName);
                }
                else if ((externParam.Type is PointerTypeSyntax { ElementType: TypeSyntax ptrElementType }
                    && !IsVoid(ptrElementType)
                    && !this.IsInterface(parameterTypeInfo)) ||
                    externParam.Type is ArrayTypeSyntax)
                {
                    TypeSyntax elementType = externParam.Type is PointerTypeSyntax ptr ? ptr.ElementType
                        : externParam.Type is ArrayTypeSyntax array ? array.ElementType
                        : throw new InvalidOperationException();
                    bool isPointerToPointer = elementType is PointerTypeSyntax or FunctionPointerTypeSyntax;

                    // If there are no SAL annotations at all...
                    if (!isOptional && !isIn && !isOut)
                    {
                        // Consider that const means [In]
                        if (isConst)
                        {
                            isIn = true;
                            isOut = false;
                        }
                        else
                        {
                            // Otherwise assume bidirectional.
                            isIn = isOut = true;
                        }
                    }

                    bool isArray = false;
                    bool isNullTerminated = false; // TODO
                    short? sizeParamIndex = null;
                    int? sizeConst = null;
                    foreach (CustomAttributeHandle attHandle in param.GetCustomAttributes())
                    {
                        CustomAttribute att = this.Reader.GetCustomAttribute(attHandle);
                        if (this.IsAttribute(att, InteropDecorationNamespace, NativeArrayInfoAttribute))
                        {
                            var args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                            isArray = true;
                            sizeParamIndex = (short?)args.NamedArguments.FirstOrDefault(a => a.Name == "CountParamIndex").Value;
                            sizeConst = (int?)args.NamedArguments.FirstOrDefault(a => a.Name == "CountConst").Value;

                            break;
                        }
                    }

                    IdentifierNameSyntax origName = IdentifierName(parameters[param.SequenceNumber - 1].Identifier.ValueText);
                    IdentifierNameSyntax localName = IdentifierName(origName + "Local");
                    if (isArray)
                    {
                        // TODO: add support for in/out size parameters. (e.g. RSGetViewports)
                        // TODO: add support for lists of pointers via a generated pointer-wrapping struct (e.g. PSSetSamplers)
                        if (sizeParamIndex.HasValue
                            && !(externMethodDeclaration.ParameterList.Parameters[sizeParamIndex.Value].Type is PointerTypeSyntax)
                            && !isPointerToPointer)
                        {
                            signatureChanged = true;

                            if (lengthParamUsedBy.TryGetValue(sizeParamIndex.Value, out int userIndex))
                            {
                                // Multiple array parameters share a common 'length' parameter.
                                // Since we're making this a little less obvious, add a quick if check in the helper method
                                // that enforces that all such parameters have a common span length.
                                ExpressionSyntax otherUserName = IdentifierName(parameters[userIndex].Identifier.ValueText);
                                leadingStatements.Add(IfStatement(
                                    BinaryExpression(
                                        SyntaxKind.NotEqualsExpression,
                                        GetSpanLength(otherUserName),
                                        GetSpanLength(origName)),
                                    ThrowStatement(ObjectCreationExpression(IdentifierName(nameof(ArgumentException))).WithArgumentList(ArgumentList()))));
                            }
                            else
                            {
                                lengthParamUsedBy.Add(sizeParamIndex.Value, param.SequenceNumber - 1);
                            }

                            if (externParam.Type is PointerTypeSyntax)
                            {
                                parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                    .WithType((isIn && isConst ? MakeReadOnlySpanOfT(elementType) : MakeSpanOfT(elementType)).WithTrailingTrivia(TriviaList(Space)));
                                fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                                    VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                                arguments[param.SequenceNumber - 1] = Argument(localName);
                            }

                            ExpressionSyntax sizeArgExpression = GetSpanLength(origName);
                            if (!(parameters[sizeParamIndex.Value].Type is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.IntKeyword } }))
                            {
                                sizeArgExpression = CastExpression(parameters[sizeParamIndex.Value].Type!, sizeArgExpression);
                            }

                            arguments[sizeParamIndex.Value] = Argument(sizeArgExpression);
                        }
                        else if (sizeConst.HasValue && !isPointerToPointer)
                        {
                            // TODO: add support for lists of pointers via a generated pointer-wrapping struct
                            signatureChanged = true;

                            // Accept a span instead of a pointer.
                            parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                .WithType((isIn && isConst ? MakeReadOnlySpanOfT(elementType) : MakeSpanOfT(elementType)).WithTrailingTrivia(TriviaList(Space)));
                            fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                                VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                            arguments[param.SequenceNumber - 1] = Argument(localName);

                            // Add a runtime check that the span is at least the required length.
                            leadingStatements.Add(IfStatement(
                                BinaryExpression(
                                    SyntaxKind.LessThanExpression,
                                    GetSpanLength(origName),
                                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(sizeConst.Value))),
                                ThrowStatement(ObjectCreationExpression(IdentifierName(nameof(ArgumentException))).WithArgumentList(ArgumentList()))));
                        }
                        else if (isNullTerminated && isConst && parameters[param.SequenceNumber - 1].Type is PointerTypeSyntax { ElementType: PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.CharKeyword } } })
                        {
                            // replace char* with string
                            signatureChanged = true;
                            parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                .WithType(PredefinedType(TokenWithSpace(SyntaxKind.StringKeyword)));
                            fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                                VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                            arguments[param.SequenceNumber - 1] = Argument(localName);
                        }
                    }
                    else if (isIn && isOptional && !isOut && !isPointerToPointer)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(NullableType(elementType).WithTrailingTrivia(TriviaList(Space)));
                        leadingStatements.Add(
                            LocalDeclarationStatement(VariableDeclaration(elementType)
                                .AddVariables(VariableDeclarator(localName.Identifier).WithInitializer(
                                    EqualsValueClause(ConditionalExpression(
                                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("HasValue")),
                                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("Value")),
                                        DefaultExpression(elementType)))))));
                        arguments[param.SequenceNumber - 1] = Argument(ConditionalExpression(
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("HasValue")),
                            PrefixUnaryExpression(SyntaxKind.AddressOfExpression, localName),
                            LiteralExpression(SyntaxKind.NullLiteralExpression)));
                    }
                    else if (isIn && isOut && !isOptional)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(elementType.WithTrailingTrivia(TriviaList(Space)))
                            .WithModifiers(TokenList(TokenWithSpace(SyntaxKind.RefKeyword)));
                        fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                    else if (isOut && !isIn && !isOptional)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(elementType.WithTrailingTrivia(TriviaList(Space)))
                            .WithModifiers(TokenList(TokenWithSpace(SyntaxKind.OutKeyword)));
                        fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                    else if (isIn && !isOut && !isOptional)
                    {
                        // Use the "in" modifier to avoid copying the struct.
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(elementType.WithTrailingTrivia(TriviaList(Space)))
                            .WithModifiers(TokenList(TokenWithSpace(SyntaxKind.InKeyword)));
                        fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                }
                else if (isIn && !isOut && isConst && externParam.Type is QualifiedNameSyntax { Right: { Identifier: { ValueText: "PCWSTR" } } })
                {
                    IdentifierNameSyntax origName = IdentifierName(externParam.Identifier.ValueText);
                    IdentifierNameSyntax localName = IdentifierName(origName + "Local");
                    signatureChanged = true;
                    parameters[param.SequenceNumber - 1] = externParam
                        .WithType(PredefinedType(TokenWithSpace(SyntaxKind.StringKeyword)));
                    fixedBlocks.Add(VariableDeclaration(PointerType(PredefinedType(Token(SyntaxKind.CharKeyword)))).AddVariables(
                        VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                    arguments[param.SequenceNumber - 1] = Argument(localName);
                }
            }

            TypeSyntax? returnSafeHandleType = originalSignature.ReturnType is HandleTypeHandleInfo returnTypeHandleInfo
                && this.TryGetHandleReleaseMethod(returnTypeHandleInfo.Handle, out string? returnReleaseMethod)
                ? this.RequestSafeHandle(returnReleaseMethod) : null;
            SyntaxToken friendlyMethodName = externMethodDeclaration.Identifier;

            if (returnSafeHandleType is object && !signatureChanged)
            {
                // The parameter types are all the same, but we need a friendly overload with a different return type.
                // Our only choice is to rename the friendly overload.
                friendlyMethodName = Identifier(externMethodDeclaration.Identifier.ValueText + "_SafeHandle");
                signatureChanged = true;
            }

            if (signatureChanged)
            {
                if (lengthParamUsedBy.Count > 0)
                {
                    // Remove in reverse order so as to not invalidate the indexes of elements to remove.
                    // Also take care to only remove each element once, even if it shows up multiple times in the collection.
                    var parameterIndexesToRemove = new SortedSet<int>(lengthParamUsedBy.Keys);
                    foreach (int indexToRemove in parameterIndexesToRemove.Reverse())
                    {
                        parameters.RemoveAt(indexToRemove);
                    }
                }

                TypeSyntax docRefExternName = overloadOf == FriendlyOverloadOf.InterfaceMethod
                    ? QualifiedName(declaringTypeName, IdentifierName(externMethodDeclaration.Identifier))
                    : IdentifierName(externMethodDeclaration.Identifier);
                var leadingTrivia = Trivia(
                    DocumentationCommentTrivia(SyntaxKind.SingleLineDocumentationCommentTrivia).AddContent(
                        XmlText("/// "),
                        XmlEmptyElement("inheritdoc").AddAttributes(XmlCrefAttribute(NameMemberCref(docRefExternName, ToCref(externMethodDeclaration.ParameterList)))),
                        XmlText().AddTextTokens(XmlTextNewLine("\n", continueXmlDocumentationComment: false))));
                InvocationExpressionSyntax externInvocation = InvocationExpression(
                    overloadOf switch
                    {
                        FriendlyOverloadOf.ExternMethod => QualifiedName(declaringTypeName, IdentifierName(externMethodDeclaration.Identifier.Text)),
                        FriendlyOverloadOf.StructMethod => MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName(externMethodDeclaration.Identifier.Text)),
                        FriendlyOverloadOf.InterfaceMethod => MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("@this"), IdentifierName(externMethodDeclaration.Identifier.Text)),
                        _ => throw new NotSupportedException("Unrecognized friendly overload mode " + overloadOf),
                    })
                    .WithArgumentList(FixTrivia(ArgumentList().AddArguments(arguments.ToArray())));
                bool hasVoidReturn = externMethodReturnType is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.VoidKeyword } };
                var body = Block().AddStatements(leadingStatements.ToArray());
                IdentifierNameSyntax resultLocal = IdentifierName("__result");
                if (returnSafeHandleType is object)
                {
                    //// HANDLE result = invocation();
                    body = body.AddStatements(LocalDeclarationStatement(VariableDeclaration(externMethodReturnType)
                        .AddVariables(VariableDeclarator(resultLocal.Identifier).WithInitializer(EqualsValueClause(externInvocation)))));

                    body = body.AddStatements(trailingStatements.ToArray());

                    //// return new SafeHandle(result, ownsHandle: true);
                    body = body.AddStatements(ReturnStatement(ObjectCreationExpression(returnSafeHandleType).AddArgumentListArguments(
                        Argument(resultLocal),
                        Argument(LiteralExpression(SyntaxKind.TrueLiteralExpression)).WithNameColon(NameColon(IdentifierName("ownsHandle"))))));
                }
                else if (hasVoidReturn)
                {
                    body = body.AddStatements(ExpressionStatement(externInvocation));
                    body = body.AddStatements(trailingStatements.ToArray());
                }
                else
                {
                    // var result = externInvocation();
                    body = body.AddStatements(LocalDeclarationStatement(VariableDeclaration(externMethodReturnType)
                        .AddVariables(VariableDeclarator(resultLocal.Identifier).WithInitializer(EqualsValueClause(externInvocation)))));

                    body = body.AddStatements(trailingStatements.ToArray());

                    // return result;
                    body = body.AddStatements(ReturnStatement(resultLocal));
                }

                foreach (var fixedExpression in fixedBlocks)
                {
                    body = Block(FixedStatement(fixedExpression, body).WithFixedKeyword(TokenWithSpace(SyntaxKind.FixedKeyword)));
                }

                if (finallyStatements.Count > 0)
                {
                    body = Block()
                        .AddStatements(leadingOutsideTryStatements.ToArray())
                        .AddStatements(TryStatement(body, default, FinallyClause(Block().AddStatements(finallyStatements.ToArray()))));
                }
                else if (leadingOutsideTryStatements.Count > 0)
                {
                    body = body.WithStatements(body.Statements.InsertRange(0, leadingOutsideTryStatements));
                }

                var modifiers = TokenList(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.UnsafeKeyword));
                if (overloadOf != FriendlyOverloadOf.StructMethod)
                {
                    modifiers = modifiers.Insert(1, TokenWithSpace(SyntaxKind.StaticKeyword));
                }

                if (overloadOf == FriendlyOverloadOf.InterfaceMethod)
                {
                    parameters.Insert(0, Parameter(Identifier("@this")).WithType(declaringTypeName.WithTrailingTrivia(TriviaList(Space))).AddModifiers(TokenWithSpace(SyntaxKind.ThisKeyword)));
                }

                body = body
                    .WithOpenBraceToken(Token(TriviaList(LineFeed), SyntaxKind.OpenBraceToken, TriviaList(LineFeed)))
                    .WithCloseBraceToken(TokenWithLineFeed(SyntaxKind.CloseBraceToken));

                MethodDeclarationSyntax friendlyDeclaration = externMethodDeclaration
                    .WithReturnType(externMethodReturnType.WithTrailingTrivia(TriviaList(Space)))
                    .WithIdentifier(friendlyMethodName)
                    .WithModifiers(modifiers)
                    .WithAttributeLists(List<AttributeListSyntax>())
                    .WithParameterList(FixTrivia(ParameterList().AddParameters(parameters.ToArray())))
                    .WithBody(body)
                    .WithSemicolonToken(default);

                if (returnSafeHandleType is object)
                {
                    friendlyDeclaration = friendlyDeclaration.WithReturnType(returnSafeHandleType.WithTrailingTrivia(TriviaList(Space)));
                }

                if (this.GetSupportedOSPlatformAttribute(methodDefinition.GetCustomAttributes()) is AttributeSyntax supportedOSPlatformAttribute)
                {
                    friendlyDeclaration = friendlyDeclaration.AddAttributeLists(AttributeList().AddAttributes(supportedOSPlatformAttribute));
                }

                friendlyDeclaration = friendlyDeclaration
                    .WithLeadingTrivia(leadingTrivia);

                yield return friendlyDeclaration;
            }
#pragma warning restore SA1114 // Parameter list should follow declaration
        }

        private string GetNormalizedModuleName(MethodImport import)
        {
            ModuleReference module = this.Reader.GetModuleReference(import.Module);
            string moduleName = this.Reader.GetString(module.Name);
            if (CanonicalCapitalizations.TryGetValue(moduleName, out string? canonicalModuleName))
            {
                moduleName = canonicalModuleName;
            }

            return moduleName;
        }

        private ParameterListSyntax CreateParameterList(MethodDefinition methodDefinition, MethodSignature<TypeHandleInfo> signature, TypeSyntaxSettings typeSettings)
            => ParameterList().AddParameters(methodDefinition.GetParameters().Select(this.Reader.GetParameter).Where(p => !p.Name.IsNil).Select(p => this.CreateParameter(signature.ParameterTypes[p.SequenceNumber - 1], p, typeSettings)).ToArray());

        private ParameterSyntax CreateParameter(TypeHandleInfo parameterInfo, Parameter parameter, TypeSyntaxSettings typeSettings)
        {
            string name = this.Reader.GetString(parameter.Name);
            try
            {
                // TODO:
                // * Notice [Out][RAIIFree] handle producing parameters. Can we make these provide SafeHandle's?
                bool isReturnOrOutParam = parameter.SequenceNumber == 0 || (parameter.Attributes & ParameterAttributes.Out) == ParameterAttributes.Out;
                var parameterTypeSyntax = parameterInfo.ToTypeSyntax(typeSettings, parameter.GetCustomAttributes(), parameter.Attributes);

                // Determine the custom attributes to apply.
                var attributes = AttributeList();
                if (parameterTypeSyntax.Type is PointerTypeSyntax ptr)
                {
                    if ((parameter.Attributes & ParameterAttributes.Optional) == ParameterAttributes.Optional)
                    {
                        attributes = attributes.AddAttributes(OptionalAttributeSyntax);
                    }
                }

                var modifiers = TokenList();
                if (parameterTypeSyntax.ParameterModifier.HasValue)
                {
                    modifiers = modifiers.Add(parameterTypeSyntax.ParameterModifier.Value.WithTrailingTrivia(TriviaList(Space)));
                }

                ParameterSyntax parameterSyntax = Parameter(
                    attributes.Attributes.Count > 0 ? List<AttributeListSyntax>().Add(attributes) : List<AttributeListSyntax>(),
                    modifiers,
                    parameterTypeSyntax.Type.WithTrailingTrivia(TriviaList(Space)),
                    SafeIdentifier(name),
                    @default: null);
                parameterSyntax = parameterTypeSyntax.AddMarshalAs(parameterSyntax);

                if (parameter.GetCustomAttributes().Any(h => this.IsAttribute(this.Reader.GetCustomAttribute(h), InteropDecorationNamespace, "RetValAttribute")))
                {
                    parameterSyntax = parameterSyntax.WithAdditionalAnnotations(IsRetValAnnotation);
                }

                return parameterSyntax;
            }
            catch (Exception ex)
            {
                throw new GenerationFailedException("Failed while generating parameter: " + name, ex);
            }
        }

        private (TypeSyntax FieldType, SyntaxList<MemberDeclarationSyntax> AdditionalMembers) ReinterpretFieldType(FieldDefinition fieldDef, TypeSyntax originalType, CustomAttributeHandleCollection customAttributes)
        {
            TypeSyntaxSettings typeSettings = this.fieldTypeSettings;
            TypeHandleInfo fieldTypeHandleInfo = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null);

            // If the field is a fixed length array, we have to work some code gen magic since C# does not allow those.
            if (originalType is ArrayTypeSyntax arrayType && arrayType.RankSpecifiers.Count > 0 && arrayType.RankSpecifiers[0].Sizes.Count == 1)
            {
                int length = int.Parse(((LiteralExpressionSyntax)arrayType.RankSpecifiers[0].Sizes[0]).Token.ValueText, CultureInfo.InvariantCulture);
                TypeSyntax elementType = arrayType.ElementType;

                // C# does not allow Span<T> where T is a pointer type.
                if (elementType is PointerTypeSyntax ptr)
                {
                    elementType = IntPtrTypeSyntax;
                }

                var lengthLiteralSyntax = LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(length));

                // internal struct __TheStruct_Count
                // {
                //     internal TheStruct _0, _1, _2, _3, _4, _5, _6, _7, _8;
                //     /// <summary>Always <c>8</c>.</summary>
                //     internal int Length => 8;
                // ...
                IdentifierNameSyntax fixedLengthStructName = IdentifierName($"__{elementType.ToString().Replace(' ', '_').Replace('.', '_').Replace(':', '_').Replace('*', '_').Replace('<', '_').Replace('>', '_').Replace('[', '_').Replace(']', '_').Replace(',', '_')}_{length}");
                SyntaxTokenList fieldModifiers = TokenList(TokenWithSpace(this.Visibility));
                if (RequiresUnsafe(elementType))
                {
                    fieldModifiers = fieldModifiers.Add(TokenWithSpace(SyntaxKind.UnsafeKeyword));
                }

                var fixedLengthStruct = StructDeclaration(fixedLengthStructName.Identifier)
                    .AddModifiers(TokenWithSpace(this.Visibility))
                    .AddMembers(
                        FieldDeclaration(VariableDeclaration(elementType)
                            .AddVariables(Enumerable.Range(0, length).Select(n => VariableDeclarator(Identifier($"_{n}"))).ToArray()))
                            .WithModifiers(fieldModifiers),
                        PropertyDeclaration(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword)), "Length")
                            .AddModifiers(TokenWithSpace(this.Visibility))
                            .WithExpressionBody(ArrowExpressionClause(lengthLiteralSyntax))
                            .WithSemicolonToken(SemicolonWithLineFeed)
                            .WithLeadingTrivia(Trivia(DocumentationCommentTrivia(SyntaxKind.SingleLineDocumentationCommentTrivia).AddContent(
                                DocCommentStart,
                                XmlElement("summary", List(new XmlNodeSyntax[]
                                {
                                    XmlText("Always "),
                                    XmlElement("c", List(new XmlNodeSyntax[] { XmlText(lengthLiteralSyntax.Token.ValueText) })),
                                    XmlText("."),
                                })),
                                DocCommentEnd))));

                IdentifierNameSyntax GetElementFieldName(int index) => IdentifierName(FormattableString.Invariant($"_{index}"));
                var firstElementFieldName = GetElementFieldName(0);
                if (this.canCallCreateSpan)
                {
                    // ...
                    //     internal ref TheStruct this[int index] => ref AsSpan()[index];
                    //     internal Span<TheStruct> AsSpan() => MemoryMarshal.CreateSpan(ref _1, 4);
                    fixedLengthStruct = fixedLengthStruct
                        .AddMembers(
                            IndexerDeclaration(RefType(elementType).WithTrailingTrivia(TriviaList(Space)))
                                .AddModifiers(TokenWithSpace(this.Visibility))
                                .AddParameterListParameters(Parameter(Identifier("index")).WithType(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword))))
                                .WithExpressionBody(ArrowExpressionClause(RefExpression(
                                    ElementAccessExpression(InvocationExpression(IdentifierName("AsSpan")))
                                        .AddArgumentListArguments(Argument(IdentifierName("index"))))))
                                .WithSemicolonToken(SemicolonWithLineFeed)
                                .WithLeadingTrivia(InlineArrayUnsafeIndexerComment),
                            MethodDeclaration(MakeSpanOfT(elementType).WithTrailingTrivia(TriviaList(Space)), Identifier("AsSpan"))
                                .AddModifiers(TokenWithSpace(this.Visibility))
                                .WithExpressionBody(ArrowExpressionClause(
                                    InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("MemoryMarshal"), IdentifierName("CreateSpan")))
                                        .WithArgumentList(FixTrivia(ArgumentList().AddArguments(
                                            Argument(nameColon: null, TokenWithSpace(SyntaxKind.RefKeyword), firstElementFieldName),
                                            Argument(lengthLiteralSyntax))))))
                                .WithSemicolonToken(SemicolonWithLineFeed)
                                .WithLeadingTrivia(InlineArrayUnsafeAsSpanComment));
                }

                IdentifierNameSyntax indexParamName = IdentifierName("index");
                IdentifierNameSyntax p0 = IdentifierName("p0");
                IdentifierNameSyntax atThis = IdentifierName("@this");
                TypeSyntax qualifiedElementType = elementType == IntPtrTypeSyntax ? elementType : ((ArrayTypeSyntax)fieldTypeHandleInfo.ToTypeSyntax(this.extensionMethodSignatureTypeSettings, customAttributes).Type).ElementType;

                ////internal static unsafe ref readonly uint ReadOnlyItemRef(this in MainAVIHeader.__dwReserved_4 @this, int index)
                ////{
                ////    fixed (uint* p0 = &@this._1)
                ////        return ref p0[index];
                ////    - or (for managed elements) -
                ////    switch (index)
                ////    {
                ////      case 0: ref return @this._0;
                ////      case 1: ref return @this._1;
                ////      default: throw new ArgumentOutOfRangeException();
                ////    }
                ////}
                StatementSyntax? statement =
                    fieldTypeHandleInfo is ArrayTypeHandleInfo { ElementType: { } arrayElement } && this.IsManagedType(arrayElement)
                     ? SwitchStatement(indexParamName)
                        .AddSections(Enumerable.Range(0, length).Select(n => SwitchSection()
                            .AddLabels(CaseSwitchLabel(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(n))))
                            .AddStatements(ReturnStatement(RefExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, atThis, GetElementFieldName(n)))))).ToArray())
                        .AddSections(SwitchSection().AddLabels(DefaultSwitchLabel()).AddStatements(ThrowStatement(
                            ObjectCreationExpression(IdentifierName(nameof(ArgumentOutOfRangeException)))
                                .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(InvocationExpression(IdentifierName("nameof")).WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(indexParamName)))))))))))
                     : FixedStatement(
                        VariableDeclaration(PointerType(qualifiedElementType)).AddVariables(
                            VariableDeclarator(p0.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(
                                    SyntaxKind.AddressOfExpression,
                                    MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, atThis, firstElementFieldName))))),
                        ReturnStatement(RefExpression(ElementAccessExpression(p0).AddArgumentListArguments(Argument(indexParamName)))))
                        .WithFixedKeyword(TokenWithSpace(SyntaxKind.FixedKeyword));
                BlockSyntax body = Block().AddStatements(statement);
                ParameterSyntax thisParameter = Parameter(atThis.Identifier)
                    .WithType(QualifiedName((NameSyntax)new HandleTypeHandleInfo(this.Reader, fieldDef.GetDeclaringType()).ToTypeSyntax(this.extensionMethodSignatureTypeSettings, customAttributes).Type, fixedLengthStructName).WithTrailingTrivia(TriviaList(Space)))
                    .AddModifiers(TokenWithSpace(SyntaxKind.ThisKeyword));
                ParameterSyntax indexParameter = Parameter(indexParamName.Identifier).WithType(PredefinedType(TokenWithSpace(SyntaxKind.IntKeyword)));
                SyntaxTokenList methodModifiers = TokenList(TokenWithSpace(this.Visibility), TokenWithSpace(SyntaxKind.StaticKeyword), TokenWithSpace(SyntaxKind.UnsafeKeyword));
                MethodDeclarationSyntax getAtMethod = MethodDeclaration(RefType(qualifiedElementType.WithTrailingTrivia(TriviaList(Space))).WithReadOnlyKeyword(TokenWithSpace(SyntaxKind.ReadOnlyKeyword)), Identifier("ReadOnlyItemRef"))
                    .WithModifiers(methodModifiers)
                    .WithParameterList(FixTrivia(ParameterList().AddParameters(thisParameter.AddModifiers(TokenWithSpace(SyntaxKind.InKeyword)), indexParameter)))
                    .WithBody(body);
                this.volatileCode.AddInlineArrayIndexerExtension(getAtMethod);

                ////internal static unsafe ref uint ItemRef(this ref MainAVIHeader.__dwReserved_4 @this, int index)
                ////{
                ////    fixed (uint* p0 = &@this._1)
                ////        return ref p0[index];
                ////}
                MethodDeclarationSyntax getOrSetAtMethod = MethodDeclaration(RefType(qualifiedElementType.WithTrailingTrivia(TriviaList(Space))), Identifier("ItemRef"))
                    .WithModifiers(methodModifiers)
                    .WithParameterList(FixTrivia(ParameterList().AddParameters(thisParameter.AddModifiers(TokenWithSpace(SyntaxKind.RefKeyword)), indexParameter)))
                    .WithBody(body);
                this.volatileCode.AddInlineArrayIndexerExtension(getOrSetAtMethod);

                return (fixedLengthStructName, List<MemberDeclarationSyntax>().Add(fixedLengthStruct));
            }

            if (!this.options.AllowMarshaling)
            {
                // If the field is a delegate type, we have to replace that with a native function pointer to avoid the struct becoming a 'managed type'.
                if (this.IsDelegateReference(fieldTypeHandleInfo, out TypeDefinition typeDef))
                {
                    return (this.FunctionPointer(typeDef), default);
                }
            }

            // If the field is a pointer to a COM interface (and we're using bona fide interfaces),
            // then we must type it as an array.
            if (fieldTypeHandleInfo is PointerTypeHandleInfo ptr3 && this.IsManagedType(ptr3.ElementType))
            {
                return (ArrayType(ptr3.ElementType.ToTypeSyntax(typeSettings, null).Type).AddRankSpecifiers(ArrayRankSpecifier()), default);
            }

            return (originalType, default);
        }

        private bool IsTypeDefStruct(TypeHandleInfo? typeHandleInfo)
        {
            if (typeHandleInfo is HandleTypeHandleInfo handleInfo)
            {
                if (handleInfo.Handle.Kind == HandleKind.TypeDefinition)
                {
                    TypeDefinition typeDef = this.Reader.GetTypeDefinition((TypeDefinitionHandle)handleInfo.Handle);
                    return this.IsTypeDefStruct(typeDef);
                }
                else if (handleInfo.Handle.Kind == HandleKind.TypeReference && this.TryGetTypeDefHandle((TypeReferenceHandle)handleInfo.Handle, out TypeDefinitionHandle tdh))
                {
                    TypeDefinition typeDef = this.Reader.GetTypeDefinition(tdh);
                    return this.IsTypeDefStruct(typeDef);
                }
            }
            else if (SpecialTypeDefNames.Contains(null!/*TODO*/))
            {
                return true;
            }

            return false;
        }

        private bool IsDelegateReference(TypeHandleInfo typeHandleInfo, out TypeDefinition delegateTypeDef)
        {
            if (typeHandleInfo is PointerTypeHandleInfo { ElementType: HandleTypeHandleInfo handleInfo })
            {
                return this.IsDelegateReference(handleInfo, out delegateTypeDef);
            }
            else if (typeHandleInfo is HandleTypeHandleInfo handleInfo1)
            {
                return this.IsDelegateReference(handleInfo1, out delegateTypeDef);
            }

            delegateTypeDef = default;
            return false;
        }

        private bool IsDelegateReference(HandleTypeHandleInfo typeHandleInfo, out TypeDefinition delegateTypeDef)
        {
            if (typeHandleInfo.Handle.Kind == HandleKind.TypeDefinition)
            {
                var tdh = (TypeDefinitionHandle)typeHandleInfo.Handle;
                delegateTypeDef = this.Reader.GetTypeDefinition(tdh);
                return this.IsDelegate(delegateTypeDef);
            }

            delegateTypeDef = default;
            return false;
        }

        private bool IsManagedType(TypeDefinitionHandle typeDefinitionHandle)
        {
            var visitedTypes = new HashSet<TypeDefinitionHandle>();
            return Helper(typeDefinitionHandle)!.Value;

            bool? Helper(TypeDefinitionHandle typeDefinitionHandle)
            {
                if (!visitedTypes.Add(typeDefinitionHandle))
                {
                    // Avoid recursion. We just don't know the answer yet.
                    return null;
                }

                TypeDefinition typeDef = this.Reader.GetTypeDefinition(typeDefinitionHandle);
                try
                {
                    if ((typeDef.Attributes & TypeAttributes.Interface) == TypeAttributes.Interface)
                    {
                        return this.options.AllowMarshaling && !this.IsNonCOMInterface(typeDef);
                    }

                    this.GetBaseTypeInfo(typeDef, out StringHandle baseName, out StringHandle baseNamespace);
                    if (this.Reader.StringComparer.Equals(baseName, nameof(ValueType)) && this.Reader.StringComparer.Equals(baseNamespace, nameof(System)))
                    {
                        if (this.IsTypeDefStruct(typeDef))
                        {
                            return false;
                        }
                        else
                        {
                            foreach (FieldDefinitionHandle fieldHandle in typeDef.GetFields())
                            {
                                FieldDefinition fieldDef = this.Reader.GetFieldDefinition(fieldHandle);
                                try
                                {
                                    TypeHandleInfo elementType = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null);
                                    while (elementType is ITypeHandleContainer container)
                                    {
                                        elementType = container.ElementType;
                                    }

                                    if (elementType is PrimitiveTypeHandleInfo)
                                    {
                                        // These are never managed.
                                        continue;
                                    }
                                    else if (elementType is HandleTypeHandleInfo { Handle: { Kind: HandleKind.TypeDefinition } fieldTypeDefHandle })
                                    {
                                        if (Helper((TypeDefinitionHandle)fieldTypeDefHandle) is true)
                                        {
                                            return true;
                                        }
                                    }
                                    else if (elementType is HandleTypeHandleInfo { Handle: { Kind: HandleKind.TypeReference } fieldTypeRefHandle })
                                    {
                                        if (this.TryGetTypeDefHandle((TypeReferenceHandle)fieldTypeRefHandle, out TypeDefinitionHandle tdr) && Helper(tdr) is true)
                                        {
                                            return true;
                                        }
                                    }
                                    else
                                    {
                                        throw new GenerationFailedException("Unrecognized type.");
                                    }
                                }
                                catch (Exception ex)
                                {
                                    throw new GenerationFailedException($"Unable to ascertain whether the {this.Reader.GetString(fieldDef.Name)} field represents a managed type.", ex);
                                }
                            }

                            return false;
                        }
                    }
                    else if (this.Reader.StringComparer.Equals(baseName, nameof(Enum)) && this.Reader.StringComparer.Equals(baseNamespace, nameof(System)))
                    {
                        return false;
                    }
                    else if (this.Reader.StringComparer.Equals(baseName, nameof(MulticastDelegate)) && this.Reader.StringComparer.Equals(baseNamespace, nameof(System)))
                    {
                        // Delegates appear as unmanaged function pointers when using structs instead of COM interfaces.
                        return this.options.AllowMarshaling;
                    }

                    throw new NotSupportedException();
                }
                catch (Exception ex)
                {
                    throw new GenerationFailedException($"Unable to determine if {new HandleTypeHandleInfo(this.Reader, typeDefinitionHandle).ToTypeSyntax(this.errorMessageTypeSettings, null)} is a managed type.", ex);
                }
            }
        }

        private UnmanagedType? GetUnmanagedType(BlobHandle blobHandle)
        {
            if (blobHandle.IsNil)
            {
                return null;
            }

            BlobReader br = this.Reader.GetBlobReader(blobHandle);
            UnmanagedType unmgdType = (UnmanagedType)br.ReadByte();
            return unmgdType;
        }

        private MarshalAsAttribute ToMarshalAsAttribute(BlobHandle blobHandle)
        {
            BlobReader br = this.Reader.GetBlobReader(blobHandle);
            UnmanagedType unmgdType = (UnmanagedType)br.ReadByte();
            MarshalAsAttribute ma = new MarshalAsAttribute(unmgdType);
            switch (unmgdType)
            {
                case UnmanagedType.Interface:
                case UnmanagedType.IUnknown:
                case UnmanagedType.IDispatch:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.IidParameterIndex = br.ReadCompressedInteger();
                    break;

                case UnmanagedType.ByValArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeConst = br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.ArraySubType = (UnmanagedType)br.ReadCompressedInteger();

                    break;

                case UnmanagedType.SafeArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SafeArraySubType = (VarEnum)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }
                    ////string udtName = br.ReadSerializedString();
                    ////ma.SafeArrayUserDefinedSubType = Helpers.LoadTypeFromAssemblyQualifiedName(udtName, module.GetRoAssembly(), ignoreCase: false, throwOnError: false);
                    break;

                case UnmanagedType.LPArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.ArraySubType = (UnmanagedType)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeParamIndex = (short)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeConst = br.ReadCompressedInteger();
                    break;

                case UnmanagedType.CustomMarshaler:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    br.ReadSerializedString(); // Skip the typelib guid.

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    br.ReadSerializedString(); // Skip name of native type.

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.MarshalType = br.ReadSerializedString();
                    ////ma.MarshalTypeRef = Helpers.LoadTypeFromAssemblyQualifiedName(ma.MarshalType, module.GetRoAssembly(), ignoreCase: false, throwOnError: false);

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.MarshalCookie = br.ReadSerializedString();
                    break;

                default:
                    break;
            }

            return ma;
        }

        private ExpressionSyntax ToExpressionSyntax(Constant constant)
        {
            var blobReader = this.Reader.GetBlobReader(constant.Value);
            return constant.TypeCode switch
            {
                ConstantTypeCode.Boolean => blobReader.ReadBoolean() ? LiteralExpression(SyntaxKind.TrueLiteralExpression) : LiteralExpression(SyntaxKind.FalseLiteralExpression),
                ConstantTypeCode.Char => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadChar())),
                ConstantTypeCode.SByte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadSByte())),
                ConstantTypeCode.Byte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadByte())),
                ConstantTypeCode.Int16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt16())),
                ConstantTypeCode.UInt16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt16())),
                ConstantTypeCode.Int32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt32())),
                ConstantTypeCode.UInt32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt32())),
                ConstantTypeCode.Int64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt64())),
                ConstantTypeCode.UInt64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt64())),
                ConstantTypeCode.Single => FloatExpression(blobReader.ReadSingle()),
                ConstantTypeCode.Double => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadDouble())),
                ConstantTypeCode.String => blobReader.ReadConstant(constant.TypeCode) is string value ? LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(value)) : LiteralExpression(SyntaxKind.NullLiteralExpression),
                ConstantTypeCode.NullReference => LiteralExpression(SyntaxKind.NullLiteralExpression),
                _ => throw new NotSupportedException("ConstantTypeCode not supported: " + constant.TypeCode),
            };

            static ExpressionSyntax FloatExpression(float value)
            {
                return
                    float.IsPositiveInfinity(value) ? MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, PredefinedType(Token(SyntaxKind.FloatKeyword)), IdentifierName(nameof(float.PositiveInfinity))) :
                    float.IsNegativeInfinity(value) ? MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, PredefinedType(Token(SyntaxKind.FloatKeyword)), IdentifierName(nameof(float.NegativeInfinity))) :
                    float.IsNaN(value) ? MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, PredefinedType(Token(SyntaxKind.FloatKeyword)), IdentifierName(nameof(float.NaN))) :
                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(value));
            }
        }

        private ExpressionSyntax ToHexExpressionSyntax(Constant constant)
        {
            var blobReader = this.Reader.GetBlobReader(constant.Value);
            var blobReader2 = this.Reader.GetBlobReader(constant.Value);
            return constant.TypeCode switch
            {
                ConstantTypeCode.SByte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadSByte()), blobReader2.ReadSByte())),
                ConstantTypeCode.Byte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadByte()), blobReader2.ReadByte())),
                ConstantTypeCode.Int16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt16()), blobReader2.ReadInt16())),
                ConstantTypeCode.UInt16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt16()), blobReader2.ReadUInt16())),
                ConstantTypeCode.Int32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt32()), blobReader2.ReadInt32())),
                ConstantTypeCode.UInt32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt32()), blobReader2.ReadUInt32())),
                ConstantTypeCode.Int64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt64()), blobReader2.ReadInt64())),
                ConstantTypeCode.UInt64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt64()), blobReader2.ReadUInt64())),
                _ => throw new NotSupportedException("ConstantTypeCode not supported: " + constant.TypeCode),
            };
        }

        private IEnumerable<NamespaceMetadata> GetNamespacesToSearch(string? @namespace)
        {
            if (@namespace is object)
            {
                return this.MetadataIndex.MetadataByNamespace.TryGetValue(@namespace, out var metadata)
                    ? new[] { metadata }
                    : Array.Empty<NamespaceMetadata>();
            }
            else
            {
                return this.MetadataIndex.MetadataByNamespace.Values;
            }
        }

        private class GeneratedCode
        {
            private readonly GeneratedCode? parent;

            private Dictionary<string, List<MemberDeclarationSyntax>> modulesAndMembers = new Dictionary<string, List<MemberDeclarationSyntax>>(StringComparer.OrdinalIgnoreCase);

            /// <summary>
            /// The structs, enums, delegates and other supporting types for extern methods.
            /// </summary>
            private Dictionary<TypeDefinitionHandle, MemberDeclarationSyntax> types = new();

            private Dictionary<FieldDefinitionHandle, FieldDeclarationSyntax> fieldsToSyntax = new();

            private List<ClassDeclarationSyntax> safeHandleTypes = new();

            private Dictionary<string, MemberDeclarationSyntax> specialTypes = new(StringComparer.Ordinal);

            /// <summary>
            /// The set of types that are or have been generated so we don't stack overflow for self-referencing types.
            /// </summary>
            private Dictionary<TypeDefinitionHandle, Exception?> typesGenerating = new();

            /// <summary>
            /// The set of methods that are or have been generated.
            /// </summary>
            private Dictionary<MethodDefinitionHandle, Exception?> methodsGenerating = new();

            /// <summary>
            /// A collection of the names of special types we are or have generated.
            /// </summary>
            private Dictionary<string, Exception?> specialTypesGenerating = new(StringComparer.Ordinal);

            private Dictionary<string, TypeSyntax?> releaseMethodsWithSafeHandleTypesGenerating = new();

            private List<MethodDeclarationSyntax> inlineArrayIndexerExtensionsMembers = new();

            private List<MethodDeclarationSyntax> comInterfaceFriendlyExtensionsMembers = new();

            private bool generating;

            internal GeneratedCode()
            {
            }

            internal GeneratedCode(GeneratedCode parent)
            {
                this.parent = parent;
            }

            internal IEnumerable<MemberDeclarationSyntax> GeneratedTypes => this.types.Values.Concat(this.specialTypes.Values).Concat(this.safeHandleTypes);

            internal IEnumerable<MethodDeclarationSyntax> ComInterfaceExtensions => this.comInterfaceFriendlyExtensionsMembers;

            internal IEnumerable<MethodDeclarationSyntax> InlineArrayIndexerExtensions => this.inlineArrayIndexerExtensionsMembers;

            internal IEnumerable<FieldDeclarationSyntax> Fields => this.fieldsToSyntax.Values;

            internal IEnumerable<IGrouping<string, MemberDeclarationSyntax>> MembersByModule
            {
                get
                {
                    foreach (var item in this.modulesAndMembers)
                    {
                        yield return new Grouping<string, MemberDeclarationSyntax>(item.Key, item.Value);
                    }
                }
            }

            internal void AddSafeHandleType(ClassDeclarationSyntax safeHandleDeclaration)
            {
                this.ThrowIfNotGenerating();

                this.safeHandleTypes.Add(safeHandleDeclaration);
            }

            internal void AddMemberToModule(string moduleName, MemberDeclarationSyntax member)
            {
                this.ThrowIfNotGenerating();

                if (!this.modulesAndMembers.TryGetValue(moduleName, out var methodsList))
                {
                    this.modulesAndMembers.Add(moduleName, methodsList = new List<MemberDeclarationSyntax>());
                }

                methodsList.Add(member);
            }

            internal void AddMemberToModule(string moduleName, IEnumerable<MemberDeclarationSyntax> members)
            {
                this.ThrowIfNotGenerating();

                if (!this.modulesAndMembers.TryGetValue(moduleName, out var methodsList))
                {
                    this.modulesAndMembers.Add(moduleName, methodsList = new List<MemberDeclarationSyntax>());
                }

                methodsList.AddRange(members);
            }

            internal void AddConstant(FieldDefinitionHandle fieldDefHandle, FieldDeclarationSyntax constantDeclaration)
            {
                this.ThrowIfNotGenerating();
                this.fieldsToSyntax.Add(fieldDefHandle, constantDeclaration);
            }

            internal void AddInlineArrayIndexerExtension(MethodDeclarationSyntax inlineIndexer)
            {
                this.ThrowIfNotGenerating();

                string thisParameter = inlineIndexer.ParameterList.Parameters[0].Type!.ToString();
                if (!this.inlineArrayIndexerExtensionsMembers.Any(m => m.Identifier.ValueText == inlineIndexer.Identifier.ValueText && m.ParameterList.Parameters[0].Type!.ToString() == thisParameter))
                {
                    this.inlineArrayIndexerExtensionsMembers.Add(inlineIndexer);
                }
            }

            internal void AddComInterfaceExtension(MethodDeclarationSyntax extension)
            {
                this.ThrowIfNotGenerating();
                this.comInterfaceFriendlyExtensionsMembers.Add(extension);
            }

            internal void AddComInterfaceExtension(IEnumerable<MethodDeclarationSyntax> extension)
            {
                this.ThrowIfNotGenerating();
                this.comInterfaceFriendlyExtensionsMembers.AddRange(extension);
            }

            internal void AddSpecialType(string specialName, MemberDeclarationSyntax specialDeclaration)
            {
                this.ThrowIfNotGenerating();
                this.specialTypes.Add(specialName, specialDeclaration);
            }

            internal void AddInteropType(TypeDefinitionHandle typeDefinitionHandle, MemberDeclarationSyntax typeDeclaration)
            {
                this.ThrowIfNotGenerating();
                this.types.Add(typeDefinitionHandle, typeDeclaration);
            }

            internal void GenerationTransaction(Action generator)
            {
                if (this.parent is null)
                {
                    throw new InvalidOperationException("Code generation should occur in a volatile instance.");
                }

                if (this.generating)
                {
                    // A transaction is already running. Just run the generator.
                    generator();
                    return;
                }

                try
                {
                    this.generating = true;
                    generator();
                    this.Commit(this.parent);
                }
                catch
                {
                    this.Commit(null);
                    throw;
                }
                finally
                {
                    this.generating = false;
                }
            }

            internal void GenerateMethod(MethodDefinitionHandle methodDefinitionHandle, Action generator)
            {
                this.ThrowIfNotGenerating();

                if (this.methodsGenerating.TryGetValue(methodDefinitionHandle, out Exception? failure) || this.parent?.methodsGenerating.TryGetValue(methodDefinitionHandle, out failure) is true)
                {
                    if (failure is object)
                    {
                        throw new GenerationFailedException("This member already failed in generation previously.", failure);
                    }

                    return;
                }

                this.methodsGenerating.Add(methodDefinitionHandle, null);
                try
                {
                    generator();
                }
                catch (Exception ex)
                {
                    this.methodsGenerating[methodDefinitionHandle] = ex;
                    throw;
                }
            }

            internal void GenerateSpecialType(string name, Action generator)
            {
                this.ThrowIfNotGenerating();

                if (this.specialTypesGenerating.TryGetValue(name, out Exception? failure) || this.parent?.specialTypesGenerating.TryGetValue(name, out failure) is true)
                {
                    if (failure is object)
                    {
                        throw new GenerationFailedException("This type already failed in generation previously.", failure);
                    }

                    return;
                }

                this.specialTypesGenerating.Add(name, null);
                try
                {
                    generator();
                }
                catch (Exception ex)
                {
                    this.specialTypesGenerating[name] = ex;
                    throw;
                }
            }

            internal void GenerateType(TypeDefinitionHandle typeDefinitionHandle, Action generator)
            {
                this.ThrowIfNotGenerating();

                if (this.typesGenerating.TryGetValue(typeDefinitionHandle, out Exception? failure) || this.parent?.typesGenerating.TryGetValue(typeDefinitionHandle, out failure) is true)
                {
                    if (failure is object)
                    {
                        throw new GenerationFailedException("This type already failed in generation previously.", failure);
                    }

                    return;
                }

                this.typesGenerating.Add(typeDefinitionHandle, null);
                try
                {
                    generator();
                }
                catch (Exception ex)
                {
                    this.typesGenerating[typeDefinitionHandle] = ex;
                    throw;
                }
            }

            internal void GenerateConstant(FieldDefinitionHandle fieldDefinitionHandle, Action generator)
            {
                this.ThrowIfNotGenerating();

                if (this.fieldsToSyntax.ContainsKey(fieldDefinitionHandle) || this.parent?.fieldsToSyntax.ContainsKey(fieldDefinitionHandle) is true)
                {
                    return;
                }

                generator();
            }

            internal bool TryGetSafeHandleForReleaseMethod(string releaseMethod, out TypeSyntax? safeHandleType)
            {
                return this.releaseMethodsWithSafeHandleTypesGenerating.TryGetValue(releaseMethod, out safeHandleType)
                    || this.parent?.releaseMethodsWithSafeHandleTypesGenerating.TryGetValue(releaseMethod, out safeHandleType) is true;
            }

            internal void AddSafeHandleNameForReleaseMethod(string releaseMethod, TypeSyntax? safeHandleType)
            {
                this.ThrowIfNotGenerating();

                this.releaseMethodsWithSafeHandleTypesGenerating.Add(releaseMethod, safeHandleType);
            }

            private static void Commit<TKey, TValue>(Dictionary<TKey, TValue> source, Dictionary<TKey, TValue>? target)
            {
                if (target is object)
                {
                    foreach (var item in source)
                    {
                        target.Add(item.Key, item.Value);
                    }
                }

                source.Clear();
            }

            private static void Commit<T>(List<T> source, List<T>? target)
            {
                if (target is object)
                {
                    target.AddRange(source);
                }

                source.Clear();
            }

            private void Commit(GeneratedCode? parent)
            {
                foreach (var item in this.modulesAndMembers)
                {
                    if (parent is object)
                    {
                        if (!parent.modulesAndMembers.TryGetValue(item.Key, out var list))
                        {
                            parent.modulesAndMembers.Add(item.Key, list = new());
                        }

                        list.AddRange(item.Value);
                    }

                    item.Value.Clear();
                }

                Commit(this.types, parent?.types);
                Commit(this.fieldsToSyntax, parent?.fieldsToSyntax);
                Commit(this.safeHandleTypes, parent?.safeHandleTypes);
                Commit(this.specialTypes, parent?.specialTypes);
                Commit(this.typesGenerating, parent?.typesGenerating);
                Commit(this.methodsGenerating, parent?.methodsGenerating);
                Commit(this.specialTypesGenerating, parent?.specialTypesGenerating);
                Commit(this.releaseMethodsWithSafeHandleTypesGenerating, parent?.releaseMethodsWithSafeHandleTypesGenerating);
                Commit(this.inlineArrayIndexerExtensionsMembers, parent?.inlineArrayIndexerExtensionsMembers);
                Commit(this.comInterfaceFriendlyExtensionsMembers, parent?.comInterfaceFriendlyExtensionsMembers);
            }

            private void ThrowIfNotGenerating()
            {
                if (!this.generating)
                {
                    throw new InvalidOperationException("Generating code must take place within a recognized top-level call.");
                }
            }

            private class Grouping<TKey, TElement> : IGrouping<TKey, TElement>
            {
                private readonly IEnumerable<TElement> values;

                internal Grouping(TKey key, IEnumerable<TElement> values)
                {
                    this.Key = key;
                    this.values = values;
                }

                public TKey Key { get; }

                public IEnumerator<TElement> GetEnumerator() => this.values.GetEnumerator();

                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => this.GetEnumerator();
            }
        }

        private class WhitespaceRewriter : CSharpSyntaxRewriter
        {
            private readonly List<SyntaxTrivia> indentationLevels = new List<SyntaxTrivia> { default };
            private int indentationLevel;

            internal WhitespaceRewriter()
                : base(visitIntoStructuredTrivia: true)
            {
            }

            private SyntaxTrivia IndentTrivia => this.indentationLevels[this.indentationLevel];

            private SyntaxTrivia OuterIndentTrivia => this.indentationLevels[Math.Max(0, this.indentationLevel - 1)];

            public override SyntaxNode? VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
            {
                node = node
                    .WithNamespaceKeyword(node.NamespaceKeyword.WithLeadingTrivia(TriviaList(this.IndentTrivia)))
                    .WithOpenBraceToken(node.OpenBraceToken.WithLeadingTrivia(TriviaList(this.IndentTrivia)))
                    .WithCloseBraceToken(node.CloseBraceToken.WithLeadingTrivia(TriviaList(this.IndentTrivia)));
                using var indent = new Indent(this);
                SyntaxNode? result = base.VisitNamespaceDeclaration(node);
                if (result is NamespaceDeclarationSyntax ns)
                {
                    result = ns.WithMembers(AddSpacingBetweenMembers(ns.Members, ns.Usings.Count > 0));
                }

                return result;
            }

            public override SyntaxNode? VisitStructDeclaration(StructDeclarationSyntax node)
            {
                node = this.WithIndentingTrivia(node)
                    .WithOpenBraceToken(node.OpenBraceToken.WithLeadingTrivia(TriviaList(this.IndentTrivia)))
                    .WithCloseBraceToken(node.CloseBraceToken.WithLeadingTrivia(TriviaList(this.IndentTrivia)));
                using var indent = new Indent(this);
                SyntaxNode? result = base.VisitStructDeclaration(node);
                if (result is StructDeclarationSyntax s)
                {
                    result = s.WithMembers(AddSpacingBetweenMembers(s.Members));
                }

                return result;
            }

            public override SyntaxNode? VisitClassDeclaration(ClassDeclarationSyntax node)
            {
                node = this.WithIndentingTrivia(node)
                    .WithOpenBraceToken(node.OpenBraceToken.WithLeadingTrivia(TriviaList(this.IndentTrivia)))
                    .WithCloseBraceToken(node.CloseBraceToken.WithLeadingTrivia(TriviaList(this.IndentTrivia)));
                using var indent = new Indent(this);
                SyntaxNode? result = base.VisitClassDeclaration(node);
                if (result is ClassDeclarationSyntax c)
                {
                    result = c.WithMembers(AddSpacingBetweenMembers(c.Members));
                }

                return result;
            }

            public override SyntaxNode? VisitEnumDeclaration(EnumDeclarationSyntax node)
            {
                node = this.WithIndentingTrivia(node)
                    .WithOpenBraceToken(node.OpenBraceToken.WithLeadingTrivia(TriviaList(this.IndentTrivia)))
                    .WithCloseBraceToken(node.CloseBraceToken.WithLeadingTrivia(TriviaList(this.IndentTrivia)));
                using var indent = new Indent(this);
                return base.VisitEnumDeclaration(node);
            }

            public override SyntaxNode? VisitUsingDirective(UsingDirectiveSyntax node)
            {
                return base.VisitUsingDirective(node.WithLeadingTrivia(this.IndentTrivia));
            }

            public override SyntaxNode? VisitBlock(BlockSyntax node)
            {
                SyntaxTriviaList leadingTrivia;
                if (node.Parent is FixedStatementSyntax or AccessorDeclarationSyntax or TryStatementSyntax or FinallyClauseSyntax)
                {
                    leadingTrivia = TriviaList(this.IndentTrivia);
                }
                else
                {
                    leadingTrivia = TriviaList(LineFeed).Add(this.IndentTrivia);
                }

                node = node
                    .WithOpenBraceToken(Token(leadingTrivia, SyntaxKind.OpenBraceToken, TriviaList(LineFeed)))
                    .WithCloseBraceToken(Token(TriviaList(this.IndentTrivia), SyntaxKind.CloseBraceToken, TriviaList(LineFeed)));
                using var indent = new Indent(this);
                return base.VisitBlock(node);
            }

            public override SyntaxNode? VisitBaseList(BaseListSyntax node)
            {
                if (node.Parent is EnumDeclarationSyntax)
                {
                    return base.VisitBaseList(node);
                }
                else
                {
                    return base.VisitBaseList(this.WithIndentingTrivia(node));
                }
            }

            public override SyntaxNode? VisitAttributeList(AttributeListSyntax node)
            {
                if (node.Parent is ParameterSyntax)
                {
                    return base.VisitAttributeList(node.WithCloseBracketToken(TokenWithSpace(SyntaxKind.CloseBracketToken)));
                }
                else if (node.Parent is BaseTypeDeclarationSyntax)
                {
                    return base.VisitAttributeList(this.WithOuterIndentingTrivia(node));
                }
                else
                {
                    return base.VisitAttributeList(this.WithIndentingTrivia(node));
                }
            }

            public override SyntaxNode? VisitMethodDeclaration(MethodDeclarationSyntax node) => base.VisitMethodDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitConstructorDeclaration(ConstructorDeclarationSyntax node) => base.VisitConstructorDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitOperatorDeclaration(OperatorDeclarationSyntax node) => base.VisitOperatorDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node) => base.VisitConversionOperatorDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitDelegateDeclaration(DelegateDeclarationSyntax node) => base.VisitDelegateDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitFieldDeclaration(FieldDeclarationSyntax node) => base.VisitFieldDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node) => base.VisitEnumMemberDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitPropertyDeclaration(PropertyDeclarationSyntax node) => base.VisitPropertyDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitIndexerDeclaration(IndexerDeclarationSyntax node) => base.VisitIndexerDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitAccessorList(AccessorListSyntax node)
            {
                node = node
                    .WithOpenBraceToken(Token(TriviaList(this.IndentTrivia), SyntaxKind.OpenBraceToken, TriviaList(LineFeed)))
                    .WithCloseBraceToken(Token(TriviaList(this.IndentTrivia), SyntaxKind.CloseBraceToken, TriviaList(LineFeed)));
                using var indent = new Indent(this);
                return base.VisitAccessorList(node);
            }

            public override SyntaxNode? VisitAccessorDeclaration(AccessorDeclarationSyntax node) => base.VisitAccessorDeclaration(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node) => base.VisitLocalDeclarationStatement(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitExpressionStatement(ExpressionStatementSyntax node) => base.VisitExpressionStatement(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitTryStatement(TryStatementSyntax node) => base.VisitTryStatement(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitFinallyClause(FinallyClauseSyntax node) => base.VisitFinallyClause(this.WithIndentingTrivia(node));

            public override SyntaxNode? VisitIfStatement(IfStatementSyntax node)
            {
                node = this.WithIndentingTrivia(node);
                if (node.Statement is BlockSyntax)
                {
                    return base.VisitIfStatement(node);
                }
                else
                {
                    using var indent = new Indent(this);
                    return base.VisitIfStatement(node);
                }
            }

            public override SyntaxNode? VisitWhileStatement(WhileStatementSyntax node)
            {
                node = this.WithIndentingTrivia(node);
                if (node.Statement is BlockSyntax)
                {
                    return base.VisitWhileStatement(node);
                }
                else
                {
                    using var indent = new Indent(this);
                    return base.VisitWhileStatement(node);
                }
            }

            public override SyntaxNode? VisitElseClause(ElseClauseSyntax node)
            {
                node = this.WithIndentingTrivia(node);
                if (node.Statement is BlockSyntax)
                {
                    return base.VisitElseClause(node);
                }
                else
                {
                    using var indent = new Indent(this);
                    return base.VisitElseClause(node);
                }
            }

            public override SyntaxNode? VisitFixedStatement(FixedStatementSyntax node)
            {
                node = this.WithIndentingTrivia(node);
                if (node.Statement is BlockSyntax)
                {
                    return base.VisitFixedStatement(node);
                }
                else
                {
                    using var indent = new Indent(this);
                    return base.VisitFixedStatement(node);
                }
            }

            public override SyntaxNode? VisitReturnStatement(ReturnStatementSyntax node) => base.VisitReturnStatement(node.WithLeadingTrivia(this.IndentTrivia));

            public override SyntaxToken VisitToken(SyntaxToken token)
            {
                if (token.IsKind(SyntaxKind.CommaToken) && token.Parent is ParameterListSyntax or AttributeArgumentListSyntax or ArgumentListSyntax)
                {
                    return TokenWithSpace(SyntaxKind.CommaToken);
                }

                return base.VisitToken(token);
            }

            public override SyntaxTriviaList VisitList(SyntaxTriviaList list)
            {
#if DEBUG && false // Nodes that contain any annotations at all cause a lot of lock contention that slows us down. Consider removing it all and enforcing (part of it) with this code
                if (list.Any() && list[0].IsEquivalentTo(SyntaxFactory.ElasticMarker))
                {
                    throw new GenerationFailedException("Elastic trivia got by us.");
                }
#endif

                string? indent = null;
                for (int i = list.Count - 1; i >= 0; i--)
                {
                    if (list[i].GetStructure() is DocumentationCommentTriviaSyntax trivia)
                    {
                        indent ??= list[i].Token.Parent is BaseTypeDeclarationSyntax ? this.OuterIndentTrivia.ToString() : this.IndentTrivia.ToString();
                        var comment = new StringBuilder(trivia.Content.ToFullString());
                        comment.Insert(0, indent);
                        comment.Replace("\n", "\n" + indent);
                        comment.Length -= indent.Length; // Remove the extra indent after the last newline.
                        list = list.RemoveAt(i).InsertRange(i, ParseLeadingTrivia(comment.ToString()));
                    }
                }

                return list; // do not recurse into trivia
            }

            private static SyntaxList<MemberDeclarationSyntax> AddSpacingBetweenMembers(SyntaxList<MemberDeclarationSyntax> members, bool insertLineAboveFirstMember = false)
            {
                for (int i = members.Count - 1; i > 0; i--)
                {
                    if (members[i] is
                        ClassDeclarationSyntax or
                        StructDeclarationSyntax or
                        NamespaceDeclarationSyntax or
                        EnumDeclarationSyntax or
                        MethodDeclarationSyntax or
                        IndexerDeclarationSyntax or
                        PropertyDeclarationSyntax)
                    {
                        members = members.Replace(members[i], members[i].WithLeadingTrivia(members[i].GetLeadingTrivia().Insert(0, LineFeed)));
                    }
                }

                if (insertLineAboveFirstMember && members.Count > 0)
                {
                    members = members.Replace(members[0], members[0].WithLeadingTrivia(members[0].GetLeadingTrivia().Insert(0, LineFeed)));
                }

                return members;
            }

            private static TSyntax WithIndentingTrivia<TSyntax>(TSyntax node, SyntaxTrivia indentTrivia)
                where TSyntax : SyntaxNode
            {
                if (node is MemberDeclarationSyntax memberDeclaration)
                {
                    SyntaxToken firstToken = GetFirstToken(memberDeclaration);
                    return node.ReplaceToken(firstToken, firstToken.WithLeadingTrivia(firstToken.HasLeadingTrivia ? firstToken.LeadingTrivia.Add(indentTrivia) : TriviaList(indentTrivia)));
                }

                // Take care to preserve xml doc comments, pragmas, etc.
                return node.WithLeadingTrivia(node.HasLeadingTrivia ? node.GetLeadingTrivia().Add(indentTrivia) : TriviaList(indentTrivia));

                static SyntaxToken GetFirstToken(MemberDeclarationSyntax memberDeclaration)
                {
                    if (!memberDeclaration.AttributeLists.Any())
                    {
                        return memberDeclaration.GetFirstToken();
                    }
                    else if (memberDeclaration.Modifiers.Any())
                    {
                        return memberDeclaration.Modifiers[0];
                    }
                    else
                    {
                        return memberDeclaration.GetFirstToken();
                    }
                }
            }

            private TSyntax WithIndentingTrivia<TSyntax>(TSyntax node)
                where TSyntax : SyntaxNode
            {
                return WithIndentingTrivia(node, this.IndentTrivia);
            }

            private TSyntax WithOuterIndentingTrivia<TSyntax>(TSyntax node)
                where TSyntax : SyntaxNode
            {
                return WithIndentingTrivia(node, this.OuterIndentTrivia);
            }

            private struct Indent : IDisposable
            {
                private readonly WhitespaceRewriter rewriter;

                internal Indent(WhitespaceRewriter rewriter)
                {
                    this.rewriter = rewriter;
                    rewriter.indentationLevel++;
                    for (int i = rewriter.indentationLevels.Count; i <= rewriter.indentationLevel; i++)
                    {
                        rewriter.indentationLevels.Add(SyntaxTrivia(SyntaxKind.WhitespaceTrivia, new string('\t', i)));
                    }
                }

                public void Dispose()
                {
                    this.rewriter.indentationLevel--;
                }
            }
        }
    }
}
