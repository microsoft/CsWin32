// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Microsoft.Windows.CsWin32
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Reflection.Metadata;
    using System.Reflection.PortableExecutable;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Threading;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

    /// <summary>
    /// The core of the source generator.
    /// </summary>
    public class Generator : IDisposable
    {
        internal static readonly Dictionary<string, TypeSyntax> BclInteropStructs = new Dictionary<string, TypeSyntax>(StringComparer.Ordinal)
        {
            { nameof(System.Runtime.InteropServices.ComTypes.FILETIME), ParseTypeName("System.Runtime.InteropServices.ComTypes.FILETIME") },
        };

        internal static readonly Dictionary<string, string> BannedAPIs = new Dictionary<string, string>
        {
            { "GetLastError", "Do not generate GetLastError. Call Marshal.GetLastWin32Error() instead. Learn more from https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.getlastwin32error" },
        };

        private const string SystemRuntimeCompilerServices = "System.Runtime.CompilerServices";
        private const string SystemRuntimeInteropServices = "System.Runtime.InteropServices";
        private const string MetadataTypesNamespace = "Windows.Win32";
        private const string InteropDecorationNamespace = "Windows.Win32.Interop";
        private const string RAIIFreeAttribute = "RAIIFreeAttribute";
        private const string NativeTypeInfoAttribute = "NativeTypeInfoAttribute";
        private const string AutoGeneratedHeader = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

";

        private const string PartialPInvokeContentComment = @"/// <content>
/// Contains extern methods into ""{0}.dll"".
/// </content>
";

        private const string SimpleFileNameAnnotation = "SimpleFileName";
        private const string OriginalDelegateAnnotation = "OriginalDelegate";

        private static readonly TypeSyntax SafeHandleTypeSyntax = IdentifierName("SafeHandle");
        private static readonly IdentifierNameSyntax IntPtrTypeSyntax = IdentifierName(nameof(IntPtr));
        private static readonly TypeSyntax VoidStar = SyntaxFactory.ParseTypeName("void*");

        /// <summary>
        /// This is the preferred capitalizations for modules and class names.
        /// If they are not in this list, the capitalization will come from the metadata assembly.
        /// </summary>
        private static readonly ImmutableHashSet<string> CanonicalCapitalizations = ImmutableHashSet.Create<string>(
            StringComparer.OrdinalIgnoreCase,
            "AdvApi32",
            "AuthZ",
            "BCrypt",
            "Cabinet",
            "CfgMgr32",
            "Chakra",
            "CodeGeneration",
            "CodeGeneration.Debugging",
            "CodeGenerationAttributes",
            "ComCtl32",
            "ComDlg32",
            "Crypt32",
            "CryptNet",
            "D3D11",
            "D3D12",
            "D3DCompiler_47",
            "DbgHelp",
            "DfsCli",
            "DhcpCSvc",
            "DhcpCSvc6",
            "DnsApi",
            "DsParse",
            "DSRole",
            "DwmApi",
            "DXGI",
            "Esent",
            "FltLib",
            "Fusion",
            "Gdi32",
            "Hid",
            "Icu",
            "ImageHlp",
            "InkObjCore",
            "IPHlpApi",
            "Kernel32",
            "LogonCli",
            "Magnification",
            "MFSensorGroup",
            "Mpr",
            "MSCms",
            "MSCorEE",
            "Msi",
            "MswSock",
            "NCrypt",
            "NetApi32",
            "NetUtils",
            "NewDev",
            "NTDll",
            "Ole32",
            "OleAut32",
            "PowrProf",
            "PropSys",
            "Psapi",
            "RpcRT4",
            "SamCli",
            "SchedCli",
            "SetupApi",
            "SHCore",
            "Shell32",
            "ShlwApi",
            "SrvCli",
            "TokenBinding",
            "UrlMon",
            "User32",
            "UserEnv",
            "UxTheme",
            "Version",
            "WebAuthN",
            "WebServices",
            "WebSocket",
            "Win32",
            "Win32MetaGeneration",
            "Windows.Core",
            "Windows.ShellScalingApi",
            "WinHttp",
            "WinMM",
            "WinUsb",
            "WksCli",
            "WLanApi",
            "WldAp32",
            "WtsApi32");

        private static readonly HashSet<string> CSharpKeywords = new HashSet<string>(StringComparer.Ordinal)
        {
            "object",
            "event",
            "override",
            "public",
            "private",
            "protected",
            "internal",
            "virtual",
            "string",
            "base",
            "ref",
            "in",
            "out",
            "decimal",
            "as",
        };

        private static readonly HashSet<string> ObjectMembers = new HashSet<string>(StringComparer.Ordinal)
        {
            "GetType",
        };

        private static readonly string[] WarningsToSuppressInGeneratedCode = new string[]
        {
            "CS1591", // missing docs
            "CS1573", // missing docs for an individual parameter
            "CS0649", // fields never assigned to
            "CS8019", // unused usings
            "CS1570", // XML comment has badly formed XML
        };

        private static readonly AttributeSyntax InAttributeSyntax = Attribute(IdentifierName("In"));
        private static readonly AttributeSyntax OutAttributeSyntax = Attribute(IdentifierName("Out"));
        private static readonly AttributeSyntax OptionalAttributeSyntax = Attribute(IdentifierName("Optional"));
        private static readonly AttributeSyntax FlagsAttributeSyntax = Attribute(IdentifierName("Flags"));
        private static readonly AttributeSyntax FieldOffsetAttributeSyntax = Attribute(IdentifierName("FieldOffset"));

        private readonly Stream metadataStream;
        private readonly PEReader peReader;
        private readonly MetadataReader mr;
        private readonly SignatureTypeProvider signatureTypeProvider;
        private readonly CustomAttributeTypeProvider customAttributeTypeProvider;
        private readonly Dictionary<string, List<MemberDeclarationSyntax>> modulesAndMembers = new Dictionary<string, List<MemberDeclarationSyntax>>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// The structs, enums, delegates and other supporting types for extern methods.
        /// </summary>
        private readonly Dictionary<TypeDefinitionHandle, MemberDeclarationSyntax> types = new Dictionary<TypeDefinitionHandle, MemberDeclarationSyntax>();

        private readonly Dictionary<string, FieldDefinitionHandle> fieldsByName = new Dictionary<string, FieldDefinitionHandle>(StringComparer.Ordinal);

        private readonly Dictionary<FieldDefinitionHandle, MemberDeclarationSyntax> fieldsToSyntax = new Dictionary<FieldDefinitionHandle, MemberDeclarationSyntax>();

        private readonly List<ClassDeclarationSyntax> safeHandleTypes = new List<ClassDeclarationSyntax>();

        /// <summary>
        /// The set of types that are or have been generated so we don't stack overflow for self-referencing types.
        /// </summary>
        private readonly HashSet<TypeDefinitionHandle> typesGenerating = new HashSet<TypeDefinitionHandle>();

        /// <summary>
        /// The set of methods that are or have been generated.
        /// </summary>
        private readonly HashSet<MethodDefinitionHandle> methodsGenerating = new HashSet<MethodDefinitionHandle>();

        private readonly Dictionary<TypeDefinitionHandle, TypeDefinitionHandle> nestedToDeclaringLookup = new Dictionary<TypeDefinitionHandle, TypeDefinitionHandle>();

        private readonly Dictionary<string, MethodDefinitionHandle> methodsByName;

        private readonly Dictionary<string, TypeDefinitionHandle> typesByName;

        private readonly Dictionary<string, TypeSyntax?> releaseMethodsWithSafeHandleTypesGenerating = new Dictionary<string, TypeSyntax?>();

        private readonly GeneratorOptions options;
        private readonly CSharpCompilation? compilation;
        private readonly CSharpParseOptions? parseOptions;

        /// <summary>
        /// Initializes a new instance of the <see cref="Generator"/> class.
        /// </summary>
        /// <param name="metadataLibraryStream">The stream to the winmd metadata to generate APIs from.</param>
        /// <param name="options">Options that influence the result of generation.</param>
        /// <param name="compilation">The compilation that the generated code will be added to.</param>
        /// <param name="parseOptions">The parse options that will be used for the generated code.</param>
        public Generator(Stream metadataLibraryStream, GeneratorOptions? options = null, CSharpCompilation? compilation = null, CSharpParseOptions? parseOptions = null)
        {
            this.options = options ??= new GeneratorOptions();
            this.options.Validate();
            this.compilation = compilation;
            this.parseOptions = parseOptions;

            this.metadataStream = metadataLibraryStream;
            this.peReader = new PEReader(this.metadataStream);
            this.mr = this.peReader.GetMetadataReader();

            this.signatureTypeProvider = new SignatureTypeProvider(this);
            this.customAttributeTypeProvider = new CustomAttributeTypeProvider();

            this.Apis = this.mr.TypeDefinitions.Select(this.mr.GetTypeDefinition).Single(td => this.mr.StringComparer.Equals(td.Name, "Apis") && this.mr.StringComparer.Equals(td.Namespace, MetadataTypesNamespace));
            this.InitializeNestedToDeclaringLookupDictionary();

            this.methodsByName = new Dictionary<string, MethodDefinitionHandle>(StringComparer.Ordinal);
            foreach (MethodDefinitionHandle methodDefHandle in this.Apis.GetMethods())
            {
                string methodName = this.mr.GetString(this.mr.GetMethodDefinition(methodDefHandle).Name);
                if (!this.methodsByName.ContainsKey(methodName))
                {
                    this.methodsByName.Add(methodName, methodDefHandle);
                }
            }

            this.typesByName = new Dictionary<string, TypeDefinitionHandle>(StringComparer.Ordinal);
            foreach (TypeDefinitionHandle typeDefinitionHandle in this.mr.TypeDefinitions)
            {
                TypeDefinition typeDefinition = this.mr.GetTypeDefinition(typeDefinitionHandle);
                string name = this.mr.GetString(typeDefinition.Name);
                if (!this.typesByName.ContainsKey(name))
                {
                    this.typesByName.Add(name, typeDefinitionHandle);
                }
            }

            foreach (FieldDefinitionHandle fieldDefHandle in this.Apis.GetFields())
            {
                FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
                const FieldAttributes expectedFlags = FieldAttributes.Literal | FieldAttributes.Static | FieldAttributes.Public;
                if ((fieldDef.Attributes & expectedFlags) == expectedFlags)
                {
                    string name = this.mr.GetString(fieldDef.Name);
                    this.fieldsByName.Add(name, fieldDefHandle);
                }
            }
        }

        internal TypeDefinition Apis { get; }

        internal MetadataReader Reader => this.mr;

        internal LanguageVersion LanguageVersion => this.parseOptions?.LanguageVersion ?? LanguageVersion.CSharp9;

        private bool WideCharOnly => this.options.WideCharOnly;

        private bool GroupByModule => string.IsNullOrEmpty(this.options.ClassName);

        private string Namespace => this.options.Namespace;

        private string SingleClassName => this.options.ClassName ?? throw new InvalidOperationException("Not in one-class mode.");

        private SyntaxKind Visibility => this.options.Public ? SyntaxKind.PublicKeyword : SyntaxKind.InternalKeyword;

        private IEnumerable<MemberDeclarationSyntax> NamespaceMembers
        {
            get
            {
                IEnumerable<MemberDeclarationSyntax> result = this.GroupByModule
                    ? this.ExternMethodsByModuleClassName.Select(kv =>
                        ClassDeclaration(Identifier(GetClassNameForModule(kv.Key)))
                        .AddModifiers(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword))
                        .AddMembers(kv.ToArray()))
                    : from entry in this.modulesAndMembers
                      select ClassDeclaration(Identifier(this.SingleClassName))
                        .AddModifiers(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword))
                        .AddMembers(entry.Value.ToArray())
                        .WithLeadingTrivia(ParseLeadingTrivia(string.Format(CultureInfo.InvariantCulture, PartialPInvokeContentComment, entry.Key)))
                        .WithAdditionalAnnotations(new SyntaxAnnotation(SimpleFileNameAnnotation, $"{this.SingleClassName}.{entry.Key}"));
                result = result
                    .Concat(this.safeHandleTypes)
                    .Concat(this.types.Values);

                var constantClass = this.CreateConstantDefiningClass();
                if (constantClass.Members.Count > 0)
                {
                    result = result.Concat(new MemberDeclarationSyntax[] { constantClass });
                }

                return result;
            }
        }

        private IEnumerable<IGrouping<string, MemberDeclarationSyntax>> ExternMethodsByModuleClassName =>
            from entry in this.modulesAndMembers
            from method in entry.Value
            group method by GetClassNameForModule(entry.Key) into x
            select x;

        /// <inheritdoc/>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Generates all extern methods, structs, delegates, constants as defined by the source metadata.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAll(CancellationToken cancellationToken)
        {
            this.GenerateAllExternMethods(cancellationToken);

            // Also generate all structs/enum types too, even if not referenced by a method,
            // since some methods use `void*` types and require structs at runtime.
            this.GenerateAllInteropTypes(cancellationToken);

            this.GenerateAllConstants(cancellationToken);
        }

        /// <summary>
        /// Generates code for a given API.
        /// </summary>
        /// <param name="apiNameOrModuleWildcard">The name of the method, struct or constant. Or the name of a module with a ".*" suffix in order to generate all methods and supporting types for the specified module.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns><see langword="true" /> if any matching APIs were found and generated; <see langword="false"/> otherwise.</returns>
        public bool TryGenerate(string apiNameOrModuleWildcard, CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(apiNameOrModuleWildcard))
            {
                throw new ArgumentException("API cannot be null or empty.", nameof(apiNameOrModuleWildcard));
            }

            if (apiNameOrModuleWildcard.EndsWith(".*", StringComparison.Ordinal))
            {
                return this.TryGenerateAllExternMethods(apiNameOrModuleWildcard.Substring(0, apiNameOrModuleWildcard.Length - 2), cancellationToken);
            }
            else
            {
                return
                    this.TryGenerateExternMethod(apiNameOrModuleWildcard) ||
                    this.TryGenerateType(apiNameOrModuleWildcard) ||
                    this.TryGenerateConstant(apiNameOrModuleWildcard);
            }
        }

        /// <summary>
        /// Generates a projection of all extern methods and their supporting types.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAllExternMethods(CancellationToken cancellationToken)
        {
            foreach (MethodDefinitionHandle methodHandle in this.Apis.GetMethods())
            {
                cancellationToken.ThrowIfCancellationRequested();

                this.GenerateExternMethod(methodHandle);
            }
        }

        /// <summary>
        /// Generates a projection of all constants.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAllConstants(CancellationToken cancellationToken)
        {
            foreach (FieldDefinitionHandle fieldDefHandle in this.Apis.GetFields())
            {
                cancellationToken.ThrowIfCancellationRequested();

                this.GenerateConstant(fieldDefHandle);
            }
        }

        /// <summary>
        /// Generates all extern methods exported from a particular module, along with all their supporting types.
        /// </summary>
        /// <param name="moduleName">The name of the module for whose exports extern methods should be generated for.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns><see langword="true"/> if a matching module name was found and extern methods generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateAllExternMethods(string moduleName, CancellationToken cancellationToken)
        {
            bool successful = false;
            foreach (MethodDefinitionHandle methodHandle in this.Apis.GetMethods())
            {
                cancellationToken.ThrowIfCancellationRequested();

                MethodDefinition methodDef = this.mr.GetMethodDefinition(methodHandle);
                ModuleReferenceHandle moduleHandle = methodDef.GetImport().Module;
                if (moduleHandle.IsNil)
                {
                    continue;
                }

                ModuleReference module = this.mr.GetModuleReference(moduleHandle);
                if (this.mr.StringComparer.Equals(module.Name, moduleName, ignoreCase: true))
                {
                    string? bannedReason = null;
                    foreach (var bannedApi in BannedAPIs)
                    {
                        if (this.mr.StringComparer.Equals(methodDef.Name, bannedApi.Key))
                        {
                            // Skip a banned API.
                            bannedReason = bannedApi.Value;
                            continue;
                        }
                    }

                    if (bannedReason is object)
                    {
                        continue;
                    }

                    this.GenerateExternMethod(methodHandle);
                    successful = true;
                }
            }

            return successful;
        }

        /// <summary>
        /// Generate code for the named extern method, if it is recognized.
        /// </summary>
        /// <param name="name">The name of the extern method.</param>
        /// <returns><see langword="true"/> if a match was found and the extern method generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateExternMethod(string name)
        {
            if (BannedAPIs.TryGetValue(name, out string? reason))
            {
                throw new NotSupportedException(reason);
            }

            if (this.methodsByName.TryGetValue(name, out MethodDefinitionHandle handle))
            {
                this.GenerateExternMethod(handle);
                return true;
            }

            bool successful = false;
            if (this.methodsByName.TryGetValue(name + "W", out handle))
            {
                this.GenerateExternMethod(handle);
                successful = true;
            }

            if (this.methodsByName.TryGetValue(name + "A", out handle))
            {
                this.GenerateExternMethod(handle);
                successful = true;
            }

            return successful;
        }

        /// <summary>
        /// Generate code for the named type, if it is recognized.
        /// </summary>
        /// <param name="name">The name of the type.</param>
        /// <returns><see langword="true"/> if a match was found and the type generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateType(string name)
        {
            if (this.typesByName.TryGetValue(name, out TypeDefinitionHandle typeDefHandle))
            {
                this.GenerateInteropType(typeDefHandle);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Generate code for the named constant, if it is recognized.
        /// </summary>
        /// <param name="name">The name of the constant.</param>
        /// <returns><see langword="true"/> if a match was found and the constant generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateConstant(string name)
        {
            if (this.fieldsByName.TryGetValue(name, out FieldDefinitionHandle fieldDefHandle))
            {
                this.GenerateConstant(fieldDefHandle);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Collects the result of code generation.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>All the generated source files, keyed by filename.</returns>
        public IReadOnlyDictionary<string, CompilationUnitSyntax> GetCompilationUnits(CancellationToken cancellationToken)
        {
            var starterNamespace = NamespaceDeclaration(ParseName(this.Namespace));

            const string FilenamePattern = "{0}.cs";
            var results = new Dictionary<string, NamespaceDeclarationSyntax>(StringComparer.OrdinalIgnoreCase);

            if (this.options.EmitSingleFile)
            {
                results.Add(
                    string.Format(CultureInfo.InvariantCulture, FilenamePattern, "NativeMethods"),
                    starterNamespace.AddMembers(this.NamespaceMembers.ToArray()));
            }
            else
            {
                var membersByFile = from member in this.NamespaceMembers
                                    let fileSimpleName = member.HasAnnotations(SimpleFileNameAnnotation)
                                        ? member.GetAnnotations(SimpleFileNameAnnotation).Single().Data
                                        : member switch
                                        {
                                            ClassDeclarationSyntax classDecl => classDecl.Identifier.ValueText,
                                            StructDeclarationSyntax structDecl => structDecl.Identifier.ValueText,
                                            EnumDeclarationSyntax enumDecl => enumDecl.Identifier.ValueText,
                                            DelegateDeclarationSyntax delegateDecl => "Delegates", // group all delegates in one file
                                            _ => throw new NotSupportedException("Unsupported member type: " + member.GetType().Name),
                                        }
                                    group member by fileSimpleName into x
                                    select x;

                foreach (var fileSimpleName in membersByFile)
                {
                    results.Add(
                        string.Format(CultureInfo.InvariantCulture, FilenamePattern, fileSimpleName.Key),
                        starterNamespace.AddMembers(fileSimpleName.ToArray()));
                }
            }

            var normalizedResults = new Dictionary<string, CompilationUnitSyntax>(StringComparer.OrdinalIgnoreCase);
            results.AsParallel().WithCancellation(cancellationToken).ForAll(kv =>
            {
                var compilationUnit = CompilationUnit()
                    .AddMembers(
                        kv.Value.AddUsings(
                            UsingDirective(IdentifierName(nameof(System))),
                            UsingDirective(IdentifierName(nameof(System) + "." + nameof(System.Diagnostics))),
                            UsingDirective(ParseName(SystemRuntimeInteropServices))))
                    .WithLeadingTrivia(ParseLeadingTrivia(AutoGeneratedHeader).AddRange(
                        WarningsToSuppressInGeneratedCode.Select(code =>
                            Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true).WithErrorCodes(SingletonSeparatedList<ExpressionSyntax>(IdentifierName(code)))))))
                    .NormalizeWhitespace();

                lock (normalizedResults)
                {
                    normalizedResults.Add(kv.Key, compilationUnit);
                }
            });

            return normalizedResults;
        }

        internal void GenerateAllInteropTypes(CancellationToken cancellationToken)
        {
            foreach (TypeDefinitionHandle typeDefinitionHandle in this.mr.TypeDefinitions)
            {
                cancellationToken.ThrowIfCancellationRequested();
                TypeDefinition typeDef = this.mr.GetTypeDefinition(typeDefinitionHandle);
                if (typeDef.BaseType.IsNil)
                {
                    continue;
                }

                this.GenerateInteropType(typeDefinitionHandle);
            }
        }

        internal void GenerateExternMethod(MethodDefinitionHandle methodDefinitionHandle)
        {
            if (methodDefinitionHandle.IsNil)
            {
                return;
            }

            if (!this.methodsGenerating.Add(methodDefinitionHandle))
            {
                return;
            }

            MethodDefinition methodDefinition = this.mr.GetMethodDefinition(methodDefinitionHandle);
            MethodImport import = methodDefinition.GetImport();
            if (import.Name.IsNil)
            {
                // Not an exported method.
                return;
            }

            var methodName = this.mr.GetString(methodDefinition.Name);
            try
            {
                if (this.WideCharOnly && IsAnsiFunction(methodName))
                {
                    // Skip Ansi functions.
                    return;
                }

                var moduleName = this.GetNormalizedModuleName(import);

                if (false && !CanonicalCapitalizations.Contains(moduleName))
                {
                    // Skip methods for modules we are not prepared to export.
                    return;
                }

                string? entrypoint = null;
                if (this.TryGetRenamedMethod(methodName, out string? newName))
                {
                    entrypoint = methodName;
                    methodName = newName;
                }

                MethodSignature<TypeSyntax> signature = methodDefinition.DecodeSignature(this.signatureTypeProvider, null);
                CustomAttributeHandleCollection? returnTypeAttributes = this.GetReturnTypeCustomAttributes(methodDefinition);

                TypeSyntax returnType = signature.ReturnType;
                AttributeSyntax? returnTypeAttribute = null;
                if (returnTypeAttributes.HasValue)
                {
                    (returnType, returnTypeAttribute) = this.ReinterpretMethodSignatureType(signature.ReturnType, returnTypeAttributes.Value);
                }

                MethodDeclarationSyntax methodDeclaration = MethodDeclaration(
                    List<AttributeListSyntax>().Add(AttributeList().AddAttributes(DllImport(import, moduleName, entrypoint))),
                    modifiers: TokenList(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ExternKeyword)),
                    returnType,
                    explicitInterfaceSpecifier: null!,
                    SafeIdentifier(methodName),
                    null!,
                    this.CreateParameterList(methodDefinition, signature),
                    List<TypeParameterConstraintClauseSyntax>(),
                    body: null!,
                    Token(SyntaxKind.SemicolonToken));
                if (returnTypeAttribute is object)
                {
                    methodDeclaration = methodDeclaration.AddAttributeLists(
                        AttributeList().WithTarget(AttributeTargetSpecifier(Token(SyntaxKind.ReturnKeyword))).AddAttributes(returnTypeAttribute));
                }

                // Add documentation if we can find it.
                methodDeclaration = AddApiDocumentation(entrypoint ?? methodName, methodDeclaration);

                List<MemberDeclarationSyntax> methodsList = this.GetModuleMemberList(moduleName);
                if (methodDeclaration.ReturnType is PointerTypeSyntax || methodDeclaration.ParameterList.Parameters.Any(p => p.Type is PointerTypeSyntax))
                {
                    methodDeclaration = methodDeclaration.AddModifiers(Token(SyntaxKind.UnsafeKeyword));
                    methodsList.AddRange(this.CreateFriendlyOverloads(methodDefinition, methodDeclaration, this.GroupByModule ? GetClassNameForModule(moduleName) : this.SingleClassName, isStatic: true));
                }

                methodsList.Add(methodDeclaration);

                // If RAIIFree applies, make sure we generate the close handle method.
                if (returnTypeAttributes.HasValue)
                {
                    foreach (CustomAttributeHandle attHandle in returnTypeAttributes)
                    {
                        CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                        if (this.IsAttribute(att, InteropDecorationNamespace, RAIIFreeAttribute))
                        {
                            var args = att.DecodeValue(this.customAttributeTypeProvider);
                            if (args.FixedArguments[0].Value is string freeMethodName)
                            {
                                this.TryGenerateExternMethod(freeMethodName);
                            }

                            break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed while generating extern method: {methodName}", ex);
            }
        }

        internal TypeDefinitionHandle? GenerateInteropType(TypeReferenceHandle typeRefHandle)
        {
            TypeReference typeRef = this.mr.GetTypeReference(typeRefHandle);
            string name = this.mr.GetString(typeRef.Name);
            if (this.typesByName.TryGetValue(name, out TypeDefinitionHandle typeDefHandle))
            {
                this.GenerateInteropType(typeDefHandle);
                return typeDefHandle;
            }
            else
            {
                // System.Guid reaches here, but doesn't need to be generated.
                ////throw new NotSupportedException($"Could not find a type def for: {this.mr.GetString(typeRef.Namespace)}.{name}");
                return null;
            }
        }

        internal void GenerateInteropType(TypeDefinitionHandle typeDefHandle)
        {
            if (this.nestedToDeclaringLookup.TryGetValue(typeDefHandle, out TypeDefinitionHandle nestingParentHandle))
            {
                // We should only generate this type into its parent type.
                this.GenerateInteropType(nestingParentHandle);
                return;
            }

            if (!this.typesGenerating.Add(typeDefHandle))
            {
                return;
            }

            MemberDeclarationSyntax? typeDeclaration = this.CreateInteropType(typeDefHandle);

            if (typeDeclaration is object)
            {
                this.types.Add(typeDefHandle, typeDeclaration);
            }
        }

        internal void GenerateConstant(FieldDefinitionHandle fieldDefHandle)
        {
            if (this.fieldsToSyntax.ContainsKey(fieldDefHandle))
            {
                return;
            }

            this.fieldsToSyntax.Add(fieldDefHandle, this.CreateField(fieldDefHandle));
        }

        /// <summary>
        /// Disposes of managed and unmanaged resources.
        /// </summary>
        /// <param name="disposing"><see langword="true"/> if being disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.peReader.Dispose();
                this.metadataStream.Dispose();
            }
        }

        private static T AddApiDocumentation<T>(string api, T memberDeclaration)
            where T : MemberDeclarationSyntax
        {
            if (Docs.Instance.TryGetApiDocs(api, out var docs))
            {
                var docCommentsBuilder = new StringBuilder();
                if (docs.Description is object)
                {
                    docCommentsBuilder.Append($@"/// <summary>");
                    EmitDoc(docs.Description, docCommentsBuilder, docs, string.Empty);
                    docCommentsBuilder.AppendLine("</summary>");
                }

                if (docs.Parameters is object)
                {
                    if (memberDeclaration is BaseMethodDeclarationSyntax methodDecl)
                    {
                        foreach (var entry in docs.Parameters)
                        {
                            if (!methodDecl.ParameterList.Parameters.Any(p => string.Equals(p.Identifier.ValueText, entry.Key, StringComparison.Ordinal)))
                            {
                                // Skip documentation for parameters that do not actually exist on the method.
                                continue;
                            }

                            docCommentsBuilder.Append($@"/// <param name=""{entry.Key}"">");
                            EmitDoc(entry.Value, docCommentsBuilder, docs, "parameters");
                            docCommentsBuilder.AppendLine("</param>");
                        }
                    }
                }

                if (docs.Fields is object)
                {
                    var fieldsDocBuilder = new StringBuilder();
                    switch (memberDeclaration)
                    {
                        case StructDeclarationSyntax structDeclaration:
                            memberDeclaration = memberDeclaration.ReplaceNodes(
                                structDeclaration.Members.OfType<FieldDeclarationSyntax>(),
                                (_, field) =>
                                {
                                    var variable = field.Declaration.Variables.Single();
                                    if (docs.Fields.TryGetValue(variable.Identifier.ValueText, out string? fieldDoc))
                                    {
                                        fieldsDocBuilder.Append("/// <summary>");
                                        EmitDoc(fieldDoc, fieldsDocBuilder, docs, "members");
                                        fieldsDocBuilder.AppendLine("</summary>");
                                        if (field.Declaration.Type.HasAnnotations(OriginalDelegateAnnotation))
                                        {
                                            fieldsDocBuilder.AppendLine(@$"/// <remarks>See the <see cref=""{field.Declaration.Type.GetAnnotations(OriginalDelegateAnnotation).Single().Data}"" /> delegate for more about this function.</remarks>");
                                        }

                                        field = field.WithLeadingTrivia(ParseLeadingTrivia(fieldsDocBuilder.ToString()));
                                        fieldsDocBuilder.Clear();
                                    }

                                    return field;
                                });
                            break;
                        case EnumDeclarationSyntax enumDeclaration:
                            memberDeclaration = memberDeclaration.ReplaceNodes(
                                enumDeclaration.Members,
                                (_, field) =>
                                {
                                    if (docs.Fields.TryGetValue(field.Identifier.ValueText, out string? fieldDoc))
                                    {
                                        fieldsDocBuilder.Append($@"/// <summary>");
                                        EmitDoc(fieldDoc, fieldsDocBuilder, docs, "members");
                                        fieldsDocBuilder.AppendLine("</summary>");
                                        field = field.WithLeadingTrivia(ParseLeadingTrivia(fieldsDocBuilder.ToString()));
                                        fieldsDocBuilder.Clear();
                                    }

                                    return field;
                                });
                            break;
                    }
                }

                if (docs.ReturnValue is object)
                {
                    docCommentsBuilder.Append("/// <returns>");
                    EmitDoc(docs.ReturnValue, docCommentsBuilder, docs: null, string.Empty);
                    docCommentsBuilder.AppendLine("</returns>");
                }

                docCommentsBuilder.Append($"/// <remarks>");
                if (docs.Remarks is object)
                {
                    EmitDoc(docs.Remarks, docCommentsBuilder, docs, string.Empty);
                }
                else
                {
                    docCommentsBuilder.AppendLine();
                    docCommentsBuilder.AppendLine($@"/// <para><see href=""{docs.HelpLink}"">Learn more about this API from docs.microsoft.com</see>.</para>");
                    docCommentsBuilder.Append("/// ");
                }

                docCommentsBuilder.AppendLine($"</remarks>");

                memberDeclaration = memberDeclaration.WithLeadingTrivia(
                    ParseLeadingTrivia(docCommentsBuilder.ToString()));
            }

            return memberDeclaration;

            static void EmitLine(StringBuilder stringBuilder, string yamlDocSrc)
            {
                stringBuilder.Append(yamlDocSrc.Trim());
            }

            static void EmitDoc(string yamlDocSrc, StringBuilder docCommentsBuilder, Docs.ApiDetails? docs, string docsAnchor)
            {
                if (yamlDocSrc.Contains('\n'))
                {
                    docCommentsBuilder.AppendLine();
                    var docReader = new StringReader(yamlDocSrc);
                    string? paramDocLine;

                    bool inParagraph = false;
                    bool inComment = false;
                    int blankLineCounter = 0;
                    while ((paramDocLine = docReader.ReadLine()) is object)
                    {
                        if (string.IsNullOrWhiteSpace(paramDocLine))
                        {
                            if (++blankLineCounter >= 2 && inParagraph)
                            {
                                docCommentsBuilder.AppendLine("</para>");
                                inParagraph = false;
                                inComment = false;
                            }

                            continue;
                        }
                        else if (blankLineCounter > 0)
                        {
                            blankLineCounter = 0;
                        }
                        else
                        {
                            docCommentsBuilder.Append(' ');
                        }

                        if (inParagraph)
                        {
                            if (docCommentsBuilder.Length > 0 && docCommentsBuilder[docCommentsBuilder.Length - 1] != ' ')
                            {
                                docCommentsBuilder.Append(' ');
                            }
                        }
                        else
                        {
                            docCommentsBuilder.Append("/// <para>");
                            inParagraph = true;
                            inComment = true;
                        }

                        if (!inComment)
                        {
                            docCommentsBuilder.Append("/// ");
                        }

                        if (paramDocLine.IndexOf("<table", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<img", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<ul", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<ol", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("```", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<<", StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            // We don't try to format tables, so truncate at this point.
                            if (inParagraph)
                            {
                                docCommentsBuilder.AppendLine("</para>");
                                inParagraph = false;
                                inComment = false;
                            }

                            docCommentsBuilder.AppendLine($@"/// <para>This doc was truncated.</para>");

                            break; // is this the right way?
                        }

                        EmitLine(docCommentsBuilder, paramDocLine);
                    }

                    if (inParagraph)
                    {
                        if (!inComment)
                        {
                            docCommentsBuilder.Append("/// ");
                        }

                        docCommentsBuilder.AppendLine("</para>");
                        inParagraph = false;
                        inComment = false;
                    }

                    if (docs is object)
                    {
                        docCommentsBuilder.AppendLine($@"/// <para><see href=""{docs.HelpLink}#{docsAnchor}"">Read more on docs.microsoft.com</see>.</para>");
                    }

                    docCommentsBuilder.Append("/// ");
                }
                else
                {
                    EmitLine(docCommentsBuilder, yamlDocSrc);
                }
            }
        }

        private static string GetClassNameForModule(string moduleName) =>
            moduleName.StartsWith("api-", StringComparison.Ordinal) || moduleName.StartsWith("ext-", StringComparison.Ordinal) ? "ApiSets" : moduleName.Replace('-', '_');

        private static AttributeSyntax FieldOffset(int offset) => FieldOffsetAttributeSyntax.AddArgumentListArguments(AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(offset))));

        private static AttributeSyntax StructLayout(TypeAttributes typeAttributes, TypeLayout layout)
        {
            LayoutKind layoutKind = (typeAttributes & TypeAttributes.ExplicitLayout) == TypeAttributes.ExplicitLayout ? LayoutKind.Explicit : LayoutKind.Sequential;
            var structLayoutAttribute = Attribute(IdentifierName("StructLayout")).AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(LayoutKind)),
                    IdentifierName(Enum.GetName(typeof(LayoutKind), layoutKind)!))));

            if (layout.PackingSize > 0)
            {
                structLayoutAttribute = structLayoutAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(layout.PackingSize)))
                        .WithNameEquals(NameEquals(nameof(StructLayoutAttribute.Pack))));
            }

            if (layout.Size > 0)
            {
                structLayoutAttribute = structLayoutAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(layout.Size)))
                        .WithNameEquals(NameEquals(nameof(StructLayoutAttribute.Size))));
            }

            return structLayoutAttribute;
        }

        private static AttributeSyntax GUID(Guid guid)
        {
            return Attribute(IdentifierName("Guid")).AddArgumentListArguments(
                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(guid.ToString().ToUpperInvariant()))));
        }

        private static AttributeSyntax InterfaceType(ComInterfaceType interfaceType)
        {
            return Attribute(IdentifierName("InterfaceType")).AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(ComInterfaceType)),
                    IdentifierName(Enum.GetName(typeof(ComInterfaceType), interfaceType)!))));
        }

        private static AttributeSyntax DllImport(MethodImport import, string moduleName, string? entrypoint)
        {
            var dllImportAttribute = Attribute(IdentifierName("DllImport")).AddArgumentListArguments(
                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(moduleName))),
                AttributeArgument(LiteralExpression(SyntaxKind.TrueLiteralExpression)).WithNameEquals(NameEquals(nameof(DllImportAttribute.ExactSpelling))));

            if (entrypoint is object)
            {
                dllImportAttribute = dllImportAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(entrypoint)))
                        .WithNameEquals(NameEquals(nameof(DllImportAttribute.EntryPoint))));
            }

            if ((import.Attributes & MethodImportAttributes.SetLastError) == MethodImportAttributes.SetLastError)
            {
                dllImportAttribute = dllImportAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.TrueLiteralExpression))
                        .WithNameEquals(NameEquals(nameof(DllImportAttribute.SetLastError))));
            }

            return dllImportAttribute;
        }

        private static AttributeSyntax UnmanagedFunctionPointer(CallingConvention callingConvention)
        {
            return Attribute(IdentifierName(nameof(UnmanagedFunctionPointerAttribute)))
                .AddArgumentListArguments(AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(CallingConvention)),
                    IdentifierName(Enum.GetName(typeof(CallingConvention), callingConvention)!))));
        }

        private static AttributeSyntax MarshalAs(UnmanagedType unmanagedType)
        {
            return Attribute(IdentifierName("MarshalAs"))
                .AddArgumentListArguments(AttributeArgument(
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(nameof(UnmanagedType)),
                        IdentifierName(Enum.GetName(typeof(UnmanagedType), unmanagedType)!))));
        }

        private static AttributeSyntax DebuggerBrowsable(DebuggerBrowsableState state)
        {
            return Attribute(IdentifierName("DebuggerBrowsable"))
                .AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(DebuggerBrowsableState)),
                    IdentifierName(Enum.GetName(typeof(DebuggerBrowsableState), state)!))));
        }

        private static SyntaxToken SafeIdentifier(string name) => Identifier(CSharpKeywords.Contains(name) ? "@" + name : name);

        private static string GetHiddenFieldName(string fieldName) => $"__{fieldName}";

        private static CrefParameterListSyntax ToCref(ParameterListSyntax parameterList) => CrefParameterList().AddParameters(parameterList.Parameters.Select(ToCref).ToArray());

        private static CrefParameterSyntax ToCref(ParameterSyntax parameter)
            => CrefParameter(
                parameter.Modifiers.Any(SyntaxKind.RefKeyword) ? Token(SyntaxKind.RefKeyword) :
                parameter.Modifiers.Any(SyntaxKind.OutKeyword) ? Token(SyntaxKind.OutKeyword) :
                default,
                parameter.Type!);

        private static TypeSyntax MakeSpanOfT(TypeSyntax typeArgument) => GenericName("Span").AddTypeArgumentListArguments(typeArgument);

        private static TypeSyntax MakeReadOnlySpanOfT(TypeSyntax typeArgument) => GenericName("ReadOnlySpan").AddTypeArgumentListArguments(typeArgument);

        private static FunctionPointerUnmanagedCallingConventionSyntax ToUnmanagedCallingConventionSyntax(CallingConvention callingConvention)
        {
            return callingConvention switch
            {
                CallingConvention.StdCall => FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall")),
                CallingConvention.Winapi => FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall")), // Winapi isn't a valid string, and only .NET 5 supports runtime-determined calling conventions like Winapi does.
                _ => throw new NotImplementedException(),
            };
        }

        private static FunctionPointerTypeSyntax FunctionPointer(CallingConvention callingConvention, MethodSignature<TypeSyntax> signature, string delegateName)
            => FunctionPointerType(
                FunctionPointerCallingConvention(Token(SyntaxKind.UnmanagedKeyword), FunctionPointerUnmanagedCallingConventionList(SingletonSeparatedList(ToUnmanagedCallingConventionSyntax(callingConvention)))),
                FunctionPointerParameterList(SeparatedList(signature.ParameterTypes.Select(FunctionPointerParameter)).Add(FunctionPointerParameter(signature.ReturnType))))
               .WithAdditionalAnnotations(new SyntaxAnnotation(OriginalDelegateAnnotation, delegateName));

        private static bool IsVoid(TypeSyntax typeSyntax) => typeSyntax is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.VoidKeyword } };

        private static bool IsWideFunction(string methodName)
        {
            if (methodName.Length > 1 && methodName.EndsWith("W", StringComparison.Ordinal) && char.IsLower(methodName[methodName.Length - 2]))
            {
                // The name looks very much like an Wide-char method.
                // If further confidence is ever needed, we could look at the parameter and return types
                // to see if they have charset-related metadata in their marshaling metadata.
                return true;
            }

            return false;
        }

        private static bool IsAnsiFunction(string methodName)
        {
            if (methodName.Length > 1 && methodName.EndsWith("A", StringComparison.Ordinal) && char.IsLower(methodName[methodName.Length - 2]))
            {
                // The name looks very much like an Ansi method.
                // If further confidence is ever needed, we could look at the parameter and return types
                // to see if they have charset-related metadata in their marshaling metadata.
                return true;
            }

            return false;
        }

        private bool TryGetRenamedMethod(string methodName, [NotNullWhen(true)] out string? newName)
        {
            if (this.WideCharOnly && IsWideFunction(methodName))
            {
                newName = methodName.Substring(0, methodName.Length - 1);
                return !this.methodsByName.ContainsKey(newName);
            }

            newName = null;
            return false;
        }

        private CustomAttributeHandleCollection? GetReturnTypeCustomAttributes(MethodDefinition methodDefinition)
        {
            CustomAttributeHandleCollection? returnTypeAttributes = null;
            foreach (ParameterHandle parameterHandle in methodDefinition.GetParameters())
            {
                var parameter = this.mr.GetParameter(parameterHandle);
                if (parameter.Name.IsNil)
                {
                    returnTypeAttributes = parameter.GetCustomAttributes();
                }

                // What we're looking for would always be the first element in the collection.
                break;
            }

            return returnTypeAttributes;
        }

        private bool IsCompilerGenerated(TypeDefinition typeDef)
        {
            bool isCompilerGenerated = false;
            foreach (CustomAttributeHandle attHandle in typeDef.GetCustomAttributes())
            {
                var att = this.mr.GetCustomAttribute(attHandle);
                if (this.IsAttribute(att, SystemRuntimeCompilerServices, nameof(CompilerGeneratedAttribute)))
                {
                    isCompilerGenerated = true;
                    break;
                }
            }

            return isCompilerGenerated;
        }

        private TypeSyntax? GenerateSafeHandle(string releaseMethod)
        {
            if (this.releaseMethodsWithSafeHandleTypesGenerating.TryGetValue(releaseMethod, out TypeSyntax? safeHandleType))
            {
                return safeHandleType;
            }

            MethodDefinitionHandle releaseMethodHandle = this.methodsByName[releaseMethod];
            MethodDefinition releaseMethodDef = this.mr.GetMethodDefinition(releaseMethodHandle);
            string releaseMethodModule = this.GetNormalizedModuleName(releaseMethodDef.GetImport());
            var releaseMethodSignature = releaseMethodDef.DecodeSignature(this.signatureTypeProvider, null);
            TypeSyntax releaseMethodReturnType = this.GetReturnTypeCustomAttributes(releaseMethodDef) is { } atts
                ? this.ReinterpretMethodSignatureType(releaseMethodSignature.ReturnType, atts).Type
                : releaseMethodSignature.ReturnType;

            // If the release method takes more than one parameter, we can't generate a SafeHandle for it.
            if (releaseMethodSignature.RequiredParameterCount != 1)
            {
                return null;
            }

            // TODO: Reuse existing SafeHandle's defined in .NET where possible to facilitate interop with APIs that take them.
            string safeHandleClassName = $"{releaseMethod}SafeHandle";
            this.TryGetRenamedMethod(releaseMethod, out string? renamedReleaseMethod);

            var members = new List<MemberDeclarationSyntax>();

            MemberAccessExpressionSyntax thisHandle = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("handle"));
            ExpressionSyntax intptrZero = DefaultExpression(IntPtrTypeSyntax);
            ExpressionSyntax intptrMinusOne = ObjectCreationExpression(IntPtrTypeSyntax).AddArgumentListArguments(Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(-1))));

            // private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            const string invalidValueFieldName = "INVALID_HANDLE_VALUE";
            members.Add(FieldDeclaration(VariableDeclaration(IntPtrTypeSyntax).AddVariables(
                VariableDeclarator(invalidValueFieldName).WithInitializer(EqualsValueClause(intptrMinusOne))))
                .AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ReadOnlyKeyword)));

            // public SafeHandle() : base(INVALID_HANDLE_VALUE, true)
            members.Add(ConstructorDeclaration(safeHandleClassName)
                .AddModifiers(Token(this.Visibility))
                .WithInitializer(ConstructorInitializer(SyntaxKind.BaseConstructorInitializer, ArgumentList().AddArguments(
                    Argument(IdentifierName(invalidValueFieldName)),
                    Argument(LiteralExpression(SyntaxKind.TrueLiteralExpression)))))
                .WithBody(Block()));

            // public SafeHandle(IntPtr preexistingHandle, bool ownsHandle = true) : base(INVALID_HANDLE_VALUE, ownsHandle) { this.SetHandle(preexistingHandle); }
            const string preexistingHandleName = "preexistingHandle";
            const string ownsHandleName = "ownsHandle";
            members.Add(ConstructorDeclaration(safeHandleClassName)
                .AddModifiers(Token(this.Visibility))
                .AddParameterListParameters(
                    Parameter(Identifier(preexistingHandleName)).WithType(IntPtrTypeSyntax),
                    Parameter(Identifier(ownsHandleName)).WithType(PredefinedType(Token(SyntaxKind.BoolKeyword)))
                        .WithDefault(EqualsValueClause(LiteralExpression(SyntaxKind.TrueLiteralExpression))))
                .WithInitializer(ConstructorInitializer(SyntaxKind.BaseConstructorInitializer, ArgumentList().AddArguments(
                    Argument(IdentifierName(invalidValueFieldName)),
                    Argument(IdentifierName(ownsHandleName)))))
                .WithBody(Block().AddStatements(
                    ExpressionStatement(InvocationExpression(MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        ThisExpression(),
                        IdentifierName("SetHandle"))).AddArgumentListArguments(
                        Argument(IdentifierName(preexistingHandleName)))))));

            // public override bool IsInvalid => this.handle == default || this.Handle == INVALID_HANDLE_VALUE;
            members.Add(PropertyDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword)), nameof(SafeHandle.IsInvalid))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(
                    BinaryExpression(
                        SyntaxKind.LogicalOrExpression,
                        BinaryExpression(SyntaxKind.EqualsExpression, thisHandle, intptrZero),
                        BinaryExpression(SyntaxKind.EqualsExpression, thisHandle, IdentifierName(invalidValueFieldName)))))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            // protected override bool ReleaseHandle() => ReleaseMethod(this.handle);
            // Special case release functions based on their return type as follows: (https://github.com/microsoft/win32metadata/issues/25)
            //  * bool => true is success
            //  * int => zero is success
            //  * uint => zero is success
            //  * byte => non-zero is success
            ExpressionSyntax releaseInvocation = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(this.GroupByModule ? releaseMethodModule : this.SingleClassName),
                    IdentifierName(renamedReleaseMethod ?? releaseMethod)),
                ArgumentList().AddArguments(Argument(thisHandle)));
            BlockSyntax? releaseBlock = null;
            if (!(releaseMethodReturnType is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.BoolKeyword } }))
            {
                SyntaxKind returnType = ((PredefinedTypeSyntax)releaseMethodReturnType).Keyword.Kind();
                if (returnType == SyntaxKind.IntKeyword)
                {
                    releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                }
                else
                if (returnType == SyntaxKind.UIntKeyword)
                {
                    releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                }
                else if (returnType == SyntaxKind.ByteKeyword)
                {
                    releaseInvocation = BinaryExpression(SyntaxKind.NotEqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                }
                else if (returnType == SyntaxKind.VoidKeyword)
                {
                    releaseBlock = Block(
                        ExpressionStatement(releaseInvocation),
                        ReturnStatement(LiteralExpression(SyntaxKind.TrueLiteralExpression)));
                }
                else
                {
                    throw new NotSupportedException($"Return type {returnType} on release method {releaseMethod} not supported.");
                }
            }

            MethodDeclarationSyntax releaseHandleDeclaration = MethodDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword)), "ReleaseHandle")
                .AddModifiers(Token(SyntaxKind.ProtectedKeyword), Token(SyntaxKind.OverrideKeyword));
            releaseHandleDeclaration = releaseBlock is null
                ? releaseHandleDeclaration
                     .WithExpressionBody(ArrowExpressionClause(releaseInvocation))
                     .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                : releaseHandleDeclaration
                    .WithBody(releaseBlock);
            members.Add(releaseHandleDeclaration);

            ClassDeclarationSyntax safeHandleDeclaration = ClassDeclaration(safeHandleClassName)
                .AddModifiers(Token(this.Visibility))
                .AddBaseListTypes(SimpleBaseType(SafeHandleTypeSyntax))
                .AddMembers(members.ToArray())
                .WithLeadingTrivia(ParseLeadingTrivia($@"/// <summary>
        /// Represents a Win32 handle that can be closed with <see cref=""{(this.GroupByModule ? releaseMethodModule : this.SingleClassName)}.{renamedReleaseMethod ?? releaseMethod}""/>.
        /// </summary>
"));

            this.safeHandleTypes.Add(safeHandleDeclaration);
            if (this.GroupByModule)
            {
                this.GetModuleMemberList(releaseMethodModule).Add(safeHandleDeclaration);
            }

            var safeHandleTypeIdentifier = IdentifierName(safeHandleDeclaration.Identifier);
            safeHandleType = this.GroupByModule
                ? QualifiedName(IdentifierName(releaseMethodModule), safeHandleTypeIdentifier)
                : safeHandleTypeIdentifier;

            this.releaseMethodsWithSafeHandleTypesGenerating.Add(releaseMethod, safeHandleType);
            return safeHandleType;
        }

        private MemberDeclarationSyntax? CreateInteropType(TypeDefinitionHandle typeDefHandle)
        {
            TypeDefinition typeDef = this.mr.GetTypeDefinition(typeDefHandle);
            if (this.IsCompilerGenerated(typeDef))
            {
                return null;
            }

            // Skip if the compilation already defines this type.
            string name = this.mr.GetString(typeDef.Name);
            string ns = this.mr.GetString(typeDef.Namespace);
            string fullyQualifiedName = this.Namespace + "." + name;
            if (this.compilation?.GetTypeByMetadataName(fullyQualifiedName) is object)
            {
                return null;
            }

            try
            {
                StringHandle baseTypeName, baseTypeNamespace;
                if (typeDef.BaseType.IsNil)
                {
                    baseTypeName = default;
                    baseTypeNamespace = default;
                }
                else
                {
                    switch (typeDef.BaseType.Kind)
                    {
                        case HandleKind.TypeReference:
                            TypeReference baseTypeRef = this.mr.GetTypeReference((TypeReferenceHandle)typeDef.BaseType);
                            baseTypeName = baseTypeRef.Name;
                            baseTypeNamespace = baseTypeRef.Namespace;
                            break;
                        case HandleKind.TypeDefinition:
                            TypeDefinition baseTypeDef = this.mr.GetTypeDefinition((TypeDefinitionHandle)typeDef.BaseType);
                            baseTypeName = baseTypeDef.Name;
                            baseTypeNamespace = baseTypeDef.Namespace;
                            break;
                        default:
                            throw new NotSupportedException("Unsupported base type handle: " + typeDef.BaseType.Kind);
                    }
                }

                MemberDeclarationSyntax? typeDeclaration;

                if ((typeDef.Attributes & TypeAttributes.Interface) == TypeAttributes.Interface)
                {
                    typeDeclaration = this.CreateInterface(typeDef);
                }
                else if (this.mr.StringComparer.Equals(baseTypeName, nameof(ValueType)) && this.mr.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    StructDeclarationSyntax structDeclaration = this.CreateInteropStruct(typeDef);

                    // Proactively generate all nested types as well.
                    foreach (TypeDefinitionHandle nestedHandle in typeDef.GetNestedTypes())
                    {
                        if (this.CreateInteropType(nestedHandle) is { } nestedType)
                        {
                            structDeclaration = structDeclaration.AddMembers(nestedType);
                        }
                    }

                    typeDeclaration = structDeclaration;
                }
                else if (this.mr.StringComparer.Equals(baseTypeName, nameof(Enum)) && this.mr.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    // Consider reusing .NET types like FILE_SHARE_FLAGS -> System.IO.FileShare
                    typeDeclaration = this.CreateInteropEnum(typeDef);
                }
                else if (this.mr.StringComparer.Equals(baseTypeName, nameof(MulticastDelegate)) && this.mr.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    typeDeclaration = this.CreateInteropDelegate(typeDef);
                }
                else
                {
                    // not yet supported.
                    return null;
                }

                return typeDeclaration;
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to generate " + this.mr.GetString(typeDef.Name), ex);
            }
        }

        private FieldDeclarationSyntax CreateField(FieldDefinitionHandle fieldDefHandle)
        {
            var fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
            string name = this.mr.GetString(fieldDef.Name);
            TypeSyntax fieldType = fieldDef.DecodeSignature(this.signatureTypeProvider, null);
            Constant constant = this.mr.GetConstant(fieldDef.GetDefaultValue());
            return FieldDeclaration(VariableDeclaration(fieldType).AddVariables(
                VariableDeclarator(name).WithInitializer(EqualsValueClause(this.ToExpressionSyntax(constant)))))
                .WithModifiers(TokenList(Token(this.Visibility), Token(SyntaxKind.ConstKeyword)));
        }

        private ClassDeclarationSyntax CreateConstantDefiningClass()
        {
            return ClassDeclaration("Constants")
                .AddMembers(this.fieldsToSyntax.Values.ToArray())
                .WithModifiers(TokenList(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword)));
        }

        /// <summary>
        /// Generates a type to represent a COM interface.
        /// </summary>
        /// <param name="typeDef">The type definition of the interface.</param>
        /// <returns>The type declaration.</returns>
        /// <remarks>
        /// COM interfaces are represented as structs in order to maintain the "unmanaged type" trait
        /// so that all structs are blittable.
        /// </remarks>
        private TypeDeclarationSyntax? CreateInterface(TypeDefinition typeDef)
        {
            IdentifierNameSyntax ifaceName = IdentifierName(this.mr.GetString(typeDef.Name));

            Stack<TypeDefinitionHandle> baseTypes = new Stack<TypeDefinitionHandle>();
            InterfaceImplementationHandle baseTypeHandle = typeDef.GetInterfaceImplementations().SingleOrDefault();
            while (!baseTypeHandle.IsNil)
            {
                InterfaceImplementation baseTypeImpl = this.mr.GetInterfaceImplementation(baseTypeHandle);
                TypeReference baseTypeRef = this.mr.GetTypeReference((TypeReferenceHandle)baseTypeImpl.Interface);
                string baseTypeName = this.mr.GetString(baseTypeRef.Name);
                TypeDefinitionHandle typeDefHandle = this.typesByName[baseTypeName];
                baseTypes.Push(typeDefHandle);
                TypeDefinition baseType = this.mr.GetTypeDefinition(typeDefHandle);
                baseTypeHandle = baseType.GetInterfaceImplementations().SingleOrDefault();
            }

            Guid guid = Guid.Empty;
            foreach (CustomAttributeHandle attHandle in typeDef.GetCustomAttributes())
            {
                var att = this.mr.GetCustomAttribute(attHandle);
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(GuidAttribute)))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    guid = Guid.Parse((string)args.FixedArguments[0].Value!);
                }
            }

            IdentifierNameSyntax vtblFieldName = IdentifierName("lpVtbl");
            var members = new List<MemberDeclarationSyntax>();
            var vtblMembers = new List<MemberDeclarationSyntax>();

            // It is imperative that we generate methods for all base interfaces as well, ahead of any implemented by *this* interface.
            var allMethods = new List<MethodDefinitionHandle>();
            while (baseTypes.Count > 0)
            {
                TypeDefinition baseType = this.mr.GetTypeDefinition(baseTypes.Pop());
                allMethods.AddRange(baseType.GetMethods());
            }

            allMethods.AddRange(typeDef.GetMethods());
            int methodCounter = 0;
            foreach (MethodDefinitionHandle methodDefHandle in allMethods)
            {
                methodCounter++;
                var methodDefinition = this.mr.GetMethodDefinition(methodDefHandle);
                string methodName = this.mr.GetString(methodDefinition.Name);
                IdentifierNameSyntax innerMethodName = IdentifierName($"{methodName}_{methodCounter}");

                MethodSignature<TypeSyntax> signature = methodDefinition.DecodeSignature(this.signatureTypeProvider, null);
                CustomAttributeHandleCollection? returnTypeAttributes = this.GetReturnTypeCustomAttributes(methodDefinition);

                TypeSyntax returnType = signature.ReturnType;
                AttributeSyntax? returnTypeAttribute = null;
                if (returnTypeAttributes.HasValue)
                {
                    (returnType, returnTypeAttribute) = this.ReinterpretMethodSignatureType(signature.ReturnType, returnTypeAttributes.Value);
                }

                ParameterListSyntax parameterList = this.CreateParameterList(methodDefinition, signature);
                FunctionPointerParameterListSyntax funcPtrParameters = FunctionPointerParameterList()
                    .AddParameters(FunctionPointerParameter(PointerType(ifaceName)))
                    .AddParameters(parameterList.Parameters.Select(p => FunctionPointerParameter(p.Type!).WithModifiers(p.Modifiers)).ToArray())
                    .AddParameters(FunctionPointerParameter(returnType));

                FieldDeclarationSyntax vtblFunctionPtr = FieldDeclaration(
                    VariableDeclaration(
                        FunctionPointerType().WithCallingConvention(FunctionPointerCallingConvention(Token(SyntaxKind.UnmanagedKeyword))
                            .WithUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionList(
                                SingletonSeparatedList(FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall"))))))
                        .WithParameterList(funcPtrParameters))
                    .WithVariables(SingletonSeparatedList(VariableDeclarator(innerMethodName.Identifier))))
                    .WithModifiers(TokenList(Token(SyntaxKind.InternalKeyword)));
                vtblMembers.Add(vtblFunctionPtr);

                IdentifierNameSyntax pThisLocal = IdentifierName("pThis");
                InvocationExpressionSyntax vtblInvocation = InvocationExpression(MemberAccessExpression(SyntaxKind.PointerMemberAccessExpression, vtblFieldName, innerMethodName))
                    .AddArgumentListArguments(Argument(pThisLocal))
                    .AddArgumentListArguments(parameterList.Parameters.Select(p => Argument(IdentifierName(p.Identifier.ValueText)).WithRefKindKeyword(p.Modifiers.Count > 0 ? p.Modifiers[0] : default)).ToArray());
                StatementSyntax vtblInvocationStatement = IsVoid(returnType)
                    ? ExpressionStatement(vtblInvocation)
                    : ReturnStatement(vtblInvocation);
                var body = Block().AddStatements(
                    FixedStatement(
                        VariableDeclaration(PointerType(ifaceName)).AddVariables(
                            VariableDeclarator(pThisLocal.Identifier).WithInitializer(EqualsValueClause(PrefixUnaryExpression(SyntaxKind.AddressOfExpression, ThisExpression())))),
                        vtblInvocationStatement));

                MethodDeclarationSyntax methodDeclaration = MethodDeclaration(
                    List<AttributeListSyntax>(),
                    modifiers: TokenList(Token(this.Visibility)),
                    returnType,
                    explicitInterfaceSpecifier: null!,
                    SafeIdentifier(methodName),
                    null!,
                    parameterList,
                    List<TypeParameterConstraintClauseSyntax>(),
                    body: body,
                    semicolonToken: default);
                if (returnTypeAttribute is object)
                {
                    methodDeclaration = methodDeclaration.AddAttributeLists(
                        AttributeList().WithTarget(AttributeTargetSpecifier(Token(SyntaxKind.ReturnKeyword))).AddAttributes(returnTypeAttribute));
                }

                if (methodName == nameof(object.GetType) && parameterList.Parameters.Count == 0)
                {
                    methodDeclaration = methodDeclaration.AddModifiers(Token(SyntaxKind.NewKeyword));
                }

                // Add documentation if we can find it.
                methodDeclaration = AddApiDocumentation($"{ifaceName}.{methodName}", methodDeclaration);

                if (methodDeclaration.ReturnType is PointerTypeSyntax || methodDeclaration.ParameterList.Parameters.Any(p => p.Type is PointerTypeSyntax))
                {
                    methodDeclaration = methodDeclaration.AddModifiers(Token(SyntaxKind.UnsafeKeyword));
                    members.AddRange(this.CreateFriendlyOverloads(methodDefinition, methodDeclaration, ifaceName.Identifier.ValueText, isStatic: false));
                }

                members.Add(methodDeclaration);
            }

            var vtblStruct = StructDeclaration("Vtbl")
                .AddMembers(vtblMembers.ToArray())
                .AddModifiers(Token(SyntaxKind.PrivateKeyword));
            members.Add(vtblStruct);

            // private Vtbl* lpVtbl;
            members.Add(FieldDeclaration(VariableDeclaration(PointerType(IdentifierName(vtblStruct.Identifier))).AddVariables(VariableDeclarator(vtblFieldName.Identifier))).AddModifiers(Token(SyntaxKind.PrivateKeyword)));

            var iface = StructDeclaration(ifaceName.Identifier)
                .AddMembers(members.ToArray())
                .AddModifiers(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword));

            if (guid != Guid.Empty)
            {
                iface = iface.AddAttributeLists().AddAttributeLists(AttributeList().AddAttributes(GUID(guid)));
            }

            return iface;
        }

        private void InitializeNestedToDeclaringLookupDictionary()
        {
            foreach (TypeDefinitionHandle typeDefHandle in this.mr.TypeDefinitions)
            {
                TypeDefinition typeDefinition = this.mr.GetTypeDefinition(typeDefHandle);
                if (!typeDefinition.IsNested)
                {
                    AddNestedTypesOf(typeDefHandle);
                }
            }

            void AddNestedTypesOf(TypeDefinitionHandle parentHandle)
            {
                TypeDefinition typeDefinition = this.mr.GetTypeDefinition(parentHandle);
                foreach (TypeDefinitionHandle nestedHandle in typeDefinition.GetNestedTypes())
                {
                    if (!nestedHandle.IsNil)
                    {
                        this.nestedToDeclaringLookup.Add(nestedHandle, parentHandle);
                        AddNestedTypesOf(nestedHandle);
                    }
                }
            }
        }

        private DelegateDeclarationSyntax CreateInteropDelegate(TypeDefinition typeDef)
        {
            string name = this.mr.GetString(typeDef.Name);

            CallingConvention? callingConvention = null;
            foreach (CustomAttributeHandle handle in typeDef.GetCustomAttributes())
            {
                var att = this.mr.GetCustomAttribute(handle);
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(UnmanagedFunctionPointerAttribute)))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    callingConvention = (CallingConvention)(int)args.FixedArguments[0].Value!;
                }
            }

            this.GetSignatureForDelegate(typeDef, out MethodDefinition invokeMethodDef, out MethodSignature<TypeSyntax> signature);

            DelegateDeclarationSyntax result = DelegateDeclaration(signature.ReturnType, name)
                .WithParameterList(this.CreateParameterList(invokeMethodDef, signature))
                .AddModifiers(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword));

            if (callingConvention.HasValue)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(UnmanagedFunctionPointer(callingConvention.Value)));
            }

            return result;
        }

        private void GetSignatureForDelegate(TypeDefinition typeDef, out MethodDefinition invokeMethodDef, out MethodSignature<TypeSyntax> signature)
        {
            invokeMethodDef = typeDef.GetMethods().Select(this.mr.GetMethodDefinition).Single(def => this.mr.StringComparer.Equals(def.Name, "Invoke"));
            signature = invokeMethodDef.DecodeSignature(this.signatureTypeProvider, null);
        }

        private StructDeclarationSyntax CreateInteropStruct(TypeDefinition typeDef)
        {
            string name = this.mr.GetString(typeDef.Name);

            var members = new List<MemberDeclarationSyntax>();
            foreach (FieldDefinitionHandle fieldDefHandle in typeDef.GetFields())
            {
                FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
                string fieldName = this.mr.GetString(fieldDef.Name);

                CustomAttribute? fixedBufferAttribute = null;
                foreach (CustomAttributeHandle attHandle in fieldDef.GetCustomAttributes())
                {
                    CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                    if (this.IsAttribute(att, SystemRuntimeCompilerServices, nameof(FixedBufferAttribute)))
                    {
                        fixedBufferAttribute = att;
                        break;
                    }
                }

                FieldDeclarationSyntax field;
                VariableDeclaratorSyntax fieldDeclarator = VariableDeclarator(SafeIdentifier(fieldName));
                if (fixedBufferAttribute.HasValue)
                {
                    CustomAttributeValue<TypeSyntax> attributeArgs = fixedBufferAttribute.Value.DecodeValue(this.customAttributeTypeProvider);
                    TypeSyntax fieldType = (TypeSyntax)attributeArgs.FixedArguments[0].Value!;
                    ExpressionSyntax size = LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal((int)attributeArgs.FixedArguments[1].Value!));
                    field = FieldDeclaration(
                        VariableDeclaration(fieldType))
                        .AddDeclarationVariables(
                            fieldDeclarator
                                .WithArgumentList(BracketedArgumentList(SingletonSeparatedList(Argument(size)))))
                        .AddModifiers(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword), Token(SyntaxKind.FixedKeyword));
                }
                else
                {
                    var fieldInfo = this.ReinterpretFieldType(fieldDeclarator.Identifier.ValueText, fieldDef.DecodeSignature(this.signatureTypeProvider, null), fieldDef.GetCustomAttributes());
                    if (fieldInfo.AdditionalMembers.Count > 0)
                    {
                        fieldDeclarator = fieldDeclarator.WithIdentifier(Identifier(GetHiddenFieldName(fieldDeclarator.Identifier.ValueText)));

                        members.AddRange(fieldInfo.AdditionalMembers);
                    }

                    field = FieldDeclaration(VariableDeclaration(fieldInfo.FieldType).AddVariables(fieldDeclarator))
                        .AddModifiers(Token(fieldInfo.AdditionalMembers.Count > 0 ? SyntaxKind.PrivateKeyword : this.Visibility));

                    if (fieldInfo.AdditionalMembers.Count > 0)
                    {
                        field = field.AddAttributeLists(AttributeList().AddAttributes(DebuggerBrowsable(DebuggerBrowsableState.Never)));
                    }

                    if (fieldInfo.FieldType is PointerTypeSyntax || fieldInfo.FieldType is FunctionPointerTypeSyntax)
                    {
                        field = field.AddModifiers(Token(SyntaxKind.UnsafeKeyword));
                    }

                    if (ObjectMembers.Contains(fieldName))
                    {
                        field = field.AddModifiers(Token(SyntaxKind.NewKeyword));
                    }
                }

                int offset = fieldDef.GetOffset();
                if (offset >= 0)
                {
                    field = field.AddAttributeLists(AttributeList().AddAttributes(FieldOffset(offset)));
                }

                members.Add(field);
            }

            StructDeclarationSyntax result = StructDeclaration(name)
                .AddMembers(members.ToArray())
                .WithModifiers(TokenList(Token(this.Visibility)));

            TypeLayout layout = typeDef.GetLayout();
            if (!layout.IsDefault || (typeDef.Attributes & TypeAttributes.ExplicitLayout) == TypeAttributes.ExplicitLayout)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(StructLayout(typeDef.Attributes, layout)));
            }

            Guid guid = Guid.Empty;
            foreach (CustomAttributeHandle attHandle in typeDef.GetCustomAttributes())
            {
                CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(GuidAttribute)))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    guid = Guid.Parse((string)args.FixedArguments[0].Value!);
                }
            }

            if (guid != Guid.Empty)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(GUID(guid)));
            }

            result = AddApiDocumentation(name, result);

            return result;
        }

        private EnumDeclarationSyntax CreateInteropEnum(TypeDefinition typeDef)
        {
            bool flagsEnum = false;
            foreach (CustomAttributeHandle attributeHandle in typeDef.GetCustomAttributes())
            {
                CustomAttribute attribute = this.mr.GetCustomAttribute(attributeHandle);
                if (this.IsAttribute(attribute, nameof(System), "FlagsAttribute"))
                {
                    flagsEnum = true;
                    break;
                }
            }

            var enumValues = new List<SyntaxNodeOrToken>();
            TypeSyntax? enumBaseType = null;
            foreach (FieldDefinitionHandle fieldDefHandle in typeDef.GetFields())
            {
                FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
                string enumValueName = this.mr.GetString(fieldDef.Name);
                ConstantHandle valueHandle = fieldDef.GetDefaultValue();
                if (valueHandle.IsNil)
                {
                    enumBaseType = fieldDef.DecodeSignature(this.signatureTypeProvider, null);
                    continue;
                }

                Constant value = this.mr.GetConstant(valueHandle);
                ExpressionSyntax enumValue = flagsEnum ? this.ToHexExpressionSyntax(value) : this.ToExpressionSyntax(value);
                EnumMemberDeclarationSyntax enumMember = EnumMemberDeclaration(SafeIdentifier(enumValueName))
                    .WithEqualsValue(EqualsValueClause(enumValue));
                enumValues.Add(enumMember);
                enumValues.Add(Token(SyntaxKind.CommaToken));
            }

            if (enumBaseType is null)
            {
                throw new NotSupportedException("Unknown enum type.");
            }

            var name = this.mr.GetString(typeDef.Name);
            EnumDeclarationSyntax result = EnumDeclaration(name)
                .WithMembers(SeparatedList<EnumMemberDeclarationSyntax>(enumValues.ToArray()))
                .WithModifiers(TokenList(Token(this.Visibility)));

            if (!(enumBaseType is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.IntKeyword } }))
            {
                result = result.AddBaseListTypes(SimpleBaseType(enumBaseType));
            }

            if (flagsEnum)
            {
                result = result.AddAttributeLists(
                    AttributeList().AddAttributes(FlagsAttributeSyntax));
            }

            result = AddApiDocumentation(name, result);

            return result;
        }

        private IEnumerable<MethodDeclarationSyntax> CreateFriendlyOverloads(MethodDefinition methodDefinition, MethodDeclarationSyntax externMethodDeclaration, string declaringTypeName, bool isStatic)
        {
            static ParameterSyntax StripAttributes(ParameterSyntax parameter) => parameter.WithAttributeLists(List<AttributeListSyntax>());
            bool IsInterface(string name) => this.typesByName.TryGetValue(name, out TypeDefinitionHandle tdh) && (this.mr.GetTypeDefinition(tdh).Attributes & TypeAttributes.Interface) == TypeAttributes.Interface;
            static ExpressionSyntax GetSpanLength(ExpressionSyntax span) => MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, span, IdentifierName(nameof(Span<int>.Length)));

            var parameters = externMethodDeclaration.ParameterList.Parameters.Select(StripAttributes).ToList();
            var lengthParamUsedBy = new Dictionary<int, int>();
            var arguments = externMethodDeclaration.ParameterList.Parameters.Select(p => Argument(IdentifierName(p.Identifier.Text))).ToList();
            var fixedBlocks = new List<VariableDeclarationSyntax>();
            var leadingStatements = new List<StatementSyntax>();
            bool signatureChanged = false;
            foreach (ParameterHandle paramHandle in methodDefinition.GetParameters())
            {
                var param = this.mr.GetParameter(paramHandle);
                if (param.SequenceNumber == 0)
                {
                    continue;
                }

                // TODO:
                // * Review double/triple pointer scenarios.
                //   * Consider CredEnumerateA, which is a "pointer to an array of pointers" (3-asterisks!). How does FriendlyAttribute improve this, if at all? The memory must be freed through another p/invoke.
                if (parameters[param.SequenceNumber - 1].Type is PointerTypeSyntax ptrType
                    && !IsVoid(ptrType.ElementType)
                    && !(ptrType.ElementType is IdentifierNameSyntax id && IsInterface(id.Identifier.ValueText)))
                {
                    bool isPointerToPointer = ptrType.ElementType is PointerTypeSyntax;
                    bool isOptional = (param.Attributes & ParameterAttributes.Optional) == ParameterAttributes.Optional;
                    bool isIn = (param.Attributes & ParameterAttributes.In) == ParameterAttributes.In;
                    bool isConst = param.GetCustomAttributes().Any(ah => this.IsAttribute(this.mr.GetCustomAttribute(ah), InteropDecorationNamespace, "ConstAttribute"));
                    bool isComOutPtr = param.GetCustomAttributes().Any(ah => this.IsAttribute(this.mr.GetCustomAttribute(ah), InteropDecorationNamespace, "ComOutPtrAttribute"));
                    bool isOut = isComOutPtr || (param.Attributes & ParameterAttributes.Out) == ParameterAttributes.Out;

                    // If there are no SAL annotations at all...
                    if (!isOptional && !isIn && !isOut)
                    {
                        // Consider that const means [In]
                        if (isConst)
                        {
                            isIn = true;
                            isOut = false;
                        }
                        else
                        {
                            // Otherwise assume bidirectional.
                            isIn = isOut = true;
                        }
                    }

                    bool isArray = false;
                    UnmanagedType? unmanagedType = null;
                    bool isNullTerminated = false;
                    short? sizeParamIndex = null;
                    int? sizeConst = null;
                    foreach (CustomAttributeHandle attHandle in param.GetCustomAttributes())
                    {
                        CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                        if (this.IsAttribute(att, InteropDecorationNamespace, NativeTypeInfoAttribute))
                        {
                            var args = att.DecodeValue(this.customAttributeTypeProvider);
                            if (args.FixedArguments[0].Value is object value)
                            {
                                unmanagedType = (UnmanagedType)value;
                                switch (unmanagedType.Value)
                                {
                                    case UnmanagedType.LPWStr:
                                    case UnmanagedType.LPStr:
                                    case UnmanagedType.LPTStr:
                                    case UnmanagedType.LPArray:
                                        isArray = true;
                                        break;
                                }
                            }

                            isNullTerminated |= args.NamedArguments.Any(a => a.Name == "IsNullTerminated" && a.Value is bool value && value);
                            sizeParamIndex = (short?)args.NamedArguments.FirstOrDefault(a => a.Name == "SizeParamIndex").Value;
                            sizeConst = (int?)args.NamedArguments.FirstOrDefault(a => a.Name == "SizeConst").Value;

                            continue;
                        }
                    }

                    IdentifierNameSyntax origName = IdentifierName(parameters[param.SequenceNumber - 1].Identifier.ValueText);
                    IdentifierNameSyntax localName = IdentifierName(origName + "Local");
                    if (isArray)
                    {
                        // TODO: add support for in/out size parameters. (e.g. RSGetViewports)
                        // TODO: add support for lists of pointers via a generated pointer-wrapping struct (e.g. PSSetSamplers)
                        if (sizeParamIndex.HasValue
                            && !(externMethodDeclaration.ParameterList.Parameters[sizeParamIndex.Value].Type is PointerTypeSyntax)
                            && !isPointerToPointer)
                        {
                            signatureChanged = true;

                            if (lengthParamUsedBy.TryGetValue(sizeParamIndex.Value, out int userIndex))
                            {
                                // Multiple array parameters share a common 'length' parameter.
                                // Since we're making this a little less obvious, add a quick if check in the helper method
                                // that enforces that all such parameters have a common span length.
                                ExpressionSyntax otherUserName = IdentifierName(parameters[userIndex].Identifier.ValueText);
                                leadingStatements.Add(IfStatement(
                                    BinaryExpression(
                                        SyntaxKind.NotEqualsExpression,
                                        GetSpanLength(otherUserName),
                                        GetSpanLength(origName)),
                                    ThrowStatement(ObjectCreationExpression(IdentifierName(nameof(ArgumentException))).WithArgumentList(ArgumentList()))));
                            }
                            else
                            {
                                lengthParamUsedBy.Add(sizeParamIndex.Value, param.SequenceNumber - 1);
                            }

                            parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                .WithType(isIn && isConst ? MakeReadOnlySpanOfT(ptrType.ElementType) : MakeSpanOfT(ptrType.ElementType));
                            fixedBlocks.Add(VariableDeclaration(ptrType).AddVariables(
                                VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                            arguments[param.SequenceNumber - 1] = Argument(localName);

                            ExpressionSyntax sizeArgExpression = GetSpanLength(origName);
                            if (!(parameters[sizeParamIndex.Value].Type is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.IntKeyword } }))
                            {
                                sizeArgExpression = CastExpression(parameters[sizeParamIndex.Value].Type!, sizeArgExpression);
                            }

                            arguments[sizeParamIndex.Value] = Argument(sizeArgExpression);
                        }
                        else if (sizeConst.HasValue && !isPointerToPointer)
                        {
                            // TODO: add support for lists of pointers via a generated pointer-wrapping struct
                            signatureChanged = true;

                            // Accept a span instead of a pointer.
                            parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                .WithType(isIn && isConst ? MakeReadOnlySpanOfT(ptrType.ElementType) : MakeSpanOfT(ptrType.ElementType));
                            fixedBlocks.Add(VariableDeclaration(ptrType).AddVariables(
                                VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                            arguments[param.SequenceNumber - 1] = Argument(localName);

                            // Add a runtime check that the span is at least the required length.
                            leadingStatements.Add(IfStatement(
                                BinaryExpression(
                                    SyntaxKind.LessThanExpression,
                                    GetSpanLength(origName),
                                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(sizeConst.Value))),
                                ThrowStatement(ObjectCreationExpression(IdentifierName(nameof(ArgumentException))).WithArgumentList(ArgumentList()))));
                        }
                        else if (isNullTerminated && parameters[param.SequenceNumber - 1].Type is PointerTypeSyntax { ElementType: PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.CharKeyword } } })
                        {
                            // replace char* with string
                            signatureChanged = true;
                            parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                .WithType(PredefinedType(Token(SyntaxKind.StringKeyword)));
                            fixedBlocks.Add(VariableDeclaration(ptrType).AddVariables(
                                VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                            arguments[param.SequenceNumber - 1] = Argument(localName);
                        }
                    }
                    else if (isIn && isOptional && !isOut && !isPointerToPointer)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(NullableType(ptrType.ElementType));
                        leadingStatements.Add(
                            LocalDeclarationStatement(VariableDeclaration(ptrType.ElementType)
                                .AddVariables(VariableDeclarator(localName.Identifier).WithInitializer(
                                    EqualsValueClause(ConditionalExpression(
                                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("HasValue")),
                                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("Value")),
                                        DefaultExpression(ptrType.ElementType)))))));
                        arguments[param.SequenceNumber - 1] = Argument(ConditionalExpression(
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("HasValue")),
                            PrefixUnaryExpression(SyntaxKind.AddressOfExpression, localName),
                            LiteralExpression(SyntaxKind.NullLiteralExpression)));
                    }
                    else if (isIn && isOut && !isOptional)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(ptrType.ElementType)
                            .WithModifiers(TokenList(Token(SyntaxKind.RefKeyword)));
                        fixedBlocks.Add(VariableDeclaration(ptrType).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                    else if (isOut && !isIn && !isOptional)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(ptrType.ElementType)
                            .WithModifiers(TokenList(Token(SyntaxKind.OutKeyword)));
                        fixedBlocks.Add(VariableDeclaration(ptrType).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                    else if (isIn && !isOut && !isOptional)
                    {
                        // Use the "in" modifier to avoid copying the struct.
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(ptrType.ElementType)
                            .WithModifiers(TokenList(Token(SyntaxKind.InKeyword)));
                        fixedBlocks.Add(VariableDeclaration(ptrType).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                }
            }

            if (signatureChanged)
            {
                if (lengthParamUsedBy.Count > 0)
                {
                    // Remove in reverse order so as to not invalidate the indexes of elements to remove.
                    // Also take care to only remove each element once, even if it shows up multiple times in the collection.
                    var parameterIndexesToRemove = new SortedSet<int>(lengthParamUsedBy.Keys);
                    foreach (int indexToRemove in parameterIndexesToRemove.Reverse())
                    {
                        parameters.RemoveAt(indexToRemove);
                    }
                }

                var leadingTrivia = Trivia(
                    DocumentationCommentTrivia(SyntaxKind.SingleLineDocumentationCommentTrivia).AddContent(
                        XmlText("/// "),
                        XmlEmptyElement("inheritdoc").AddAttributes(XmlCrefAttribute(NameMemberCref(IdentifierName(externMethodDeclaration.Identifier), ToCref(externMethodDeclaration.ParameterList)))),
                        XmlText().AddTextTokens(XmlTextNewLine(TriviaList(), "\r\n", "\r\n", TriviaList()))));
                InvocationExpressionSyntax externInvocation = InvocationExpression(
                    isStatic
                        ? QualifiedName(IdentifierName(declaringTypeName), IdentifierName(externMethodDeclaration.Identifier.Text))
                        : MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName(externMethodDeclaration.Identifier.Text)))
                    .AddArgumentListArguments(arguments.ToArray());
                bool hasVoidReturn = externMethodDeclaration.ReturnType is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.VoidKeyword } };
                var body = Block()
                        .AddStatements(leadingStatements.ToArray())
                        .AddStatements(hasVoidReturn ? (StatementSyntax)ExpressionStatement(externInvocation) : ReturnStatement(externInvocation));

                foreach (var fixedExpression in fixedBlocks)
                {
                    body = Block(FixedStatement(fixedExpression, body));
                }

                var modifiers = TokenList(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword));
                if (isStatic)
                {
                    modifiers = modifiers.Insert(1, Token(SyntaxKind.StaticKeyword));
                }

                MethodDeclarationSyntax friendlyDeclaration = externMethodDeclaration
                    .WithModifiers(modifiers)
                    .WithAttributeLists(List<AttributeListSyntax>())
                    .WithParameterList(ParameterList().AddParameters(parameters.ToArray()))
                    .WithLeadingTrivia(leadingTrivia)
                    .WithBody(body)
                    .WithSemicolonToken(default);
                yield return friendlyDeclaration;
            }
        }

        private bool IsAttribute(CustomAttribute attribute, string ns, string name)
        {
            StringHandle actualNamespace, actualName;
            if (attribute.Constructor.Kind == HandleKind.MemberReference)
            {
                MemberReference memberReference = this.mr.GetMemberReference((MemberReferenceHandle)attribute.Constructor);
                TypeReference parentRef = this.mr.GetTypeReference((TypeReferenceHandle)memberReference.Parent);
                actualNamespace = parentRef.Namespace;
                actualName = parentRef.Name;
            }
            else if (attribute.Constructor.Kind == HandleKind.MethodDefinition)
            {
                MethodDefinition methodDef = this.mr.GetMethodDefinition((MethodDefinitionHandle)attribute.Constructor);
                TypeDefinition typeDef = this.mr.GetTypeDefinition(methodDef.GetDeclaringType());
                actualNamespace = typeDef.Namespace;
                actualName = typeDef.Name;
            }
            else
            {
                throw new NotSupportedException("Unsupported attribute constructor kind: " + attribute.Constructor.Kind);
            }

            return this.mr.StringComparer.Equals(actualName, name) && this.mr.StringComparer.Equals(actualNamespace, ns);
        }

        private List<MemberDeclarationSyntax> GetModuleMemberList(string moduleName)
        {
            if (!this.modulesAndMembers.TryGetValue(moduleName, out var methodsList))
            {
                this.modulesAndMembers.Add(moduleName, methodsList = new List<MemberDeclarationSyntax>());
            }

            return methodsList;
        }

        private string GetNormalizedModuleName(MethodImport import)
        {
            ModuleReference module = this.mr.GetModuleReference(import.Module);
            string moduleName = this.mr.GetString(module.Name);
            if (CanonicalCapitalizations.TryGetValue(moduleName, out string? canonicalModuleName))
            {
                moduleName = canonicalModuleName;
            }

            return moduleName;
        }

        private ParameterListSyntax CreateParameterList(MethodDefinition methodDefinition, MethodSignature<TypeSyntax> signature)
            => ParameterList().AddParameters(methodDefinition.GetParameters().Select(this.mr.GetParameter).Where(p => !p.Name.IsNil).Select(p => this.CreateParameter(signature, p)).ToArray());

        private ParameterSyntax CreateParameter(MethodSignature<TypeSyntax> methodSignature, Parameter parameter)
        {
            string name = this.mr.GetString(parameter.Name);

            // TODO:
            // * Notice [Out][RAIIFree] handle producing parameters. Can we make these provide SafeHandle's?
            var parameterInfo = this.ReinterpretMethodSignatureType(methodSignature.ParameterTypes[parameter.SequenceNumber - 1], parameter.GetCustomAttributes());

            // Determine the custom attributes to apply.
            var attributes = AttributeList();
            if (parameterInfo.Type is PointerTypeSyntax ptr)
            {
                if ((parameter.Attributes & ParameterAttributes.In) == ParameterAttributes.In)
                {
                    attributes = attributes.AddAttributes(InAttributeSyntax);
                }

                if ((parameter.Attributes & ParameterAttributes.Out) == ParameterAttributes.Out)
                {
                    attributes = attributes.AddAttributes(OutAttributeSyntax);
                }

                if ((parameter.Attributes & ParameterAttributes.Optional) == ParameterAttributes.Optional)
                {
                    attributes = attributes.AddAttributes(OptionalAttributeSyntax);
                }
            }

            var modifiers = TokenList();

            ParameterSyntax parameterSyntax = Parameter(
                attributes.Attributes.Count > 0 ? List<AttributeListSyntax>().Add(attributes) : List<AttributeListSyntax>(),
                modifiers,
                parameterInfo.Type,
                SafeIdentifier(name),
                @default: null);

            if (parameterInfo.MarshalAsAttribute is object)
            {
                parameterSyntax = parameterSyntax
                    .AddAttributeLists(AttributeList().AddAttributes(parameterInfo.MarshalAsAttribute));
            }

            return parameterSyntax;
        }

        private (TypeSyntax Type, AttributeSyntax? MarshalAsAttribute) ReinterpretMethodSignatureType(TypeSyntax originalType, CustomAttributeHandleCollection customAttributes)
        {
            foreach (CustomAttributeHandle attHandle in customAttributes)
            {
                CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                if (this.IsAttribute(att, InteropDecorationNamespace, NativeTypeInfoAttribute))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    if (args.FixedArguments[0].Value is object value)
                    {
                        UnmanagedType unmanagedType = (UnmanagedType)value;
                        switch (unmanagedType)
                        {
                            case UnmanagedType.Bool: return (PredefinedType(Token(SyntaxKind.BoolKeyword)), MarshalAs(unmanagedType));
                            case UnmanagedType.LPWStr:
                                if (originalType is PointerTypeSyntax { ElementType: PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.UShortKeyword } } })
                                {
                                    return (PointerType(PredefinedType(Token(SyntaxKind.CharKeyword))), null);
                                }

                                break;

                            case UnmanagedType.LPStr:
                                if (originalType is PointerTypeSyntax { ElementType: PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.SByteKeyword } } })
                                {
                                    return (PointerType(PredefinedType(Token(SyntaxKind.ByteKeyword))), null);
                                }

                                break;

                            default:
                                break;
                        }
                    }

                    break;
                }

                if (this.IsAttribute(att, InteropDecorationNamespace, RAIIFreeAttribute))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    if (args.FixedArguments[0].Value is string releaseMethod && this.GenerateSafeHandle(releaseMethod) is TypeSyntax safeHandleType)
                    {
                        return (safeHandleType, null);
                    }
                }
            }

            return (originalType, null);
        }

        private (TypeSyntax FieldType, SyntaxList<MemberDeclarationSyntax> AdditionalMembers) ReinterpretFieldType(string fieldName, TypeSyntax originalType, CustomAttributeHandleCollection customAttributes)
        {
            ExpressionSyntax GetHiddenFieldAccess() => MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                ThisExpression(),
                IdentifierName(GetHiddenFieldName(fieldName)));

            // For fields, we don't want to use MarshalAs attributes because that turns our structs into managed types,
            // and thus cannot be used with pointers.
            foreach (CustomAttributeHandle attHandle in customAttributes)
            {
                CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                if (this.IsAttribute(att, InteropDecorationNamespace, NativeTypeInfoAttribute))
                {
                    var args = att.DecodeValue(this.customAttributeTypeProvider);
                    if (args.FixedArguments[0].Value is object value)
                    {
                        UnmanagedType unmanagedType = (UnmanagedType)value;
                        switch (unmanagedType)
                        {
                            case UnmanagedType.Bool:
                                // The native memory is 4 bytes long, so we can't use C# bool which is just 1 byte long.
                                // Use int for the field, and generate a property accessor.
                                ExpressionSyntax hiddenFieldAccess = GetHiddenFieldAccess();
                                var property = PropertyDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword)), fieldName)
                                    .AddModifiers(Token(this.Visibility))
                                    .AddAccessorListAccessors(
                                        AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                            .WithExpressionBody(ArrowExpressionClause(BinaryExpression(
                                                SyntaxKind.NotEqualsExpression,
                                                hiddenFieldAccess,
                                                LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)))))
                                            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                                        AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                            .WithExpressionBody(ArrowExpressionClause(AssignmentExpression(
                                                SyntaxKind.SimpleAssignmentExpression,
                                                hiddenFieldAccess,
                                                ConditionalExpression(
                                                    IdentifierName("value"),
                                                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(1)),
                                                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0))))))
                                            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
                                return (originalType, SingletonList<MemberDeclarationSyntax>(property));
                            case UnmanagedType.LPWStr:
                                if (originalType is PointerTypeSyntax { ElementType: PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.UShortKeyword } } })
                                {
                                    return (PointerType(PredefinedType(Token(SyntaxKind.CharKeyword))), default);
                                }

                                break;

                            case UnmanagedType.LPStr:
                                if (originalType is PointerTypeSyntax { ElementType: PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.SByteKeyword } } })
                                {
                                    return (PointerType(PredefinedType(Token(SyntaxKind.ByteKeyword))), default);
                                }

                                break;

                            default:
                                break;
                        }
                    }

                    break;
                }
            }

            // If the field is a fixed length array, we have to work some code gen magic since C# does not allow those.
            if (originalType is ArrayTypeSyntax arrayType && arrayType.RankSpecifiers.Count > 0)
            {
                int length = int.Parse(((LiteralExpressionSyntax)arrayType.RankSpecifiers[0].Sizes[0]).Token.ValueText, CultureInfo.InvariantCulture);
                TypeSyntax elementType = arrayType.ElementType;

                // C# does not allow Span<T> where T is a pointer type.
                if (elementType is PointerTypeSyntax ptr)
                {
                    elementType = IntPtrTypeSyntax;
                }

                // private struct __TheStruct_Count
                // {
                //     private TheStruct _1, _2, _3, _4, _5, _6, _7, _8;
                // }
                var fixedLengthStruct = StructDeclaration($"__{fieldName}_{length}")
                    .AddModifiers(Token(SyntaxKind.PrivateKeyword))
                    .AddAttributeLists(AttributeList().AddAttributes(StructLayout(TypeAttributes.SequentialLayout, new TypeLayout(0, packingSize: 1))))
                    .AddMembers(FieldDeclaration(VariableDeclaration(elementType)
                        .AddVariables(Enumerable.Range(1, length).Select(n => VariableDeclarator($"_{n}")).ToArray()))
                        .AddModifiers(Token(SyntaxKind.PrivateKeyword)));

                // public unsafe Span<TheStruct> TheProperty {
                //    get {
                //       fixed (void* p = &__field)
                //          return new Span<TheStruct>(p, count);
                //    }
                // }
                ExpressionSyntax hiddenFieldAccess = GetHiddenFieldAccess();
                var pointerName = IdentifierName("p");
                var pointerDeclaration = VariableDeclaration(VoidStar).AddVariables(
                    VariableDeclarator(pointerName.Identifier).WithInitializer(
                        EqualsValueClause(PrefixUnaryExpression(SyntaxKind.AddressOfExpression, hiddenFieldAccess))));
                var property = PropertyDeclaration(MakeSpanOfT(elementType), fieldName)
                    .AddModifiers(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword))
                    .AddAccessorListAccessors(AccessorDeclaration(SyntaxKind.GetAccessorDeclaration).WithBody(
                        Block(FixedStatement(
                            pointerDeclaration,
                            ReturnStatement(ObjectCreationExpression(MakeSpanOfT(elementType)).AddArgumentListArguments(
                                Argument(pointerName),
                                Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(length)))))))));

                return (IdentifierName(fixedLengthStruct.Identifier.ValueText), List<MemberDeclarationSyntax>().Add(property).Add(fixedLengthStruct));
            }

            // If the field is a delegate type, we have to replace that with a native function pointer to avoid the struct becoming a 'managed type'.
            if (originalType is IdentifierNameSyntax { Identifier: { ValueText: string typeName } } && this.typesByName.TryGetValue(typeName, out TypeDefinitionHandle typeDefHandle))
            {
                var typeDef = this.mr.GetTypeDefinition(typeDefHandle);
                if ((typeDef.Attributes & TypeAttributes.Class) == TypeAttributes.Class)
                {
                    if (typeDef.BaseType.Kind == HandleKind.TypeReference)
                    {
                        var baseType = this.mr.GetTypeReference((TypeReferenceHandle)typeDef.BaseType);
                        if (this.mr.StringComparer.Equals(baseType.Name, "MulticastDelegate"))
                        {
                            CustomAttribute ufpAtt = typeDef.GetCustomAttributes().Select(ah => this.mr.GetCustomAttribute(ah)).Single(a => this.IsAttribute(a, SystemRuntimeInteropServices, nameof(UnmanagedFunctionPointerAttribute)));
                            var attArgs = ufpAtt.DecodeValue(this.customAttributeTypeProvider);
                            CallingConvention callingConvention = (CallingConvention)attArgs.FixedArguments[0].Value!;

                            this.GetSignatureForDelegate(typeDef, out MethodDefinition invokeMethodDef, out MethodSignature<TypeSyntax> signature);
                            return (FunctionPointer(CallingConvention.StdCall, signature, typeName), default);
                        }
                    }
                }
            }

            return (originalType, default);
        }

        private UnmanagedType? GetUnmanagedType(BlobHandle blobHandle)
        {
            if (blobHandle.IsNil)
            {
                return null;
            }

            BlobReader br = this.mr.GetBlobReader(blobHandle);
            UnmanagedType unmgdType = (UnmanagedType)br.ReadByte();
            return unmgdType;
        }

        private MarshalAsAttribute ToMarshalAsAttribute(BlobHandle blobHandle)
        {
            BlobReader br = this.mr.GetBlobReader(blobHandle);
            UnmanagedType unmgdType = (UnmanagedType)br.ReadByte();
            MarshalAsAttribute ma = new MarshalAsAttribute(unmgdType);
            switch (unmgdType)
            {
                case UnmanagedType.Interface:
                case UnmanagedType.IUnknown:
                case UnmanagedType.IDispatch:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.IidParameterIndex = br.ReadCompressedInteger();
                    break;

                case UnmanagedType.ByValArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeConst = br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.ArraySubType = (UnmanagedType)br.ReadCompressedInteger();

                    break;

                case UnmanagedType.SafeArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SafeArraySubType = (VarEnum)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }
                    ////string udtName = br.ReadSerializedString();
                    ////ma.SafeArrayUserDefinedSubType = Helpers.LoadTypeFromAssemblyQualifiedName(udtName, module.GetRoAssembly(), ignoreCase: false, throwOnError: false);
                    break;

                case UnmanagedType.LPArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.ArraySubType = (UnmanagedType)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeParamIndex = (short)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeConst = br.ReadCompressedInteger();
                    break;

                case UnmanagedType.CustomMarshaler:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    br.ReadSerializedString(); // Skip the typelib guid.

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    br.ReadSerializedString(); // Skip name of native type.

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.MarshalType = br.ReadSerializedString();
                    ////ma.MarshalTypeRef = Helpers.LoadTypeFromAssemblyQualifiedName(ma.MarshalType, module.GetRoAssembly(), ignoreCase: false, throwOnError: false);

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.MarshalCookie = br.ReadSerializedString();
                    break;

                default:
                    break;
            }

            return ma;
        }

        private ExpressionSyntax ToExpressionSyntax(Constant constant)
        {
            var blobReader = this.mr.GetBlobReader(constant.Value);
            return constant.TypeCode switch
            {
                ConstantTypeCode.Boolean => blobReader.ReadBoolean() ? LiteralExpression(SyntaxKind.TrueLiteralExpression) : LiteralExpression(SyntaxKind.FalseLiteralExpression),
                ConstantTypeCode.Char => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadChar())),
                ConstantTypeCode.SByte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadSByte())),
                ConstantTypeCode.Byte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadByte())),
                ConstantTypeCode.Int16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt16())),
                ConstantTypeCode.UInt16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt16())),
                ConstantTypeCode.Int32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt32())),
                ConstantTypeCode.UInt32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt32())),
                ConstantTypeCode.Int64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt64())),
                ConstantTypeCode.UInt64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt64())),
                ConstantTypeCode.Single => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadSingle())),
                ConstantTypeCode.Double => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadDouble())),
                ConstantTypeCode.String => blobReader.ReadConstant(constant.TypeCode) is string value ? LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(value)) : LiteralExpression(SyntaxKind.NullLiteralExpression),
                ConstantTypeCode.NullReference => LiteralExpression(SyntaxKind.NullLiteralExpression),
                _ => throw new NotSupportedException("ConstantTypeCode not supported: " + constant.TypeCode),
            };
        }

        private ExpressionSyntax ToHexExpressionSyntax(Constant constant)
        {
            var blobReader = this.mr.GetBlobReader(constant.Value);
            var blobReader2 = this.mr.GetBlobReader(constant.Value);
            return constant.TypeCode switch
            {
                ConstantTypeCode.SByte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadSByte()), blobReader2.ReadSByte())),
                ConstantTypeCode.Byte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadByte()), blobReader2.ReadByte())),
                ConstantTypeCode.Int16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt16()), blobReader2.ReadInt16())),
                ConstantTypeCode.UInt16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt16()), blobReader2.ReadUInt16())),
                ConstantTypeCode.Int32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt32()), blobReader2.ReadInt32())),
                ConstantTypeCode.UInt32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt32()), blobReader2.ReadUInt32())),
                ConstantTypeCode.Int64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt64()), blobReader2.ReadInt64())),
                ConstantTypeCode.UInt64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt64()), blobReader2.ReadUInt64())),
                _ => throw new NotSupportedException("ConstantTypeCode not supported: " + constant.TypeCode),
            };

            unsafe string ToHex<T>(T value)
                where T : unmanaged
            {
                int fullHexLength = sizeof(T) * 2;
                string hex = string.Format(CultureInfo.InvariantCulture, "0x{0:X" + fullHexLength + "}", value);
                return hex;
            }
        }
    }
}
