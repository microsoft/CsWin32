// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Microsoft.Windows.CsWin32
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Reflection.Metadata;
    using System.Reflection.PortableExecutable;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Threading;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

    /// <summary>
    /// The core of the source generator.
    /// </summary>
    public class Generator : IDisposable
    {
        internal static readonly SyntaxAnnotation IsManagedTypeAnnotation = new SyntaxAnnotation("IsManagedType");
        internal static readonly SyntaxAnnotation IsSafeHandleTypeAnnotation = new SyntaxAnnotation("IsSafeHandleType");
        internal static readonly SyntaxAnnotation IsRetValAnnotation = new SyntaxAnnotation("RetVal");

        internal static readonly Dictionary<string, TypeSyntax> BclInteropStructs = new Dictionary<string, TypeSyntax>(StringComparer.Ordinal)
        {
            { nameof(System.Runtime.InteropServices.ComTypes.FILETIME), ParseTypeName("global::System.Runtime.InteropServices.ComTypes.FILETIME") },
            { nameof(Guid), ParseTypeName("global::System.Guid") },
            { "OLD_LARGE_INTEGER", PredefinedType(Token(SyntaxKind.LongKeyword)) },
            { "LARGE_INTEGER", PredefinedType(Token(SyntaxKind.LongKeyword)) },
            { "ULARGE_INTEGER", PredefinedType(Token(SyntaxKind.ULongKeyword)) },
        };

        internal static readonly Dictionary<string, TypeSyntax> AdditionalBclInteropStructsMarshaled = new Dictionary<string, TypeSyntax>(StringComparer.Ordinal)
        {
            { "BOOL", PredefinedType(Token(SyntaxKind.BoolKeyword)) },
        };

        internal static readonly Dictionary<string, TypeSyntax> BclInteropSafeHandles = new Dictionary<string, TypeSyntax>(StringComparer.Ordinal)
        {
            { "CloseHandle", ParseTypeName("Microsoft.Win32.SafeHandles.SafeFileHandle").WithAdditionalAnnotations(IsManagedTypeAnnotation, IsSafeHandleTypeAnnotation) },
        };

        internal readonly Dictionary<string, string> BannedAPIs = new Dictionary<string, string>
        {
            { "GetLastError", "Do not generate GetLastError. Call Marshal.GetLastWin32Error() instead. Learn more from https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.marshal.getlastwin32error" },
            { "OLD_LARGE_INTEGER", "Use the C# long keyword instead." },
            { "LARGE_INTEGER", "Use the C# long keyword instead." },
            { "ULARGE_INTEGER", "Use the C# ulong keyword instead." },
        };

        private const string SystemRuntimeCompilerServices = "System.Runtime.CompilerServices";
        private const string SystemRuntimeInteropServices = "System.Runtime.InteropServices";
        internal const string InteropDecorationNamespace = "Windows.Win32.Interop";
        private const string RAIIFreeAttribute = "RAIIFreeAttribute";
        internal const string NativeArrayInfoAttribute = "NativeArrayInfoAttribute";
        private const string NativeTypedefAttribute = "NativeTypedefAttribute";
        private const string AutoGeneratedHeader = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

";

        private const string PartialPInvokeContentComment = @"/// <content>
/// Contains extern methods from ""{0}.dll"".
/// </content>
";

        private const string SimpleFileNameAnnotation = "SimpleFileName";
        private const string OriginalDelegateAnnotation = "OriginalDelegate";
        internal const string GlobalNamespacePrefix = "global::";
        private static readonly SyntaxTriviaList InlineArrayUnsafeAsSpanComment = ParseLeadingTrivia(@"/// <summary>
/// Gets this inline array as a span.
/// </summary>
/// <remarks>
/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
/// </remarks>
");

        private static readonly SyntaxTriviaList InlineArrayUnsafeIndexerComment = ParseLeadingTrivia(@"/// <summary>
/// Gets a ref to an individual element of the inline array.
/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
/// </summary>
");

        private static readonly XmlTextSyntax DocCommentStart = XmlText(" ").WithLeadingTrivia(DocumentationCommentExterior("///"));
        private static readonly XmlTextSyntax DocCommentEnd = XmlText(XmlTextNewLine("\r\n", continueXmlDocumentationComment: false));

        private static readonly IdentifierNameSyntax ConstantsClassName = IdentifierName("Constants");
        private static readonly IdentifierNameSyntax InlineArrayIndexerExtensionsClassName = IdentifierName("InlineArrayIndexerExtensions");
        private static readonly IdentifierNameSyntax ComInterfaceFriendlyExtensionsClassName = IdentifierName("FriendlyOverloadExtensions");
        private static readonly TypeSyntax SafeHandleTypeSyntax = IdentifierName("SafeHandle");
        private static readonly IdentifierNameSyntax IntPtrTypeSyntax = IdentifierName(nameof(IntPtr));
        private static readonly AttributeSyntax PreserveSigAttribute = Attribute(IdentifierName("PreserveSig"));
        private static readonly AttributeListSyntax DefaultDllImportSearchPathsAttributeList = AttributeList().AddAttributes(
            Attribute(IdentifierName("DefaultDllImportSearchPaths")).AddArgumentListArguments(AttributeArgument(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(nameof(DllImportSearchPath)), IdentifierName(nameof(DllImportSearchPath.System32))))));

        private static readonly HashSet<string> StringTypeDefNames = new HashSet<string>(StringComparer.Ordinal)
        {
            "PWSTR",
            "PSTR",
        };

        /// <summary>
        /// This is the preferred capitalizations for modules and class names.
        /// If they are not in this list, the capitalization will come from the metadata assembly.
        /// </summary>
        private static readonly ImmutableHashSet<string> CanonicalCapitalizations = ImmutableHashSet.Create<string>(
            StringComparer.OrdinalIgnoreCase,
            "AdvApi32",
            "AuthZ",
            "BCrypt",
            "Cabinet",
            "CfgMgr32",
            "Chakra",
            "CodeGeneration",
            "CodeGeneration.Debugging",
            "CodeGenerationAttributes",
            "ComCtl32",
            "ComDlg32",
            "Crypt32",
            "CryptNet",
            "D3D11",
            "D3D12",
            "D3DCompiler_47",
            "DbgHelp",
            "DfsCli",
            "DhcpCSvc",
            "DhcpCSvc6",
            "DnsApi",
            "DsParse",
            "DSRole",
            "DwmApi",
            "DXGI",
            "Esent",
            "FltLib",
            "Fusion",
            "Gdi32",
            "Hid",
            "Icu",
            "ImageHlp",
            "InkObjCore",
            "IPHlpApi",
            "Kernel32",
            "LogonCli",
            "Magnification",
            "MFSensorGroup",
            "Mpr",
            "MSCms",
            "MSCorEE",
            "Msi",
            "MswSock",
            "NCrypt",
            "NetApi32",
            "NetUtils",
            "NewDev",
            "NTDll",
            "Ole32",
            "OleAut32",
            "PowrProf",
            "PropSys",
            "Psapi",
            "RpcRT4",
            "SamCli",
            "SchedCli",
            "SetupApi",
            "SHCore",
            "Shell32",
            "ShlwApi",
            "SrvCli",
            "TokenBinding",
            "UrlMon",
            "User32",
            "UserEnv",
            "UxTheme",
            "Version",
            "WebAuthN",
            "WebServices",
            "WebSocket",
            "Win32",
            "Win32MetaGeneration",
            "Windows.Core",
            "Windows.ShellScalingApi",
            "WinHttp",
            "WinMM",
            "WinUsb",
            "WksCli",
            "WLanApi",
            "WldAp32",
            "WtsApi32");

        private static readonly HashSet<string> CSharpKeywords = new HashSet<string>(StringComparer.Ordinal)
        {
            "object",
            "event",
            "override",
            "public",
            "private",
            "protected",
            "internal",
            "virtual",
            "string",
            "base",
            "ref",
            "in",
            "out",
            "decimal",
            "as",
            "params",
        };

        private static readonly HashSet<string> ObjectMembers = new HashSet<string>(StringComparer.Ordinal)
        {
            "GetType",
        };

        private static readonly string[] WarningsToSuppressInGeneratedCode = new string[]
        {
            "CS1591", // missing docs
            "CS1573", // missing docs for an individual parameter
            "CS0649", // fields never assigned to
            "CS8019", // unused usings
            "CS1570", // XML comment has badly formed XML
            "CS1584", // C# bug: https://github.com/microsoft/CsWin32/issues/24
            "CS1658", // C# bug: https://github.com/microsoft/CsWin32/issues/24
        };

        private static readonly AttributeSyntax InAttributeSyntax = Attribute(IdentifierName("In"));
        private static readonly AttributeSyntax OutAttributeSyntax = Attribute(IdentifierName("Out"));
        private static readonly AttributeSyntax OptionalAttributeSyntax = Attribute(IdentifierName("Optional"));
        private static readonly AttributeSyntax FlagsAttributeSyntax = Attribute(IdentifierName("Flags"));
        private static readonly AttributeSyntax FieldOffsetAttributeSyntax = Attribute(IdentifierName("FieldOffset"));

        private readonly TypeSyntaxSettings generalTypeSettings;
        private readonly TypeSyntaxSettings fieldTypeSettings;
        private readonly TypeSyntaxSettings delegateSignatureTypeSettings;
        private readonly TypeSyntaxSettings enumTypeSettings;
        private readonly TypeSyntaxSettings fieldOfHandleTypeDefTypeSettings;
        private readonly TypeSyntaxSettings externSignatureTypeSettings;
        private readonly TypeSyntaxSettings externReleaseSignatureTypeSettings;
        private readonly TypeSyntaxSettings comSignatureTypeSettings;
        private readonly TypeSyntaxSettings extensionMethodSignatureTypeSettings;
        private readonly TypeSyntaxSettings functionPointerTypeSettings;
        private readonly TypeSyntaxSettings errorMessageTypeSettings;

        private readonly Stream metadataStream;
        private readonly PEReader peReader;
        private readonly MetadataReader mr;
        private readonly Dictionary<string, List<MemberDeclarationSyntax>> modulesAndMembers = new Dictionary<string, List<MemberDeclarationSyntax>>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// The structs, enums, delegates and other supporting types for extern methods.
        /// </summary>
        private readonly Dictionary<TypeDefinitionHandle, MemberDeclarationSyntax> types = new Dictionary<TypeDefinitionHandle, MemberDeclarationSyntax>();

        private readonly Dictionary<string, FieldDefinitionHandle> fieldsByName = new Dictionary<string, FieldDefinitionHandle>(StringComparer.Ordinal);

        private readonly Dictionary<FieldDefinitionHandle, MemberDeclarationSyntax> fieldsToSyntax = new Dictionary<FieldDefinitionHandle, MemberDeclarationSyntax>();

        private readonly List<ClassDeclarationSyntax> safeHandleTypes = new List<ClassDeclarationSyntax>();

        private readonly Dictionary<string, MemberDeclarationSyntax> specialTypes = new Dictionary<string, MemberDeclarationSyntax>(StringComparer.Ordinal);

        /// <summary>
        /// A dictionary where the key is the typedef struct name and the value is the method used to release it.
        /// </summary>
        private readonly Dictionary<string, string> handleTypeReleaseMethod = new Dictionary<string, string>(StringComparer.Ordinal);

        /// <summary>
        /// The set of names of typedef structs that represent handles where the handle has length of <see cref="IntPtr"/>
        /// and is therefore appropriate to wrap in a <see cref="SafeHandle"/>.
        /// </summary>
        private readonly HashSet<string> handleTypeStructsWithIntPtrSizeFields = new HashSet<string>(StringComparer.Ordinal);

        /// <summary>
        /// The set of types that are or have been generated so we don't stack overflow for self-referencing types.
        /// </summary>
        private readonly HashSet<TypeDefinitionHandle> typesGenerating = new HashSet<TypeDefinitionHandle>();

        /// <summary>
        /// The set of methods that are or have been generated.
        /// </summary>
        private readonly HashSet<MethodDefinitionHandle> methodsGenerating = new HashSet<MethodDefinitionHandle>();

        /// <summary>
        /// A collection of the names of special types we are or have generated.
        /// </summary>
        private readonly HashSet<string> specialTypesGenerating = new HashSet<string>(StringComparer.Ordinal);

        private readonly Dictionary<string, MethodDefinitionHandle> methodsByName;

        private readonly Dictionary<string, TypeDefinitionHandle> typesByName;

        private readonly Dictionary<string, TypeSyntax?> releaseMethodsWithSafeHandleTypesGenerating = new Dictionary<string, TypeSyntax?>();

        private readonly List<MethodDeclarationSyntax> inlineArrayIndexerExtensionsMembers = new();

        private readonly List<MethodDeclarationSyntax> comInterfaceFriendlyExtensionsMembers = new();

        private readonly HashSet<string> releaseMethods = new HashSet<string>(StringComparer.Ordinal);

        private readonly Dictionary<TypeReferenceHandle, TypeDefinitionHandle> refToDefCache = new();

        private readonly GeneratorOptions options;
        private readonly CSharpCompilation? compilation;
        private readonly CSharpParseOptions? parseOptions;
        private readonly bool canCallCreateSpan;

        /// <summary>
        /// Initializes a new instance of the <see cref="Generator"/> class.
        /// </summary>
        /// <param name="metadataLibraryStream">The stream to the winmd metadata to generate APIs from. This will be disposed of with the <see cref="Generator"/>.</param>
        /// <param name="options">Options that influence the result of generation.</param>
        /// <param name="compilation">The compilation that the generated code will be added to.</param>
        /// <param name="parseOptions">The parse options that will be used for the generated code.</param>
        public Generator(Stream metadataLibraryStream, GeneratorOptions? options = null, CSharpCompilation? compilation = null, CSharpParseOptions? parseOptions = null)
        {
            this.options = options ??= new GeneratorOptions();
            this.options.Validate();
            this.compilation = compilation;
            this.parseOptions = parseOptions;

            this.canCallCreateSpan = this.compilation?.GetTypeByMetadataName(typeof(MemoryMarshal).FullName)?.GetMembers("CreateSpan").Any() is true;

            if (!this.options.ComInterop.StructsInsteadOfInterfaces)
            {
                this.BannedAPIs.Add("VARIANT", "Use `object` instead of VARIANT when in COM interface mode. VARIANT can only be emitted when emitting COM interfaces as structs.");
            }

            this.metadataStream = metadataLibraryStream;
            this.peReader = new PEReader(this.metadataStream);
            this.mr = this.peReader.GetMetadataReader();

            bool useComInterfaces = !options.ComInterop.StructsInsteadOfInterfaces;
            this.generalTypeSettings = new TypeSyntaxSettings(
                this,
                PreferNativeInt: this.LanguageVersion >= LanguageVersion.CSharp9,
                PreferMarshaledTypes: false,
                UseComInterfaces: !options.ComInterop.StructsInsteadOfInterfaces,
                QualifyNames: false);
            this.fieldTypeSettings = this.generalTypeSettings;
            this.delegateSignatureTypeSettings = this.generalTypeSettings;
            this.enumTypeSettings = this.generalTypeSettings;
            this.fieldOfHandleTypeDefTypeSettings = this.generalTypeSettings with { PreferNativeInt = false };
            this.externSignatureTypeSettings = this.generalTypeSettings with { QualifyNames = true, PreferMarshaledTypes = true };
            this.externReleaseSignatureTypeSettings = this.generalTypeSettings with { PreferNativeInt = false };
            this.comSignatureTypeSettings = this.generalTypeSettings;
            this.extensionMethodSignatureTypeSettings = this.generalTypeSettings with { QualifyNames = true };
            this.functionPointerTypeSettings = this.generalTypeSettings;
            this.errorMessageTypeSettings = this.generalTypeSettings with { QualifyNames = true };

            this.Apis = this.mr.TypeDefinitions.Select(this.mr.GetTypeDefinition).Where(td => this.mr.StringComparer.Equals(td.Name, "Apis")).ToList();

            this.methodsByName = new Dictionary<string, MethodDefinitionHandle>(StringComparer.Ordinal);
            foreach (MethodDefinitionHandle methodDefHandle in this.Apis.SelectMany(api => api.GetMethods()))
            {
                string methodName = this.mr.GetString(this.mr.GetMethodDefinition(methodDefHandle).Name);
                this.methodsByName.Add(methodName, methodDefHandle);
            }

            this.typesByName = new Dictionary<string, TypeDefinitionHandle>(StringComparer.Ordinal);
            foreach (TypeDefinitionHandle typeDefinitionHandle in this.mr.TypeDefinitions)
            {
                TypeDefinition typeDefinition = this.mr.GetTypeDefinition(typeDefinitionHandle);
                string name = this.mr.GetString(typeDefinition.Name);

                // https://github.com/microsoft/CsWin32/issues/31
                if (!this.typesByName.ContainsKey(name))
                {
                    this.typesByName.Add(name, typeDefinitionHandle);
                }

                // Detect if this is a struct representing a native handle.
                if (typeDefinition.GetFields().Count == 1 && typeDefinition.BaseType.Kind == HandleKind.TypeReference)
                {
                    TypeReference baseType = this.mr.GetTypeReference((TypeReferenceHandle)typeDefinition.BaseType);
                    if (this.mr.StringComparer.Equals(baseType.Name, nameof(ValueType)) && this.mr.StringComparer.Equals(baseType.Namespace, nameof(System)))
                    {
                        foreach (CustomAttributeHandle h in typeDefinition.GetCustomAttributes())
                        {
                            CustomAttribute att = this.mr.GetCustomAttribute(h);
                            if (this.IsAttribute(att, InteropDecorationNamespace, RAIIFreeAttribute))
                            {
                                var args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                                if (args.FixedArguments[0].Value is string freeMethodName)
                                {
                                    this.handleTypeReleaseMethod.Add(name, freeMethodName);
                                    this.releaseMethods.Add(freeMethodName);

                                    using FieldDefinitionHandleCollection.Enumerator fieldEnum = typeDefinition.GetFields().GetEnumerator();
                                    fieldEnum.MoveNext();
                                    FieldDefinitionHandle fieldHandle = fieldEnum.Current;
                                    FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldHandle);
                                    if (fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null) is PrimitiveTypeHandleInfo { PrimitiveTypeCode: PrimitiveTypeCode.IntPtr })
                                    {
                                        this.handleTypeStructsWithIntPtrSizeFields.Add(name);
                                    }
                                }

                                break;
                            }
                        }
                    }
                }
            }

            foreach (FieldDefinitionHandle fieldDefHandle in this.Apis.SelectMany(api => api.GetFields()))
            {
                FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
                const FieldAttributes expectedFlags = FieldAttributes.Literal | FieldAttributes.Static | FieldAttributes.Public;
                if ((fieldDef.Attributes & expectedFlags) == expectedFlags)
                {
                    string name = this.mr.GetString(fieldDef.Name);
                    this.fieldsByName.Add(name, fieldDefHandle);
                }
            }
        }

        internal List<TypeDefinition> Apis { get; }

        internal MetadataReader Reader => this.mr;

        internal LanguageVersion LanguageVersion => this.parseOptions?.LanguageVersion ?? LanguageVersion.CSharp9;

        private bool WideCharOnly => this.options.WideCharOnly;

        private bool GroupByModule => string.IsNullOrEmpty(this.options.ClassName);

        private string Namespace => this.options.Namespace;

        private string SingleClassName => this.options.ClassName ?? throw new InvalidOperationException("Not in one-class mode.");

        private SyntaxKind Visibility => this.options.Public ? SyntaxKind.PublicKeyword : SyntaxKind.InternalKeyword;

        private IEnumerable<MemberDeclarationSyntax> NamespaceMembers
        {
            get
            {
                IEnumerable<MemberDeclarationSyntax> result = this.GroupByModule
                    ? this.ExternMethodsByModuleClassName.Select(kv =>
                        ClassDeclaration(Identifier(GetClassNameForModule(kv.Key)))
                        .AddModifiers(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword))
                        .AddMembers(kv.ToArray()))
                    : from entry in this.modulesAndMembers
                      select ClassDeclaration(Identifier(this.SingleClassName))
                        .AddModifiers(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword))
                        .AddMembers(entry.Value.ToArray())
                        .WithLeadingTrivia(ParseLeadingTrivia(string.Format(CultureInfo.InvariantCulture, PartialPInvokeContentComment, entry.Key)))
                        .WithAdditionalAnnotations(new SyntaxAnnotation(SimpleFileNameAnnotation, $"{this.SingleClassName}.{entry.Key}"));
                result = result
                    .Concat(this.safeHandleTypes)
                    .Concat(this.specialTypes.Values)
                    .Concat(this.types.Values);

                ClassDeclarationSyntax constantClass = this.DeclareConstantDefiningClass();
                if (constantClass.Members.Count > 0)
                {
                    result = result.Concat(new MemberDeclarationSyntax[] { constantClass });
                }

                ClassDeclarationSyntax inlineArrayIndexerExtensionsClass = this.DeclareInlineArrayIndexerExtensionsClass();
                if (inlineArrayIndexerExtensionsClass.Members.Count > 0)
                {
                    result = result.Concat(new MemberDeclarationSyntax[] { inlineArrayIndexerExtensionsClass });
                }

                ClassDeclarationSyntax comInterfaceFriendlyExtensionsClass = this.DeclareComInterfaceFriendlyExtensionsClass();
                if (comInterfaceFriendlyExtensionsClass.Members.Count > 0)
                {
                    result = result.Concat(new MemberDeclarationSyntax[] { comInterfaceFriendlyExtensionsClass });
                }

                return result;
            }
        }

        private IEnumerable<IGrouping<string, MemberDeclarationSyntax>> ExternMethodsByModuleClassName =>
            from entry in this.modulesAndMembers
            from method in entry.Value
            group method by GetClassNameForModule(entry.Key) into x
            select x;

        /// <inheritdoc/>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Generates all extern methods, structs, delegates, constants as defined by the source metadata.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAll(CancellationToken cancellationToken)
        {
            this.GenerateAllExternMethods(cancellationToken);

            // Also generate all structs/enum types too, even if not referenced by a method,
            // since some methods use `void*` types and require structs at runtime.
            this.RequestAllInteropTypes(cancellationToken);

            this.GenerateAllConstants(cancellationToken);
        }

        /// <summary>
        /// Generates code for a given API.
        /// </summary>
        /// <param name="apiNameOrModuleWildcard">The name of the method, struct or constant. Or the name of a module with a ".*" suffix in order to generate all methods and supporting types for the specified module.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns><see langword="true" /> if any matching APIs were found and generated; <see langword="false"/> otherwise.</returns>
        public bool TryGenerate(string apiNameOrModuleWildcard, CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(apiNameOrModuleWildcard))
            {
                throw new ArgumentException("API cannot be null or empty.", nameof(apiNameOrModuleWildcard));
            }

            if (apiNameOrModuleWildcard.EndsWith(".*", StringComparison.Ordinal))
            {
                return this.TryGenerateAllExternMethods(apiNameOrModuleWildcard.Substring(0, apiNameOrModuleWildcard.Length - 2), cancellationToken);
            }
            else
            {
                return
                    this.TryGenerateExternMethod(apiNameOrModuleWildcard) ||
                    this.TryGenerateType(apiNameOrModuleWildcard) ||
                    this.TryGenerateConstant(apiNameOrModuleWildcard);
            }
        }

        /// <summary>
        /// Gets the name of the declaring enum if a supplied value matches the name of an enum's value.
        /// </summary>
        /// <param name="enumValueName">A string that may match an enum value name.</param>
        /// <param name="declaringEnum">Receives the name of the declaring enum if a match is found.</param>
        /// <returns><see langword="true"/> if a match was found; otherwise <see langword="false"/>.</returns>
        public bool TryGetEnumName(string enumValueName, [NotNullWhen(true)] out string? declaringEnum)
        {
            // First find the type reference for System.Enum
            TypeReferenceHandle? enumTypeRefHandle = null;
            foreach (TypeReferenceHandle typeRefHandle in this.mr.TypeReferences)
            {
                TypeReference typeRef = this.mr.GetTypeReference(typeRefHandle);
                if (this.mr.StringComparer.Equals(typeRef.Name, nameof(Enum)) && this.mr.StringComparer.Equals(typeRef.Namespace, nameof(System)))
                {
                    enumTypeRefHandle = typeRefHandle;
                    break;
                }
            }

            Debug.Assert(enumTypeRefHandle.HasValue, "We always expect at least one enum.");
            if (enumTypeRefHandle is null)
            {
                // No enums -> it couldn't be what the caller is looking for.
                declaringEnum = null;
                return false;
            }

            foreach (TypeDefinitionHandle typeDefHandle in this.mr.TypeDefinitions)
            {
                TypeDefinition typeDef = this.mr.GetTypeDefinition(typeDefHandle);
                if (typeDef.BaseType.IsNil)
                {
                    continue;
                }

                if (typeDef.BaseType.Kind != HandleKind.TypeReference)
                {
                    continue;
                }

                var baseTypeHandle = (TypeReferenceHandle)typeDef.BaseType;
                if (!baseTypeHandle.Equals(enumTypeRefHandle.Value))
                {
                    continue;
                }

                foreach (FieldDefinitionHandle fieldDefHandle in typeDef.GetFields())
                {
                    FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
                    if (this.mr.StringComparer.Equals(fieldDef.Name, enumValueName))
                    {
                        declaringEnum = this.mr.GetString(typeDef.Name);
                        return true;
                    }
                }
            }

            declaringEnum = null;
            return false;
        }

        /// <summary>
        /// Generates a projection of all extern methods and their supporting types.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAllExternMethods(CancellationToken cancellationToken)
        {
            foreach (MethodDefinitionHandle methodHandle in this.Apis.SelectMany(api => api.GetMethods()))
            {
                cancellationToken.ThrowIfCancellationRequested();

                this.RequestExternMethod(methodHandle);
            }
        }

        /// <summary>
        /// Generates a projection of all constants.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        public void GenerateAllConstants(CancellationToken cancellationToken)
        {
            foreach (FieldDefinitionHandle fieldDefHandle in this.Apis.SelectMany(api => api.GetFields()))
            {
                cancellationToken.ThrowIfCancellationRequested();

                this.RequestConstant(fieldDefHandle);
            }
        }

        /// <summary>
        /// Generates all extern methods exported from a particular module, along with all their supporting types.
        /// </summary>
        /// <param name="moduleName">The name of the module for whose exports extern methods should be generated for.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns><see langword="true"/> if a matching module name was found and extern methods generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateAllExternMethods(string moduleName, CancellationToken cancellationToken)
        {
            bool successful = false;
            foreach (MethodDefinitionHandle methodHandle in this.Apis.SelectMany(api => api.GetMethods()))
            {
                cancellationToken.ThrowIfCancellationRequested();

                MethodDefinition methodDef = this.mr.GetMethodDefinition(methodHandle);
                ModuleReferenceHandle moduleHandle = methodDef.GetImport().Module;
                if (moduleHandle.IsNil)
                {
                    continue;
                }

                ModuleReference module = this.mr.GetModuleReference(moduleHandle);
                if (this.mr.StringComparer.Equals(module.Name, moduleName, ignoreCase: true))
                {
                    string? bannedReason = null;
                    foreach (var bannedApi in this.BannedAPIs)
                    {
                        if (this.mr.StringComparer.Equals(methodDef.Name, bannedApi.Key))
                        {
                            // Skip a banned API.
                            bannedReason = bannedApi.Value;
                            continue;
                        }
                    }

                    if (bannedReason is object)
                    {
                        continue;
                    }

                    this.RequestExternMethod(methodHandle);
                    successful = true;
                }
            }

            return successful;
        }

        /// <summary>
        /// Generate code for the named extern method, if it is recognized.
        /// </summary>
        /// <param name="name">The name of the extern method.</param>
        /// <returns><see langword="true"/> if a match was found and the extern method generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateExternMethod(string name)
        {
            if (this.BannedAPIs.TryGetValue(name, out string? reason))
            {
                throw new NotSupportedException(reason);
            }

            if (this.methodsByName.TryGetValue(name, out MethodDefinitionHandle handle))
            {
                this.RequestExternMethod(handle);
                return true;
            }

            bool successful = false;
            if (this.methodsByName.TryGetValue(name + "W", out handle))
            {
                this.RequestExternMethod(handle);
                successful = true;
            }

            if (this.methodsByName.TryGetValue(name + "A", out handle))
            {
                this.RequestExternMethod(handle);
                successful = true;
            }

            return successful;
        }

        /// <summary>
        /// Generate code for the named type, if it is recognized.
        /// </summary>
        /// <param name="name">The name of the type.</param>
        /// <returns><see langword="true"/> if a match was found and the type generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateType(string name)
        {
            if (this.typesByName.TryGetValue(name, out TypeDefinitionHandle typeDefHandle))
            {
                this.RequestInteropType(typeDefHandle);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Generate code for the named constant, if it is recognized.
        /// </summary>
        /// <param name="name">The name of the constant.</param>
        /// <returns><see langword="true"/> if a match was found and the constant generated; otherwise <see langword="false"/>.</returns>
        public bool TryGenerateConstant(string name)
        {
            if (this.fieldsByName.TryGetValue(name, out FieldDefinitionHandle fieldDefHandle))
            {
                this.RequestConstant(fieldDefHandle);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Collects the result of code generation.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>All the generated source files, keyed by filename.</returns>
        public IReadOnlyDictionary<string, CompilationUnitSyntax> GetCompilationUnits(CancellationToken cancellationToken)
        {
            var starterNamespace = NamespaceDeclaration(ParseName(this.Namespace));

            // .g.cs because the resulting files are not user-created.
            const string FilenamePattern = "{0}.g.cs";
            var results = new Dictionary<string, NamespaceDeclarationSyntax>(StringComparer.OrdinalIgnoreCase);

            if (this.options.EmitSingleFile)
            {
                results.Add(
                    string.Format(CultureInfo.InvariantCulture, FilenamePattern, "NativeMethods"),
                    starterNamespace.AddMembers(this.NamespaceMembers.ToArray()));
            }
            else
            {
                var membersByFile = this.NamespaceMembers.GroupBy(
                    member => member.HasAnnotations(SimpleFileNameAnnotation)
                            ? member.GetAnnotations(SimpleFileNameAnnotation).Single().Data
                            : member switch
                            {
                                ClassDeclarationSyntax classDecl => classDecl.Identifier.ValueText,
                                StructDeclarationSyntax structDecl => structDecl.Identifier.ValueText,
                                InterfaceDeclarationSyntax ifaceDecl => ifaceDecl.Identifier.ValueText,
                                EnumDeclarationSyntax enumDecl => enumDecl.Identifier.ValueText,
                                DelegateDeclarationSyntax delegateDecl => "Delegates", // group all delegates in one file
                                _ => throw new NotSupportedException("Unsupported member type: " + member.GetType().Name),
                            },
                    StringComparer.OrdinalIgnoreCase);

                foreach (var fileSimpleName in membersByFile)
                {
                    try
                    {
                        results.Add(
                            string.Format(CultureInfo.InvariantCulture, FilenamePattern, fileSimpleName.Key),
                            starterNamespace.AddMembers(fileSimpleName.ToArray()));
                    }
                    catch (ArgumentException ex)
                    {
                        throw new GenerationFailedException($"Failed adding \"{fileSimpleName.Key}\".", ex);
                    }
                }
            }

            var normalizedResults = new Dictionary<string, CompilationUnitSyntax>(StringComparer.OrdinalIgnoreCase);
            results.AsParallel().WithCancellation(cancellationToken).ForAll(kv =>
            {
                var compilationUnit = CompilationUnit()
                    .AddMembers(
                        kv.Value.AddUsings(
                            UsingDirective(AliasQualifiedName(IdentifierName(Token(SyntaxKind.GlobalKeyword)), IdentifierName(nameof(System)))),
                            UsingDirective(AliasQualifiedName(IdentifierName(Token(SyntaxKind.GlobalKeyword)), IdentifierName(nameof(System) + "." + nameof(System.Diagnostics)))),
                            UsingDirective(ParseName(GlobalNamespacePrefix + SystemRuntimeCompilerServices)),
                            UsingDirective(ParseName(GlobalNamespacePrefix + SystemRuntimeInteropServices))))
                    .WithLeadingTrivia(ParseLeadingTrivia(AutoGeneratedHeader).Add(
                        Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true).AddErrorCodes(WarningsToSuppressInGeneratedCode.Select(code => IdentifierName(code)).ToArray()))))
                    .NormalizeWhitespace();

                lock (normalizedResults)
                {
                    normalizedResults.Add(kv.Key, compilationUnit);
                }
            });

            return normalizedResults;
        }

        internal bool TryGetHandleReleaseMethod(string handleStructName, [NotNullWhen(true)] out string? releaseMethod)
        {
            return this.handleTypeReleaseMethod.TryGetValue(handleStructName, out releaseMethod);
        }

        internal void RequestAllInteropTypes(CancellationToken cancellationToken)
        {
            foreach (TypeDefinitionHandle typeDefinitionHandle in this.mr.TypeDefinitions)
            {
                cancellationToken.ThrowIfCancellationRequested();
                TypeDefinition typeDef = this.mr.GetTypeDefinition(typeDefinitionHandle);
                if (typeDef.BaseType.IsNil)
                {
                    continue;
                }

                this.RequestInteropType(typeDefinitionHandle);
            }
        }

        internal void RequestExternMethod(MethodDefinitionHandle methodDefinitionHandle)
        {
            if (methodDefinitionHandle.IsNil)
            {
                return;
            }

            if (!this.methodsGenerating.Add(methodDefinitionHandle))
            {
                return;
            }

            this.DeclareExternMethod(methodDefinitionHandle);
        }

        internal TypeDefinitionHandle? RequestInteropType(TypeReferenceHandle typeRefHandle)
        {
            if (this.TryGetTypeDefHandle(typeRefHandle, out TypeDefinitionHandle typeDefHandle))
            {
                this.RequestInteropType(typeDefHandle);
                return typeDefHandle;
            }
            else
            {
                // System.Guid reaches here, but doesn't need to be generated.
                ////throw new NotSupportedException($"Could not find a type def for: {this.mr.GetString(typeRef.Namespace)}.{name}");
                return null;
            }
        }

        internal bool IsInterface(string name) => this.typesByName.TryGetValue(name, out TypeDefinitionHandle tdh) && (this.mr.GetTypeDefinition(tdh).Attributes & TypeAttributes.Interface) == TypeAttributes.Interface;

        internal bool IsInterface(TypeReferenceHandle typeRefHandle)
        {
            if (this.TryGetTypeDefHandle(typeRefHandle, out TypeDefinitionHandle typeDefHandle))
            {
                TypeDefinition typeDef = this.mr.GetTypeDefinition(typeDefHandle);
                return (typeDef.Attributes & TypeAttributes.Interface) == TypeAttributes.Interface;
            }

            return false;
        }

        internal void RequestInteropType(TypeDefinitionHandle typeDefHandle)
        {
            TypeDefinition typeDef = this.mr.GetTypeDefinition(typeDefHandle);
            if (typeDef.GetDeclaringType() is { IsNil: false } nestingParentHandle)
            {
                // We should only generate this type into its parent type.
                this.RequestInteropType(nestingParentHandle);
                return;
            }

            if (!this.typesGenerating.Add(typeDefHandle))
            {
                return;
            }

            // https://github.com/microsoft/CsWin32/issues/31
            string name = this.mr.GetString(typeDef.Name);
            if (this.typesByName.TryGetValue(name, out TypeDefinitionHandle expectedHandle) && !expectedHandle.Equals(typeDefHandle))
            {
                // Skip generating types with conflicting names till we fix that issue.
                return;
            }

            MemberDeclarationSyntax? typeDeclaration = this.RequestInteropType(typeDefHandle, null);

            if (typeDeclaration is object)
            {
                this.types.Add(typeDefHandle, typeDeclaration);
            }
        }

        internal void RequestConstant(FieldDefinitionHandle fieldDefHandle)
        {
            if (this.fieldsToSyntax.ContainsKey(fieldDefHandle))
            {
                return;
            }

            FieldDeclarationSyntax constantDeclaration = this.DeclareField(fieldDefHandle);
            constantDeclaration = AddApiDocumentation(constantDeclaration.Declaration.Variables[0].Identifier.ValueText, constantDeclaration);
            this.fieldsToSyntax.Add(fieldDefHandle, constantDeclaration);
        }

        internal TypeSyntax? RequestSafeHandle(string releaseMethod)
        {
            if (this.releaseMethodsWithSafeHandleTypesGenerating.TryGetValue(releaseMethod, out TypeSyntax? safeHandleType))
            {
                return safeHandleType;
            }

            if (BclInteropSafeHandles.TryGetValue(releaseMethod, out TypeSyntax? bclType))
            {
                return bclType;
            }

            string safeHandleClassName = $"{releaseMethod}SafeHandle";

            MethodDefinitionHandle releaseMethodHandle = this.methodsByName[releaseMethod];
            MethodDefinition releaseMethodDef = this.mr.GetMethodDefinition(releaseMethodHandle);
            string releaseMethodModule = this.GetNormalizedModuleName(releaseMethodDef.GetImport());

            var safeHandleTypeIdentifier = IdentifierName(safeHandleClassName);
            safeHandleType = this.GroupByModule
                ? QualifiedName(IdentifierName(releaseMethodModule), safeHandleTypeIdentifier)
                : safeHandleTypeIdentifier;
            safeHandleType = safeHandleType.WithAdditionalAnnotations(IsManagedTypeAnnotation, IsSafeHandleTypeAnnotation);

            MethodSignature<TypeHandleInfo> releaseMethodSignature = releaseMethodDef.DecodeSignature(SignatureHandleProvider.Instance, null);
            var releaseMethodParameterType = releaseMethodSignature.ParameterTypes[0].ToTypeSyntax(this.externSignatureTypeSettings, default);

            // If the release method takes more than one parameter, we can't generate a SafeHandle for it.
            if (releaseMethodSignature.RequiredParameterCount != 1)
            {
                safeHandleType = null;
            }

            this.releaseMethodsWithSafeHandleTypesGenerating.Add(releaseMethod, safeHandleType);

            if (safeHandleType is null)
            {
                return safeHandleType;
            }

            if (this.FindSymbolIfAlreadyAvailable($"{this.Namespace}.{safeHandleType}") is object)
            {
                return safeHandleType;
            }

            this.RequestExternMethod(releaseMethodHandle);

            var atts = this.GetReturnTypeCustomAttributes(releaseMethodDef);
            var releaseMethodReturnType = releaseMethodSignature.ReturnType.ToTypeSyntax(this.externSignatureTypeSettings, atts);

            this.TryGetRenamedMethod(releaseMethod, out string? renamedReleaseMethod);

            var members = new List<MemberDeclarationSyntax>();

            MemberAccessExpressionSyntax thisHandle = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("handle"));
            ExpressionSyntax intptrZero = DefaultExpression(IntPtrTypeSyntax);
            ExpressionSyntax intptrMinusOne = ObjectCreationExpression(IntPtrTypeSyntax).AddArgumentListArguments(Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(-1))));

            // private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            const string invalidValueFieldName = "INVALID_HANDLE_VALUE";
            members.Add(FieldDeclaration(VariableDeclaration(IntPtrTypeSyntax).AddVariables(
                VariableDeclarator(invalidValueFieldName).WithInitializer(EqualsValueClause(intptrMinusOne))))
                .AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ReadOnlyKeyword)));

            // public SafeHandle() : base(INVALID_HANDLE_VALUE, true)
            members.Add(ConstructorDeclaration(safeHandleClassName)
                .AddModifiers(Token(this.Visibility))
                .WithInitializer(ConstructorInitializer(SyntaxKind.BaseConstructorInitializer, ArgumentList().AddArguments(
                    Argument(IdentifierName(invalidValueFieldName)),
                    Argument(LiteralExpression(SyntaxKind.TrueLiteralExpression)))))
                .WithBody(Block()));

            // public SafeHandle(IntPtr preexistingHandle, bool ownsHandle = true) : base(INVALID_HANDLE_VALUE, ownsHandle) { this.SetHandle(preexistingHandle); }
            const string preexistingHandleName = "preexistingHandle";
            const string ownsHandleName = "ownsHandle";
            members.Add(ConstructorDeclaration(safeHandleClassName)
                .AddModifiers(Token(this.Visibility))
                .AddParameterListParameters(
                    Parameter(Identifier(preexistingHandleName)).WithType(IntPtrTypeSyntax),
                    Parameter(Identifier(ownsHandleName)).WithType(PredefinedType(Token(SyntaxKind.BoolKeyword)))
                        .WithDefault(EqualsValueClause(LiteralExpression(SyntaxKind.TrueLiteralExpression))))
                .WithInitializer(ConstructorInitializer(SyntaxKind.BaseConstructorInitializer, ArgumentList().AddArguments(
                    Argument(IdentifierName(invalidValueFieldName)),
                    Argument(IdentifierName(ownsHandleName)))))
                .WithBody(Block().AddStatements(
                    ExpressionStatement(InvocationExpression(MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        ThisExpression(),
                        IdentifierName("SetHandle"))).AddArgumentListArguments(
                        Argument(IdentifierName(preexistingHandleName)))))));

            // public override bool IsInvalid => this.handle == default || this.Handle == INVALID_HANDLE_VALUE;
            members.Add(PropertyDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword)), nameof(SafeHandle.IsInvalid))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(
                    BinaryExpression(
                        SyntaxKind.LogicalOrExpression,
                        BinaryExpression(SyntaxKind.EqualsExpression, thisHandle, intptrZero),
                        BinaryExpression(SyntaxKind.EqualsExpression, thisHandle, IdentifierName(invalidValueFieldName)))))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            // protected override bool ReleaseHandle() => ReleaseMethod((struct)this.handle);
            // Special case release functions based on their return type as follows: (https://github.com/microsoft/win32metadata/issues/25)
            //  * bool => true is success
            //  * int => zero is success
            //  * uint => zero is success
            //  * byte => non-zero is success
            ExpressionSyntax releaseInvocation = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(this.GroupByModule ? releaseMethodModule : this.SingleClassName),
                    IdentifierName(renamedReleaseMethod ?? releaseMethod)),
                ArgumentList().AddArguments(Argument(CastExpression(releaseMethodParameterType.Type, MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("handle"))))));
            BlockSyntax? releaseBlock = null;
            if (!(releaseMethodReturnType.Type is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.BoolKeyword } } ||
                releaseMethodReturnType.Type is IdentifierNameSyntax { Identifier: { ValueText: "BOOL" } }))
            {
                switch (releaseMethodReturnType.Type)
                {
                    case PredefinedTypeSyntax predefined:
                        SyntaxKind returnType = predefined.Keyword.Kind();
                        if (returnType == SyntaxKind.IntKeyword)
                        {
                            releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                        }
                        else if (returnType == SyntaxKind.UIntKeyword)
                        {
                            releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                        }
                        else if (returnType == SyntaxKind.ByteKeyword)
                        {
                            releaseInvocation = BinaryExpression(SyntaxKind.NotEqualsExpression, releaseInvocation, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
                        }
                        else if (returnType == SyntaxKind.VoidKeyword)
                        {
                            releaseBlock = Block(
                                ExpressionStatement(releaseInvocation),
                                ReturnStatement(LiteralExpression(SyntaxKind.TrueLiteralExpression)));
                        }
                        else
                        {
                            throw new NotSupportedException($"Return type {returnType} on release method {releaseMethod} not supported.");
                        }

                        break;
                    case IdentifierNameSyntax identifierName:
                        switch (identifierName.Identifier.ValueText)
                        {
                            case "LSTATUS":
                                this.TryGenerateConstant("ERROR_SUCCESS");
                                ExpressionSyntax errorSuccess = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ConstantsClassName, IdentifierName("ERROR_SUCCESS"));
                                releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, CastExpression(IdentifierName("LSTATUS"), errorSuccess));
                                break;
                            case "NTSTATUS":
                                // https://github.com/microsoft/win32metadata/issues/136
                                ////ExpressionSyntax statusSuccess = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("NTSTATUS"), IdentifierName("STATUS_SUCCESS"));
                                releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, CastExpression(IdentifierName("NTSTATUS"), LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0))));
                                break;
                            case "HRESULT":
                                this.TryGenerateConstant("S_OK");
                                ExpressionSyntax ok = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ConstantsClassName, IdentifierName("S_OK"));
                                releaseInvocation = BinaryExpression(SyntaxKind.EqualsExpression, releaseInvocation, CastExpression(IdentifierName("HRESULT"), ok));
                                break;
                            default:
                                throw new NotSupportedException($"Return type {identifierName.Identifier.ValueText} on release method {releaseMethod} not supported.");
                        }

                        break;
                }
            }

            MethodDeclarationSyntax releaseHandleDeclaration = MethodDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword)), "ReleaseHandle")
                .AddModifiers(Token(SyntaxKind.ProtectedKeyword), Token(SyntaxKind.OverrideKeyword));
            releaseHandleDeclaration = releaseBlock is null
                ? releaseHandleDeclaration
                     .WithExpressionBody(ArrowExpressionClause(releaseInvocation))
                     .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                : releaseHandleDeclaration
                    .WithBody(releaseBlock);
            members.Add(releaseHandleDeclaration);

            ClassDeclarationSyntax safeHandleDeclaration = ClassDeclaration(safeHandleClassName)
                .AddModifiers(Token(this.Visibility))
                .AddBaseListTypes(SimpleBaseType(SafeHandleTypeSyntax))
                .AddMembers(members.ToArray())
                .WithLeadingTrivia(ParseLeadingTrivia($@"/// <summary>
        /// Represents a Win32 handle that can be closed with <see cref=""{(this.GroupByModule ? releaseMethodModule : this.SingleClassName)}.{renamedReleaseMethod ?? releaseMethod}""/>.
        /// </summary>
"));

            this.safeHandleTypes.Add(safeHandleDeclaration);
            if (this.GroupByModule)
            {
                this.GetModuleMemberList(releaseMethodModule).Add(safeHandleDeclaration);
            }

            return safeHandleType;
        }

        /// <summary>
        /// Disposes of managed and unmanaged resources.
        /// </summary>
        /// <param name="disposing"><see langword="true"/> if being disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.peReader.Dispose();
                this.metadataStream.Dispose();
            }
        }

        private static T AddApiDocumentation<T>(string api, T memberDeclaration)
            where T : MemberDeclarationSyntax
        {
            if (Docs.Instance.TryGetApiDocs(api, out var docs))
            {
                var docCommentsBuilder = new StringBuilder();
                if (docs.Description is object)
                {
                    docCommentsBuilder.Append($@"/// <summary>");
                    EmitDoc(docs.Description, docCommentsBuilder, docs, string.Empty);
                    docCommentsBuilder.AppendLine("</summary>");
                }

                if (docs.Parameters is object)
                {
                    if (memberDeclaration is BaseMethodDeclarationSyntax methodDecl)
                    {
                        foreach (var entry in docs.Parameters)
                        {
                            if (!methodDecl.ParameterList.Parameters.Any(p => string.Equals(p.Identifier.ValueText, entry.Key, StringComparison.Ordinal)))
                            {
                                // Skip documentation for parameters that do not actually exist on the method.
                                continue;
                            }

                            docCommentsBuilder.Append($@"/// <param name=""{entry.Key}"">");
                            EmitDoc(entry.Value, docCommentsBuilder, docs, "parameters");
                            docCommentsBuilder.AppendLine("</param>");
                        }
                    }
                }

                if (docs.Fields is object)
                {
                    var fieldsDocBuilder = new StringBuilder();
                    switch (memberDeclaration)
                    {
                        case StructDeclarationSyntax structDeclaration:
                            memberDeclaration = memberDeclaration.ReplaceNodes(
                                structDeclaration.Members.OfType<FieldDeclarationSyntax>(),
                                (_, field) =>
                                {
                                    var variable = field.Declaration.Variables.Single();
                                    if (docs.Fields.TryGetValue(variable.Identifier.ValueText, out string? fieldDoc))
                                    {
                                        fieldsDocBuilder.Append("/// <summary>");
                                        EmitDoc(fieldDoc, fieldsDocBuilder, docs, "members");
                                        fieldsDocBuilder.AppendLine("</summary>");
                                        if (field.Declaration.Type.HasAnnotations(OriginalDelegateAnnotation))
                                        {
                                            fieldsDocBuilder.AppendLine(@$"/// <remarks>See the <see cref=""{field.Declaration.Type.GetAnnotations(OriginalDelegateAnnotation).Single().Data}"" /> delegate for more about this function.</remarks>");
                                        }

                                        field = field.WithLeadingTrivia(ParseLeadingTrivia(fieldsDocBuilder.ToString()));
                                        fieldsDocBuilder.Clear();
                                    }

                                    return field;
                                });
                            break;
                        case EnumDeclarationSyntax enumDeclaration:
                            memberDeclaration = memberDeclaration.ReplaceNodes(
                                enumDeclaration.Members,
                                (_, field) =>
                                {
                                    if (docs.Fields.TryGetValue(field.Identifier.ValueText, out string? fieldDoc))
                                    {
                                        fieldsDocBuilder.Append($@"/// <summary>");
                                        EmitDoc(fieldDoc, fieldsDocBuilder, docs, "members");
                                        fieldsDocBuilder.AppendLine("</summary>");
                                        field = field.WithLeadingTrivia(ParseLeadingTrivia(fieldsDocBuilder.ToString()));
                                        fieldsDocBuilder.Clear();
                                    }

                                    return field;
                                });
                            break;
                    }
                }

                if (docs.ReturnValue is object)
                {
                    docCommentsBuilder.Append("/// <returns>");
                    EmitDoc(docs.ReturnValue, docCommentsBuilder, docs: null, string.Empty);
                    docCommentsBuilder.AppendLine("</returns>");
                }

                if (docs.Remarks is object || docs.HelpLink is object)
                {
                    docCommentsBuilder.Append($"/// <remarks>");
                    if (docs.Remarks is object)
                    {
                        EmitDoc(docs.Remarks, docCommentsBuilder, docs, string.Empty);
                    }
                    else if (docs.HelpLink is object)
                    {
                        docCommentsBuilder.AppendLine();
                        docCommentsBuilder.AppendLine($@"/// <para><see href=""{docs.HelpLink}"">Learn more about this API from docs.microsoft.com</see>.</para>");
                        docCommentsBuilder.Append("/// ");
                    }

                    docCommentsBuilder.AppendLine($"</remarks>");
                }

                memberDeclaration = memberDeclaration.WithLeadingTrivia(
                    ParseLeadingTrivia(docCommentsBuilder.ToString()));
            }

            return memberDeclaration;

            static void EmitLine(StringBuilder stringBuilder, string yamlDocSrc)
            {
                stringBuilder.Append(yamlDocSrc.Trim());
            }

            static void EmitDoc(string yamlDocSrc, StringBuilder docCommentsBuilder, Docs.ApiDetails? docs, string docsAnchor)
            {
                if (yamlDocSrc.Contains('\n'))
                {
                    docCommentsBuilder.AppendLine();
                    var docReader = new StringReader(yamlDocSrc);
                    string? paramDocLine;

                    bool inParagraph = false;
                    bool inComment = false;
                    int blankLineCounter = 0;
                    while ((paramDocLine = docReader.ReadLine()) is object)
                    {
                        if (string.IsNullOrWhiteSpace(paramDocLine))
                        {
                            if (++blankLineCounter >= 2 && inParagraph)
                            {
                                docCommentsBuilder.AppendLine("</para>");
                                inParagraph = false;
                                inComment = false;
                            }

                            continue;
                        }
                        else if (blankLineCounter > 0)
                        {
                            blankLineCounter = 0;
                        }
                        else
                        {
                            docCommentsBuilder.Append(' ');
                        }

                        if (inParagraph)
                        {
                            if (docCommentsBuilder.Length > 0 && docCommentsBuilder[docCommentsBuilder.Length - 1] != ' ')
                            {
                                docCommentsBuilder.Append(' ');
                            }
                        }
                        else
                        {
                            docCommentsBuilder.Append("/// <para>");
                            inParagraph = true;
                            inComment = true;
                        }

                        if (!inComment)
                        {
                            docCommentsBuilder.Append("/// ");
                        }

                        if (paramDocLine.IndexOf("<table", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<img", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<ul", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<ol", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("```", StringComparison.OrdinalIgnoreCase) >= 0 ||
                            paramDocLine.IndexOf("<<", StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            // We don't try to format tables, so truncate at this point.
                            if (inParagraph)
                            {
                                docCommentsBuilder.AppendLine("</para>");
                                inParagraph = false;
                                inComment = false;
                            }

                            docCommentsBuilder.AppendLine($@"/// <para>This doc was truncated.</para>");

                            break; // is this the right way?
                        }

                        EmitLine(docCommentsBuilder, paramDocLine);
                    }

                    if (inParagraph)
                    {
                        if (!inComment)
                        {
                            docCommentsBuilder.Append("/// ");
                        }

                        docCommentsBuilder.AppendLine("</para>");
                        inParagraph = false;
                        inComment = false;
                    }

                    if (docs is object)
                    {
                        docCommentsBuilder.AppendLine($@"/// <para><see href=""{docs.HelpLink}#{docsAnchor}"">Read more on docs.microsoft.com</see>.</para>");
                    }

                    docCommentsBuilder.Append("/// ");
                }
                else
                {
                    EmitLine(docCommentsBuilder, yamlDocSrc);
                }
            }
        }

        private static bool RequiresUnsafe(TypeSyntax? typeSyntax) => typeSyntax is PointerTypeSyntax || typeSyntax is FunctionPointerTypeSyntax;

        private static string GetClassNameForModule(string moduleName) =>
            moduleName.StartsWith("api-", StringComparison.Ordinal) || moduleName.StartsWith("ext-", StringComparison.Ordinal) ? "ApiSets" : moduleName.Replace('-', '_');

        private static AttributeSyntax FieldOffset(int offset) => FieldOffsetAttributeSyntax.AddArgumentListArguments(AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(offset))));

        private static AttributeSyntax StructLayout(TypeAttributes typeAttributes, TypeLayout layout)
        {
            LayoutKind layoutKind = (typeAttributes & TypeAttributes.ExplicitLayout) == TypeAttributes.ExplicitLayout ? LayoutKind.Explicit : LayoutKind.Sequential;
            var structLayoutAttribute = Attribute(IdentifierName("StructLayout")).AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(LayoutKind)),
                    IdentifierName(Enum.GetName(typeof(LayoutKind), layoutKind)!))));

            if (layout.PackingSize > 0)
            {
                structLayoutAttribute = structLayoutAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(layout.PackingSize)))
                        .WithNameEquals(NameEquals(nameof(StructLayoutAttribute.Pack))));
            }

            if (layout.Size > 0)
            {
                structLayoutAttribute = structLayoutAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(layout.Size)))
                        .WithNameEquals(NameEquals(nameof(StructLayoutAttribute.Size))));
            }

            return structLayoutAttribute;
        }

        private static AttributeSyntax GUID(Guid guid)
        {
            return Attribute(IdentifierName("Guid")).AddArgumentListArguments(
                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(guid.ToString().ToUpperInvariant()))));
        }

        private static AttributeSyntax InterfaceType(ComInterfaceType interfaceType)
        {
            return Attribute(IdentifierName("InterfaceType")).AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(ComInterfaceType)),
                    IdentifierName(Enum.GetName(typeof(ComInterfaceType), interfaceType)!))));
        }

        private static AttributeSyntax DllImport(MethodImport import, string moduleName, string? entrypoint)
        {
            var dllImportAttribute = Attribute(IdentifierName("DllImport")).AddArgumentListArguments(
                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(moduleName))),
                AttributeArgument(LiteralExpression(SyntaxKind.TrueLiteralExpression)).WithNameEquals(NameEquals(nameof(DllImportAttribute.ExactSpelling))));

            if (entrypoint is object)
            {
                dllImportAttribute = dllImportAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(entrypoint)))
                        .WithNameEquals(NameEquals(nameof(DllImportAttribute.EntryPoint))));
            }

            if ((import.Attributes & MethodImportAttributes.SetLastError) == MethodImportAttributes.SetLastError)
            {
                dllImportAttribute = dllImportAttribute.AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.TrueLiteralExpression))
                        .WithNameEquals(NameEquals(nameof(DllImportAttribute.SetLastError))));
            }

            return dllImportAttribute;
        }

        private static AttributeSyntax UnmanagedFunctionPointer(CallingConvention callingConvention)
        {
            return Attribute(IdentifierName(nameof(UnmanagedFunctionPointerAttribute)))
                .AddArgumentListArguments(AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(CallingConvention)),
                    IdentifierName(Enum.GetName(typeof(CallingConvention), callingConvention)!))));
        }

        [return: NotNullIfNotNull("marshalAs")]
        internal static AttributeSyntax? MarshalAs(MarshalAsAttribute? marshalAs)
        {
            if (marshalAs is null)
            {
                return null;
            }

            // TODO: fill in more properties to match the original
            return MarshalAs(marshalAs.Value);
        }

        private static AttributeSyntax MarshalAs(UnmanagedType unmanagedType)
        {
            return Attribute(IdentifierName("MarshalAs"))
                .AddArgumentListArguments(AttributeArgument(
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(nameof(UnmanagedType)),
                        IdentifierName(Enum.GetName(typeof(UnmanagedType), unmanagedType)!))));
        }

        private static AttributeSyntax DebuggerBrowsable(DebuggerBrowsableState state)
        {
            return Attribute(IdentifierName("DebuggerBrowsable"))
                .AddArgumentListArguments(
                AttributeArgument(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(DebuggerBrowsableState)),
                    IdentifierName(Enum.GetName(typeof(DebuggerBrowsableState), state)!))));
        }

        private static AttributeSyntax DebuggerDisplay(string format)
        {
            return Attribute(IdentifierName("DebuggerDisplay"))
                .AddArgumentListArguments(
                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(format))));
        }

        private static SyntaxToken SafeIdentifier(string name) => SafeIdentifierName(name).Identifier;

        private static IdentifierNameSyntax SafeIdentifierName(string name) => IdentifierName(CSharpKeywords.Contains(name) ? "@" + name : name);

        private static string GetHiddenFieldName(string fieldName) => $"__{fieldName}";

        private static CrefParameterListSyntax ToCref(ParameterListSyntax parameterList) => CrefParameterList().AddParameters(parameterList.Parameters.Select(ToCref).ToArray());

        private static CrefParameterSyntax ToCref(ParameterSyntax parameter)
            => CrefParameter(
                parameter.Modifiers.Any(SyntaxKind.InKeyword) ? Token(SyntaxKind.InKeyword) :
                parameter.Modifiers.Any(SyntaxKind.RefKeyword) ? Token(SyntaxKind.RefKeyword) :
                parameter.Modifiers.Any(SyntaxKind.OutKeyword) ? Token(SyntaxKind.OutKeyword) :
                default,
                parameter.Type!);

        internal static TypeSyntax MakeSpanOfT(TypeSyntax typeArgument) => GenericName("Span").AddTypeArgumentListArguments(typeArgument);

        internal static TypeSyntax MakeReadOnlySpanOfT(TypeSyntax typeArgument) => GenericName("ReadOnlySpan").AddTypeArgumentListArguments(typeArgument);

        private static FunctionPointerUnmanagedCallingConventionSyntax ToUnmanagedCallingConventionSyntax(CallingConvention callingConvention)
        {
            return callingConvention switch
            {
                CallingConvention.StdCall => FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall")),
                CallingConvention.Winapi => FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall")), // Winapi isn't a valid string, and only .NET 5 supports runtime-determined calling conventions like Winapi does.
                _ => throw new NotImplementedException(),
            };
        }

        private static bool IsVoid(TypeSyntax typeSyntax) => typeSyntax is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.VoidKeyword } };

        private static bool IsWideFunction(string methodName)
        {
            if (methodName.Length > 1 && methodName.EndsWith("W", StringComparison.Ordinal) && char.IsLower(methodName[methodName.Length - 2]))
            {
                // The name looks very much like an Wide-char method.
                // If further confidence is ever needed, we could look at the parameter and return types
                // to see if they have charset-related metadata in their marshaling metadata.
                return true;
            }

            return false;
        }

        private static bool IsAnsiFunction(string methodName)
        {
            if (methodName.Length > 1 && methodName.EndsWith("A", StringComparison.Ordinal) && char.IsLower(methodName[methodName.Length - 2]))
            {
                // The name looks very much like an Ansi method.
                // If further confidence is ever needed, we could look at the parameter and return types
                // to see if they have charset-related metadata in their marshaling metadata.
                return true;
            }

            return false;
        }

        private MemberDeclarationSyntax FetchTemplate(string name)
        {
            using Stream? templateStream = Assembly.GetExecutingAssembly().GetManifestResourceStream($"{ThisAssembly.RootNamespace}.templates.{name}");
            if (templateStream is null)
            {
                throw new KeyNotFoundException();
            }

            using StreamReader sr = new(templateStream);
            string template = sr.ReadToEnd();
            MemberDeclarationSyntax member = ParseMemberDeclaration(template) ?? throw new GenerationFailedException($"Unable to parse a type from a template: {name}");
            MemberDeclarationSyntax memberWithVisibility = this.ElevateVisibility(member);
            return memberWithVisibility;
        }

        private FunctionPointerTypeSyntax FunctionPointer(MethodDefinition methodDefinition, MethodSignature<TypeHandleInfo> signature, string delegateName)
        {
            FunctionPointerCallingConventionSyntax callingConventionSyntax = FunctionPointerCallingConvention(
                Token(SyntaxKind.UnmanagedKeyword),
                FunctionPointerUnmanagedCallingConventionList(SingletonSeparatedList(ToUnmanagedCallingConventionSyntax(CallingConvention.StdCall))));

            FunctionPointerParameterListSyntax parametersList = FunctionPointerParameterList();

            foreach (ParameterHandle parameterHandle in methodDefinition.GetParameters())
            {
                var parameter = this.mr.GetParameter(parameterHandle);
                if (parameter.SequenceNumber == 0)
                {
                    continue;
                }

                var parameterTypeInfo = signature.ParameterTypes[parameter.SequenceNumber - 1];
                var parameterType = parameterTypeInfo.ToTypeSyntax(this.functionPointerTypeSettings, parameter.GetCustomAttributes());
                parametersList = parametersList.AddParameters(this.TranslateDelegateToFunctionPointer(FunctionPointerParameter(parameterType.GetUnmarshaledType())));
            }

            var returnValue = signature.ReturnType.ToTypeSyntax(this.functionPointerTypeSettings, this.GetReturnTypeCustomAttributes(methodDefinition));
            parametersList = parametersList.AddParameters(this.TranslateDelegateToFunctionPointer(FunctionPointerParameter(returnValue.GetUnmarshaledType())));

            return FunctionPointerType(callingConventionSyntax, parametersList);
        }

        private FunctionPointerParameterSyntax TranslateDelegateToFunctionPointer(FunctionPointerParameterSyntax parameter)
        {
            if (this.IsDelegateReference(parameter.Type as IdentifierNameSyntax, out TypeDefinition delegateTypeDef))
            {
                return FunctionPointerParameter(this.FunctionPointer(delegateTypeDef));
            }
            else if (parameter.Type is PointerTypeSyntax { ElementType: IdentifierNameSyntax idName } && this.IsDelegateReference(idName, out TypeDefinition delegateTypeDef2))
            {
                return FunctionPointerParameter(PointerType(this.FunctionPointer(delegateTypeDef2)));
            }

            return parameter;
        }

        private bool TryGetRenamedMethod(string methodName, [NotNullWhen(true)] out string? newName)
        {
            if (this.WideCharOnly && IsWideFunction(methodName))
            {
                newName = methodName.Substring(0, methodName.Length - 1);
                return !this.methodsByName.ContainsKey(newName);
            }

            newName = null;
            return false;
        }

        private CustomAttributeHandleCollection? GetReturnTypeCustomAttributes(MethodDefinition methodDefinition)
        {
            CustomAttributeHandleCollection? returnTypeAttributes = null;
            foreach (ParameterHandle parameterHandle in methodDefinition.GetParameters())
            {
                var parameter = this.mr.GetParameter(parameterHandle);
                if (parameter.Name.IsNil)
                {
                    returnTypeAttributes = parameter.GetCustomAttributes();
                }

                // What we're looking for would always be the first element in the collection.
                break;
            }

            return returnTypeAttributes;
        }

        private bool IsCompilerGenerated(TypeDefinition typeDef)
        {
            bool isCompilerGenerated = false;
            foreach (CustomAttributeHandle attHandle in typeDef.GetCustomAttributes())
            {
                var att = this.mr.GetCustomAttribute(attHandle);
                if (this.IsAttribute(att, SystemRuntimeCompilerServices, nameof(CompilerGeneratedAttribute)))
                {
                    isCompilerGenerated = true;
                    break;
                }
            }

            return isCompilerGenerated;
        }

        private ISymbol? FindSymbolIfAlreadyAvailable(string fullyQualifiedMetadataName)
        {
            if (this.compilation is object)
            {
                if (this.compilation.Assembly.GetTypeByMetadataName(fullyQualifiedMetadataName) is { } ownSymbol)
                {
                    // This assembly defines it.
                    // But if it defines it as a partial, we should not consider it as fully defined so we populate our side.
                    return ownSymbol.DeclaringSyntaxReferences.Any(sr => sr.GetSyntax() is BaseTypeDeclarationSyntax type && type.Modifiers.Any(SyntaxKind.PartialKeyword))
                        ? null
                        : ownSymbol;
                }

                foreach (var reference in this.compilation.References)
                {
                    if (this.compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol referencedAssembly)
                    {
                        if (referencedAssembly.GetTypeByMetadataName(fullyQualifiedMetadataName) is { } externalSymbol)
                        {
                            if (this.compilation.IsSymbolAccessibleWithin(externalSymbol, this.compilation.Assembly))
                            {
                                // A referenced assembly declares this symbol and it is accessible to our own.
                                return externalSymbol;
                            }
                        }
                    }
                }
            }

            return null;
        }

        private MemberDeclarationSyntax? RequestInteropType(TypeDefinitionHandle typeDefHandle, NameSyntax? declaringType)
        {
            TypeDefinition typeDef = this.mr.GetTypeDefinition(typeDefHandle);
            if (this.IsCompilerGenerated(typeDef))
            {
                return null;
            }

            // Skip if the compilation already defines this type or can access it from elsewhere.
            string name = this.mr.GetString(typeDef.Name);
            string ns = this.mr.GetString(typeDef.Namespace);
            string fullyQualifiedName = this.Namespace + "." + name;
            if (this.FindSymbolIfAlreadyAvailable(fullyQualifiedName) is object)
            {
                // The type already exists either in this project or a referenced one.
                return null;
            }

            try
            {
                StringHandle baseTypeName, baseTypeNamespace;
                this.GetBaseTypeInfo(typeDef, out baseTypeName, out baseTypeNamespace);

                MemberDeclarationSyntax? typeDeclaration;

                if ((typeDef.Attributes & TypeAttributes.Interface) == TypeAttributes.Interface)
                {
                    typeDeclaration = this.DeclareInterface(typeDef);
                }
                else if (this.mr.StringComparer.Equals(baseTypeName, nameof(ValueType)) && this.mr.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    // Is this a special typedef struct?
                    if (this.IsTypeDefStruct(typeDef))
                    {
                        typeDeclaration = this.DeclareTypeDefStruct(typeDef);
                    }
                    else
                    {
                        StructDeclarationSyntax structDeclaration = this.DeclareStruct(typeDef);

                        // Proactively generate all nested types as well.
                        NameSyntax nestedDeclaringType = declaringType is null ? IdentifierName(name) : QualifiedName(declaringType, IdentifierName(name));
                        foreach (TypeDefinitionHandle nestedHandle in typeDef.GetNestedTypes())
                        {
                            if (this.RequestInteropType(nestedHandle, nestedDeclaringType) is { } nestedType)
                            {
                                structDeclaration = structDeclaration.AddMembers(nestedType);
                            }
                        }

                        typeDeclaration = structDeclaration;
                    }
                }
                else if (this.mr.StringComparer.Equals(baseTypeName, nameof(Enum)) && this.mr.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    // Consider reusing .NET types like FILE_SHARE_FLAGS -> System.IO.FileShare
                    typeDeclaration = this.DeclareEnum(typeDef);
                }
                else if (!this.options.ComInterop.StructsInsteadOfInterfaces && this.mr.StringComparer.Equals(baseTypeName, nameof(MulticastDelegate)) && this.mr.StringComparer.Equals(baseTypeNamespace, nameof(System)))
                {
                    typeDeclaration = this.DeclareDelegate(typeDef);
                }
                else
                {
                    // not yet supported.
                    return null;
                }

                return typeDeclaration;
            }
            catch (Exception ex)
            {
                throw new GenerationFailedException("Failed to generate " + this.mr.GetString(typeDef.Name), ex);
            }
        }

        internal void GetBaseTypeInfo(TypeDefinition typeDef, out StringHandle baseTypeName, out StringHandle baseTypeNamespace)
        {
            if (typeDef.BaseType.IsNil)
            {
                baseTypeName = default;
                baseTypeNamespace = default;
            }
            else
            {
                switch (typeDef.BaseType.Kind)
                {
                    case HandleKind.TypeReference:
                        TypeReference baseTypeRef = this.mr.GetTypeReference((TypeReferenceHandle)typeDef.BaseType);
                        baseTypeName = baseTypeRef.Name;
                        baseTypeNamespace = baseTypeRef.Namespace;
                        break;
                    case HandleKind.TypeDefinition:
                        TypeDefinition baseTypeDef = this.mr.GetTypeDefinition((TypeDefinitionHandle)typeDef.BaseType);
                        baseTypeName = baseTypeDef.Name;
                        baseTypeNamespace = baseTypeDef.Namespace;
                        break;
                    default:
                        throw new NotSupportedException("Unsupported base type handle: " + typeDef.BaseType.Kind);
                }
            }
        }

        internal MemberDeclarationSyntax? RequestTypeDefStruct(string specialName)
        {
            // Skip if the compilation already defines this type or can access it from elsewhere.
            string fullyQualifiedName = this.Namespace + "." + specialName;
            if (this.FindSymbolIfAlreadyAvailable(fullyQualifiedName) is object)
            {
                // The type already exists either in this project or a referenced one.
                return null;
            }

            if (!this.specialTypesGenerating.Add(specialName))
            {
                // Already generated.
                return null;
            }

            try
            {
                MemberDeclarationSyntax? specialDeclaration = null;
                switch (specialName)
                {
                    case "PCWSTR":
                        specialDeclaration = this.FetchTemplate($"{specialName}.cs");
                        this.TryGenerateType("PWSTR"); // the template references this type
                        break;
                    case "PCSTR":
                        specialDeclaration = this.FetchTemplate($"{specialName}.cs");
                        this.TryGenerateType("PSTR"); // the template references this type
                        break;
                    default:
                        throw new ArgumentException($"This special name is not recognized: \"{specialName}\".", nameof(specialName));
                }

                if (specialDeclaration is null)
                {
                    throw new GenerationFailedException("Failed to parse template.");
                }

                this.specialTypes.Add(specialName, specialDeclaration);
                return specialDeclaration;
            }
            catch (Exception ex)
            {
                throw new GenerationFailedException("Failed to generate " + specialName, ex);
            }
        }

        internal CustomAttribute? FindNativeArrayInfoAttribute(CustomAttributeHandleCollection customAttributeHandles)
        {
            foreach (var handle in customAttributeHandles)
            {
                CustomAttribute att = this.mr.GetCustomAttribute(handle);
                if (this.IsAttribute(att, InteropDecorationNamespace, NativeArrayInfoAttribute))
                {
                    return att;
                }
            }

            return null;
        }

        private bool IsTypeDefStruct(TypeDefinition typeDef) => typeDef.GetCustomAttributes().Any(att => this.IsAttribute(this.mr.GetCustomAttribute(att), InteropDecorationNamespace, NativeTypedefAttribute));

        private void DeclareExternMethod(MethodDefinitionHandle methodDefinitionHandle)
        {
            MethodDefinition methodDefinition = this.mr.GetMethodDefinition(methodDefinitionHandle);
            MethodImport import = methodDefinition.GetImport();
            if (import.Name.IsNil)
            {
                // Not an exported method.
                return;
            }

            var methodName = this.mr.GetString(methodDefinition.Name);
            try
            {
                if (this.WideCharOnly && IsAnsiFunction(methodName))
                {
                    // Skip Ansi functions.
                    return;
                }

                var moduleName = this.GetNormalizedModuleName(import);

                if (false && !CanonicalCapitalizations.Contains(moduleName))
                {
                    // Skip methods for modules we are not prepared to export.
                    return;
                }

                string? entrypoint = null;
                if (this.TryGetRenamedMethod(methodName, out string? newName))
                {
                    entrypoint = methodName;
                    methodName = newName;
                }

                // If this method releases a handle, recreate the method signature such that we take the struct rather than the SafeHandle as a parameter.
                TypeSyntaxSettings typeSettings = this.releaseMethods.Contains(entrypoint ?? methodName) ? this.externReleaseSignatureTypeSettings : this.externSignatureTypeSettings;
                MethodSignature<TypeHandleInfo> signature = methodDefinition.DecodeSignature(SignatureHandleProvider.Instance, null);

                CustomAttributeHandleCollection? returnTypeAttributes = this.GetReturnTypeCustomAttributes(methodDefinition);
                var returnType = signature.ReturnType.ToTypeSyntax(typeSettings, returnTypeAttributes, ParameterAttributes.Out);

                MethodDeclarationSyntax methodDeclaration = MethodDeclaration(
                    List<AttributeListSyntax>()
                        .Add(AttributeList().AddAttributes(DllImport(import, moduleName, entrypoint)))
                        .Add(DefaultDllImportSearchPathsAttributeList),
                    modifiers: TokenList(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ExternKeyword)),
                    returnType.Type,
                    explicitInterfaceSpecifier: null!,
                    SafeIdentifier(methodName),
                    null!,
                    this.CreateParameterList(methodDefinition, signature, typeSettings),
                    List<TypeParameterConstraintClauseSyntax>(),
                    body: null!,
                    Token(SyntaxKind.SemicolonToken));
                methodDeclaration = returnType.AddReturnMarshalAs(methodDeclaration);

                // Add documentation if we can find it.
                methodDeclaration = AddApiDocumentation(entrypoint ?? methodName, methodDeclaration);

                List<MemberDeclarationSyntax> methodsList = this.GetModuleMemberList(moduleName);
                if (RequiresUnsafe(methodDeclaration.ReturnType) || methodDeclaration.ParameterList.Parameters.Any(p => RequiresUnsafe(p.Type)))
                {
                    methodDeclaration = methodDeclaration.AddModifiers(Token(SyntaxKind.UnsafeKeyword));
                }

                methodsList.AddRange(this.DeclareFriendlyOverloads(methodDefinition, methodDeclaration, this.GroupByModule ? GetClassNameForModule(moduleName) : this.SingleClassName, FriendlyOverloadOf.ExternMethod));

                methodsList.Add(methodDeclaration);
            }
            catch (Exception ex)
            {
                throw new GenerationFailedException($"Failed while generating extern method: {methodName}", ex);
            }
        }

        private FieldDeclarationSyntax DeclareField(FieldDefinitionHandle fieldDefHandle)
        {
            FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
            string name = this.mr.GetString(fieldDef.Name);
            try
            {
                TypeHandleInfo fieldTypeInfo = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null);
                var customAttributes = fieldDef.GetCustomAttributes();
                var fieldType = fieldTypeInfo.ToTypeSyntax(this.fieldTypeSettings, customAttributes);
                Constant constant = this.mr.GetConstant(fieldDef.GetDefaultValue());
                ExpressionSyntax value = this.ToExpressionSyntax(constant);
                if (fieldType.Type is not PredefinedTypeSyntax)
                {
                    if (fieldType.Type is IdentifierNameSyntax { Identifier: { ValueText: string typeName } } && this.TryGetHandleReleaseMethod(typeName, out _))
                    {
                        // Cast to IntPtr first, then the actual handle struct.
                        value = CastExpression(fieldType.Type, CastExpression(IntPtrTypeSyntax, ParenthesizedExpression(value)));
                    }
                    else
                    {
                        value = CastExpression(fieldType.Type, ParenthesizedExpression(value));
                    }
                }

                var modifiers = TokenList(Token(this.Visibility));
                if (this.IsTypeDefStruct(fieldType.Type as IdentifierNameSyntax))
                {
                    modifiers = modifiers.Add(Token(SyntaxKind.StaticKeyword)).Add(Token(SyntaxKind.ReadOnlyKeyword));
                }
                else
                {
                    modifiers = modifiers.Add(Token(SyntaxKind.ConstKeyword));
                }

                var result = FieldDeclaration(VariableDeclaration(fieldType.Type).AddVariables(
                    VariableDeclarator(name).WithInitializer(EqualsValueClause(value))))
                    .WithModifiers(modifiers);
                result = fieldType.AddMarshalAs(result);
                return result;
            }
            catch (Exception ex)
            {
                TypeDefinition typeDef = this.mr.GetTypeDefinition(fieldDef.GetDeclaringType());
                string typeName = this.mr.GetString(typeDef.Name);
                string? ns = this.mr.GetString(typeDef.Namespace);
                throw new GenerationFailedException($"Failed creating field: {ns}.{typeName}.{name}", ex);
            }
        }

        private ClassDeclarationSyntax DeclareConstantDefiningClass()
        {
            return ClassDeclaration(ConstantsClassName.Identifier)
                .AddMembers(this.fieldsToSyntax.Values.ToArray())
                .WithModifiers(TokenList(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword)));
        }

        private ClassDeclarationSyntax DeclareInlineArrayIndexerExtensionsClass()
        {
            return ClassDeclaration(InlineArrayIndexerExtensionsClassName.Identifier)
                .AddMembers(this.inlineArrayIndexerExtensionsMembers.ToArray())
                .WithModifiers(TokenList(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword)));
        }

        private ClassDeclarationSyntax DeclareComInterfaceFriendlyExtensionsClass()
        {
            return ClassDeclaration(ComInterfaceFriendlyExtensionsClassName.Identifier)
                .AddMembers(this.comInterfaceFriendlyExtensionsMembers.ToArray())
                .WithModifiers(TokenList(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword)));
        }

        /// <summary>
        /// Attempts to translate a <see cref="TypeReferenceHandle"/> to a <see cref="TypeDefinitionHandle"/>.
        /// </summary>
        /// <param name="typeRefHandle">The reference handle.</param>
        /// <param name="typeDefHandle">Receives the type def handle, if one was discovered.</param>
        /// <returns><see langword="true"/> if a TypeDefinition was found; otherwise <see langword="false"/>.</returns>
        internal bool TryGetTypeDefHandle(TypeReferenceHandle typeRefHandle, out TypeDefinitionHandle typeDefHandle)
        {
            if (this.refToDefCache.TryGetValue(typeRefHandle, out typeDefHandle))
            {
                return !typeDefHandle.IsNil;
            }

            var typeRef = this.mr.GetTypeReference(typeRefHandle);

            // PERF: check that the ResolutionScope is Module before proceeding.
            foreach (TypeDefinitionHandle tdh in this.mr.TypeDefinitions)
            {
                TypeDefinition typeDef = this.mr.GetTypeDefinition(tdh);
                if (typeDef.Name == typeRef.Name && typeDef.Namespace == typeRef.Namespace)
                {
                    if (typeRef.ResolutionScope.Kind == HandleKind.TypeReference)
                    {
                        // The ref is nested. Verify that the type we found is nested in the same type as well.
                        if (this.TryGetTypeDefHandle((TypeReferenceHandle)typeRef.ResolutionScope, out TypeDefinitionHandle nestingTypeDef) && nestingTypeDef == typeDef.GetDeclaringType())
                        {
                            typeDefHandle = tdh;
                            break;
                        }
                    }
                    else if (typeRef.ResolutionScope.Kind == HandleKind.ModuleDefinition && typeDef.GetDeclaringType().IsNil)
                    {
                        typeDefHandle = tdh;
                        break;
                    }
                    else
                    {
                        throw new NotSupportedException("Unrecognized ResolutionScope: " + typeRef.ResolutionScope);
                    }
                }
            }

            this.refToDefCache.Add(typeRefHandle, typeDefHandle);
            return !typeDefHandle.IsNil;
        }

        private bool TryGetTypeDefHandle(TypeSyntax typeSyntax, out TypeDefinitionHandle typeDefHandle)
        {
            string typeName = typeSyntax.ToString();
            return this.typesByName.TryGetValue(typeName, out typeDefHandle);
        }

        /// <summary>
        /// Generates a type to represent a COM interface.
        /// </summary>
        /// <param name="typeDef">The type definition of the interface.</param>
        /// <returns>The type declaration.</returns>
        /// <remarks>
        /// COM interfaces are represented as structs in order to maintain the "unmanaged type" trait
        /// so that all structs are blittable.
        /// </remarks>
        private TypeDeclarationSyntax? DeclareInterface(TypeDefinition typeDef)
        {
            IdentifierNameSyntax ifaceName = IdentifierName(this.mr.GetString(typeDef.Name));

            Stack<TypeDefinitionHandle> baseTypes = new Stack<TypeDefinitionHandle>();
            InterfaceImplementationHandle baseTypeHandle = typeDef.GetInterfaceImplementations().SingleOrDefault();
            while (!baseTypeHandle.IsNil)
            {
                InterfaceImplementation baseTypeImpl = this.mr.GetInterfaceImplementation(baseTypeHandle);
                if (!this.TryGetTypeDefHandle((TypeReferenceHandle)baseTypeImpl.Interface, out TypeDefinitionHandle baseTypeDefHandle))
                {
                    throw new GenerationFailedException("Failed to find base type.");
                }

                baseTypes.Push(baseTypeDefHandle);
                TypeDefinition baseType = this.mr.GetTypeDefinition(baseTypeDefHandle);
                baseTypeHandle = baseType.GetInterfaceImplementations().SingleOrDefault();
            }

            return this.options.ComInterop.StructsInsteadOfInterfaces
                ? this.DeclareInterfaceAsStruct(typeDef, ifaceName, baseTypes)
                : this.DeclareInterfaceAsInterface(typeDef, ifaceName, baseTypes);
        }

        private TypeDeclarationSyntax DeclareInterfaceAsStruct(TypeDefinition typeDef, IdentifierNameSyntax ifaceName, Stack<TypeDefinitionHandle> baseTypes)
        {
            IdentifierNameSyntax vtblFieldName = IdentifierName("lpVtbl");
            var members = new List<MemberDeclarationSyntax>();
            var vtblMembers = new List<MemberDeclarationSyntax>();
            TypeSyntaxSettings typeSettings = this.comSignatureTypeSettings;

            // It is imperative that we generate methods for all base interfaces as well, ahead of any implemented by *this* interface.
            var allMethods = new List<MethodDefinitionHandle>();
            while (baseTypes.Count > 0)
            {
                TypeDefinition baseType = this.mr.GetTypeDefinition(baseTypes.Pop());
                allMethods.AddRange(baseType.GetMethods());
            }

            allMethods.AddRange(typeDef.GetMethods());
            int methodCounter = 0;
            foreach (MethodDefinitionHandle methodDefHandle in allMethods)
            {
                methodCounter++;
                var methodDefinition = this.mr.GetMethodDefinition(methodDefHandle);
                string methodName = this.mr.GetString(methodDefinition.Name);
                IdentifierNameSyntax innerMethodName = IdentifierName($"{methodName}_{methodCounter}");

                MethodSignature<TypeHandleInfo> signature = methodDefinition.DecodeSignature(SignatureHandleProvider.Instance, null);
                CustomAttributeHandleCollection? returnTypeAttributes = this.GetReturnTypeCustomAttributes(methodDefinition);
                var returnType = signature.ReturnType.ToTypeSyntax(typeSettings, returnTypeAttributes);

                ParameterListSyntax parameterList = this.CreateParameterList(methodDefinition, signature, typeSettings);
                FunctionPointerParameterListSyntax funcPtrParameters = FunctionPointerParameterList()
                    .AddParameters(FunctionPointerParameter(PointerType(ifaceName)))
                    .AddParameters(parameterList.Parameters.Select(p => FunctionPointerParameter(p.Type!).WithModifiers(p.Modifiers)).ToArray())
                    .AddParameters(FunctionPointerParameter(returnType.Type));

                FieldDeclarationSyntax vtblFunctionPtr = FieldDeclaration(
                    VariableDeclaration(
                        FunctionPointerType().WithCallingConvention(FunctionPointerCallingConvention(Token(SyntaxKind.UnmanagedKeyword))
                            .WithUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionList(
                                SingletonSeparatedList(FunctionPointerUnmanagedCallingConvention(Identifier("Stdcall"))))))
                        .WithParameterList(funcPtrParameters))
                    .WithVariables(SingletonSeparatedList(VariableDeclarator(innerMethodName.Identifier))))
                    .WithModifiers(TokenList(Token(SyntaxKind.InternalKeyword)));
                vtblMembers.Add(vtblFunctionPtr);

                IdentifierNameSyntax pThisLocal = IdentifierName("pThis");
                InvocationExpressionSyntax vtblInvocation = InvocationExpression(MemberAccessExpression(SyntaxKind.PointerMemberAccessExpression, vtblFieldName, innerMethodName))
                    .AddArgumentListArguments(Argument(pThisLocal))
                    .AddArgumentListArguments(parameterList.Parameters.Select(p => Argument(IdentifierName(p.Identifier.ValueText)).WithRefKindKeyword(p.Modifiers.Count > 0 ? p.Modifiers[0] : default)).ToArray());
                StatementSyntax vtblInvocationStatement = IsVoid(returnType.Type)
                    ? ExpressionStatement(vtblInvocation)
                    : ReturnStatement(vtblInvocation);
                var body = Block().AddStatements(
                    FixedStatement(
                        VariableDeclaration(PointerType(ifaceName)).AddVariables(
                            VariableDeclarator(pThisLocal.Identifier).WithInitializer(EqualsValueClause(PrefixUnaryExpression(SyntaxKind.AddressOfExpression, ThisExpression())))),
                        vtblInvocationStatement));

                MethodDeclarationSyntax methodDeclaration = MethodDeclaration(
                    List<AttributeListSyntax>(),
                    modifiers: TokenList(Token(this.Visibility)),
                    returnType.Type,
                    explicitInterfaceSpecifier: null!,
                    SafeIdentifier(methodName),
                    null!,
                    parameterList,
                    List<TypeParameterConstraintClauseSyntax>(),
                    body: body,
                    semicolonToken: default);
                methodDeclaration = returnType.AddReturnMarshalAs(methodDeclaration);

                if (methodName == nameof(object.GetType) && parameterList.Parameters.Count == 0)
                {
                    methodDeclaration = methodDeclaration.AddModifiers(Token(SyntaxKind.NewKeyword));
                }

                if (methodDeclaration.ReturnType is PointerTypeSyntax || methodDeclaration.ParameterList.Parameters.Any(p => p.Type is PointerTypeSyntax))
                {
                    methodDeclaration = methodDeclaration.AddModifiers(Token(SyntaxKind.UnsafeKeyword));
                }

                // Add documentation if we can find it.
                methodDeclaration = AddApiDocumentation($"{ifaceName}.{methodName}", methodDeclaration);

                members.AddRange(this.DeclareFriendlyOverloads(methodDefinition, methodDeclaration, ifaceName.Identifier.ValueText, FriendlyOverloadOf.StructMethod));
                members.Add(methodDeclaration);
            }

            var vtblStruct = StructDeclaration("Vtbl")
                .AddMembers(vtblMembers.ToArray())
                .AddModifiers(Token(SyntaxKind.PrivateKeyword));
            members.Add(vtblStruct);

            // private Vtbl* lpVtbl;
            members.Add(FieldDeclaration(VariableDeclaration(PointerType(IdentifierName(vtblStruct.Identifier))).AddVariables(VariableDeclarator(vtblFieldName.Identifier))).AddModifiers(Token(SyntaxKind.PrivateKeyword)));

            StructDeclarationSyntax iface = StructDeclaration(ifaceName.Identifier)
                .AddAttributeLists(AttributeList().AddAttributes(GUID(this.FindGuidFromAttribute(typeDef))))
                .AddModifiers(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword))
                .AddMembers(members.ToArray());

            return iface;
        }

        private TypeDeclarationSyntax? DeclareInterfaceAsInterface(TypeDefinition typeDef, IdentifierNameSyntax ifaceName, Stack<TypeDefinitionHandle> baseTypes)
        {
            if (ifaceName.Identifier.ValueText is "IUnknown" or "IDispatch")
            {
                // We do not generate interfaces for these COM base types.
                return null;
            }

            TypeSyntaxSettings typeSettings = this.comSignatureTypeSettings;

            // It is imperative that we generate methods for all base interfaces as well, ahead of any implemented by *this* interface.
            AttributeSyntax? ifaceType = null;
            var allMethods = new List<MethodDefinitionHandle>();
            var baseTypeSyntaxList = new List<BaseTypeSyntax>();
            while (baseTypes.Count > 0)
            {
                TypeDefinitionHandle baseTypeHandle = baseTypes.Pop();
                TypeDefinition baseType = this.mr.GetTypeDefinition(baseTypeHandle);
                if (ifaceType is null)
                {
                    ifaceType = InterfaceType(
                        this.mr.StringComparer.Equals(baseType.Name, "IUnknown") ? ComInterfaceType.InterfaceIsIUnknown :
                        this.mr.StringComparer.Equals(baseType.Name, "IDispatch") ? ComInterfaceType.InterfaceIsIDispatch :
                        throw new NotSupportedException("Unsupported base COM interface type: " + this.mr.GetString(baseType.Name)));
                }
                else
                {
                    this.RequestInteropType(baseTypeHandle);
                    baseTypeSyntaxList.Add(SimpleBaseType(new HandleTypeHandleInfo(this.mr, baseTypeHandle).ToTypeSyntax(this.generalTypeSettings, null).Type));
                    allMethods.AddRange(baseType.GetMethods());
                }
            }

            int inheritedMethods = allMethods.Count;
            allMethods.AddRange(typeDef.GetMethods());

            if (ifaceType is null)
            {
                throw new NotSupportedException("No COM interface base type found.");
            }

            var members = new List<MemberDeclarationSyntax>();

            foreach (MethodDefinitionHandle methodDefHandle in allMethods)
            {
                var methodDefinition = this.mr.GetMethodDefinition(methodDefHandle);
                string methodName = this.mr.GetString(methodDefinition.Name);
                try
                {
                    IdentifierNameSyntax innerMethodName = IdentifierName(methodName);
                    MethodSignature<TypeHandleInfo> signature = methodDefinition.DecodeSignature(SignatureHandleProvider.Instance, null);

                    CustomAttributeHandleCollection? returnTypeAttributes = this.GetReturnTypeCustomAttributes(methodDefinition);
                    var (returnType, marshalAs) = signature.ReturnType.ToTypeSyntax(typeSettings, returnTypeAttributes);
                    AttributeSyntax? returnsAttribute = MarshalAs(marshalAs);

                    bool preserveSig = returnType is not IdentifierNameSyntax { Identifier: { ValueText: "HRESULT" } }
                        || this.options.ComInterop.PreserveSigMethods.Contains($"{ifaceName}.{methodName}")
                        || this.options.ComInterop.PreserveSigMethods.Contains(ifaceName.ToString());

                    var parameterList = this.CreateParameterList(methodDefinition, signature, this.comSignatureTypeSettings);

                    if (!preserveSig)
                    {
                        ParameterSyntax? lastParameter = parameterList.Parameters.Count > 0 ? parameterList.Parameters[parameterList.Parameters.Count - 1] : null;
                        if (lastParameter?.HasAnnotation(IsRetValAnnotation) is true)
                        {
                            // Move the retval parameter to the return value position.
                            parameterList = parameterList.WithParameters(parameterList.Parameters.RemoveAt(parameterList.Parameters.Count - 1));
                            returnType = lastParameter.Modifiers.Any(SyntaxKind.OutKeyword) ? lastParameter.Type! : ((PointerTypeSyntax)lastParameter.Type!).ElementType;
                            returnsAttribute = lastParameter.DescendantNodes().OfType<AttributeSyntax>().FirstOrDefault(att => att.Name.ToString() == "MarshalAs");
                        }
                        else
                        {
                            // Remove the return type
                            returnType = PredefinedType(Token(SyntaxKind.VoidKeyword));
                        }
                    }

                    MethodDeclarationSyntax methodDeclaration = MethodDeclaration(returnType, SafeIdentifier(methodName))
                        .WithParameterList(parameterList)
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
                    if (returnsAttribute is object)
                    {
                        methodDeclaration = methodDeclaration.AddAttributeLists(
                            AttributeList().WithTarget(AttributeTargetSpecifier(Token(SyntaxKind.ReturnKeyword))).AddAttributes(returnsAttribute));
                    }

                    if (preserveSig)
                    {
                        methodDeclaration = methodDeclaration.AddAttributeLists(AttributeList().AddAttributes(PreserveSigAttribute));
                    }

                    if (inheritedMethods-- > 0)
                    {
                        methodDeclaration = methodDeclaration.AddModifiers(Token(SyntaxKind.NewKeyword));
                    }

                    if (methodDeclaration.ReturnType is PointerTypeSyntax || methodDeclaration.ParameterList.Parameters.Any(p => p.Type is PointerTypeSyntax))
                    {
                        methodDeclaration = methodDeclaration.AddModifiers(Token(SyntaxKind.UnsafeKeyword));
                    }

                    // Add documentation if we can find it.
                    methodDeclaration = AddApiDocumentation($"{ifaceName}.{methodName}", methodDeclaration);
                    members.Add(methodDeclaration);

                    var atThis = IdentifierName("@this");
                    this.comInterfaceFriendlyExtensionsMembers.AddRange(
                        this.DeclareFriendlyOverloads(methodDefinition, methodDeclaration, ifaceName.Identifier.ValueText, FriendlyOverloadOf.InterfaceMethod));
                }
                catch (Exception ex)
                {
                    throw new GenerationFailedException($"Failed while generating the method: {methodName}", ex);
                }
            }

            Guid guid = this.FindGuidFromAttribute(typeDef);
            InterfaceDeclarationSyntax ifaceDeclaration = InterfaceDeclaration(ifaceName.Identifier)
                .AddAttributeLists(AttributeList().AddAttributes(GUID(guid), ifaceType))
                .AddModifiers(Token(this.Visibility))
                .AddMembers(members.ToArray());

            if (baseTypeSyntaxList.Count > 0)
            {
                ifaceDeclaration = ifaceDeclaration
                    .AddBaseListTypes(baseTypeSyntaxList.ToArray());
            }

            return ifaceDeclaration;
        }

        private Guid FindGuidFromAttribute(TypeDefinition typeDef)
        {
            Guid guid = Guid.Empty;
            foreach (CustomAttributeHandle attHandle in typeDef.GetCustomAttributes())
            {
                CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                if (this.IsAttribute(att, InteropDecorationNamespace, nameof(GuidAttribute)))
                {
                    CustomAttributeValue<TypeSyntax> args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                    guid = new Guid(
                        (uint)args.FixedArguments[0].Value!,
                        (ushort)args.FixedArguments[1].Value!,
                        (ushort)args.FixedArguments[2].Value!,
                        (byte)args.FixedArguments[3].Value!,
                        (byte)args.FixedArguments[4].Value!,
                        (byte)args.FixedArguments[5].Value!,
                        (byte)args.FixedArguments[6].Value!,
                        (byte)args.FixedArguments[7].Value!,
                        (byte)args.FixedArguments[8].Value!,
                        (byte)args.FixedArguments[9].Value!,
                        (byte)args.FixedArguments[10].Value!);
                }
            }

            return guid;
        }

        private DelegateDeclarationSyntax DeclareDelegate(TypeDefinition typeDef)
        {
            if (this.options.ComInterop.StructsInsteadOfInterfaces)
            {
                throw new NotSupportedException("Delegates are not declared while in all-structs mode.");
            }

            string name = this.mr.GetString(typeDef.Name);
            TypeSyntaxSettings typeSettings = this.delegateSignatureTypeSettings;

            CallingConvention? callingConvention = null;
            foreach (CustomAttributeHandle handle in typeDef.GetCustomAttributes())
            {
                var att = this.mr.GetCustomAttribute(handle);
                if (this.IsAttribute(att, SystemRuntimeInteropServices, nameof(UnmanagedFunctionPointerAttribute)))
                {
                    var args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                    callingConvention = (CallingConvention)(int)args.FixedArguments[0].Value!;
                }
            }

            this.GetSignatureForDelegate(typeDef, out MethodDefinition invokeMethodDef, out MethodSignature<TypeHandleInfo> signature, out CustomAttributeHandleCollection? returnTypeAttributes);
            var returnValue = signature.ReturnType.ToTypeSyntax(typeSettings, returnTypeAttributes);

            DelegateDeclarationSyntax result = DelegateDeclaration(returnValue.Type, name)
                .WithParameterList(this.CreateParameterList(invokeMethodDef, signature, typeSettings))
                .AddModifiers(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword));
            result = returnValue.AddReturnMarshalAs(result);

            if (callingConvention.HasValue)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(UnmanagedFunctionPointer(callingConvention.Value)));
            }

            return result;
        }

        private void GetSignatureForDelegate(TypeDefinition typeDef, out MethodDefinition invokeMethodDef, out MethodSignature<TypeHandleInfo> signature, out CustomAttributeHandleCollection? returnTypeAttributes)
        {
            invokeMethodDef = typeDef.GetMethods().Select(this.mr.GetMethodDefinition).Single(def => this.mr.StringComparer.Equals(def.Name, "Invoke"));
            signature = invokeMethodDef.DecodeSignature(SignatureHandleProvider.Instance, null);
            returnTypeAttributes = this.GetReturnTypeCustomAttributes(invokeMethodDef);
        }

        private StructDeclarationSyntax DeclareStruct(TypeDefinition typeDef)
        {
            IdentifierNameSyntax name = IdentifierName(this.mr.GetString(typeDef.Name));
            TypeSyntaxSettings typeSettings = this.fieldTypeSettings;

            var members = new List<MemberDeclarationSyntax>();
            SyntaxList<MemberDeclarationSyntax> additionalMembers;
            foreach (FieldDefinitionHandle fieldDefHandle in typeDef.GetFields())
            {
                FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
                string fieldName = this.mr.GetString(fieldDef.Name);

                try
                {
                    CustomAttribute? fixedBufferAttribute = null;
                    foreach (CustomAttributeHandle attHandle in fieldDef.GetCustomAttributes())
                    {
                        CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                        if (this.IsAttribute(att, SystemRuntimeCompilerServices, nameof(FixedBufferAttribute)))
                        {
                            fixedBufferAttribute = att;
                            break;
                        }
                    }

                    FieldDeclarationSyntax field;
                    VariableDeclaratorSyntax fieldDeclarator = VariableDeclarator(SafeIdentifier(fieldName));
                    if (fixedBufferAttribute.HasValue)
                    {
                        CustomAttributeValue<TypeSyntax> attributeArgs = fixedBufferAttribute.Value.DecodeValue(CustomAttributeTypeProvider.Instance);
                        TypeSyntax fieldType = (TypeSyntax)attributeArgs.FixedArguments[0].Value!;
                        ExpressionSyntax size = LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal((int)attributeArgs.FixedArguments[1].Value!));
                        field = FieldDeclaration(
                            VariableDeclaration(fieldType))
                            .AddDeclarationVariables(
                                fieldDeclarator
                                    .WithArgumentList(BracketedArgumentList(SingletonSeparatedList(Argument(size)))))
                            .AddModifiers(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword), Token(SyntaxKind.FixedKeyword));
                    }
                    else
                    {
                        CustomAttributeHandleCollection fieldAttributes = fieldDef.GetCustomAttributes();
                        TypeHandleInfo fieldTypeInfo = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null);
                        TypeSyntaxAndMarshaling fieldTypeSyntax = fieldTypeInfo.ToTypeSyntax(typeSettings, fieldAttributes);
                        var fieldInfo = this.ReinterpretFieldType(fieldDef, fieldDeclarator.Identifier.ValueText, fieldTypeSyntax.Type, fieldAttributes);
                        additionalMembers = additionalMembers.AddRange(fieldInfo.AdditionalMembers);

                        field = FieldDeclaration(VariableDeclaration(fieldInfo.FieldType).AddVariables(fieldDeclarator))
                            .AddModifiers(Token(this.Visibility));

                        if (fieldInfo.FieldType is PointerTypeSyntax || fieldInfo.FieldType is FunctionPointerTypeSyntax)
                        {
                            field = field.AddModifiers(Token(SyntaxKind.UnsafeKeyword));
                        }

                        if (ObjectMembers.Contains(fieldName))
                        {
                            field = field.AddModifiers(Token(SyntaxKind.NewKeyword));
                        }
                    }

                    int offset = fieldDef.GetOffset();
                    if (offset >= 0)
                    {
                        field = field.AddAttributeLists(AttributeList().AddAttributes(FieldOffset(offset)));
                    }

                    members.Add(field);
                }
                catch (Exception ex)
                {
                    throw new GenerationFailedException("Failed while generating field: " + fieldName, ex);
                }
            }

            // Add the additional members, taking care to not introduce redundant declarations.
            members.AddRange(additionalMembers.Where(c => c is not StructDeclarationSyntax cs || !members.OfType<StructDeclarationSyntax>().Any(m => m.Identifier.ValueText == cs.Identifier.ValueText)));

            StructDeclarationSyntax result = StructDeclaration(name.Identifier)
                .AddMembers(members.ToArray())
                .WithModifiers(TokenList(Token(this.Visibility), Token(SyntaxKind.PartialKeyword)));

            TypeLayout layout = typeDef.GetLayout();
            if (!layout.IsDefault || (typeDef.Attributes & TypeAttributes.ExplicitLayout) == TypeAttributes.ExplicitLayout)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(StructLayout(typeDef.Attributes, layout)));
            }

            Guid guid = this.FindGuidFromAttribute(typeDef);
            if (guid != Guid.Empty)
            {
                result = result.AddAttributeLists(AttributeList().AddAttributes(GUID(guid)));
            }

            result = AddApiDocumentation(name.Identifier.ValueText, result);

            return result;
        }

        /// <summary>
        /// Creates a struct that emulates a typedef in the C language headers.
        /// </summary>
        private StructDeclarationSyntax DeclareTypeDefStruct(TypeDefinition typeDef)
        {
            IdentifierNameSyntax name = IdentifierName(this.mr.GetString(typeDef.Name));
            if (name.Identifier.ValueText == "BOOL")
            {
                return this.DeclareTypeDefBOOLStruct(typeDef);
            }

            bool isHandle = false;
            foreach (CustomAttributeHandle attHandle in typeDef.GetCustomAttributes())
            {
                CustomAttribute att = this.mr.GetCustomAttribute(attHandle);

                // If this struct represents a handle, generate the SafeHandle-equivalent.
                if (this.IsAttribute(att, InteropDecorationNamespace, RAIIFreeAttribute))
                {
                    var args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                    if (args.FixedArguments[0].Value is string freeMethodName)
                    {
                        ////this.GenerateSafeHandle(freeMethodName);
                        this.TryGenerateExternMethod(freeMethodName);
                        isHandle = true;
                    }

                    break;
                }
            }

            TypeSyntaxSettings typeSettings = isHandle ? this.fieldOfHandleTypeDefTypeSettings : this.fieldTypeSettings;

            FieldDefinition fieldDef = this.mr.GetFieldDefinition(typeDef.GetFields().Single());
            string fieldName = this.mr.GetString(fieldDef.Name);
            IdentifierNameSyntax fieldIdentifierName = SafeIdentifierName(fieldName);
            VariableDeclaratorSyntax fieldDeclarator = VariableDeclarator(fieldIdentifierName.Identifier);
            var fieldAttributes = fieldDef.GetCustomAttributes();
            var fieldType = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null).ToTypeSyntax(typeSettings, fieldAttributes);
            (TypeSyntax FieldType, SyntaxList<MemberDeclarationSyntax> AdditionalMembers) fieldInfo =
                this.ReinterpretFieldType(fieldDef, fieldDeclarator.Identifier.ValueText, fieldType.Type, fieldAttributes);
            SyntaxList<MemberDeclarationSyntax> members = List<MemberDeclarationSyntax>();

            FieldDeclarationSyntax fieldSyntax = FieldDeclaration(
                VariableDeclaration(fieldInfo.FieldType).AddVariables(fieldDeclarator))
                .AddModifiers(Token(this.Visibility), Token(SyntaxKind.ReadOnlyKeyword));
            members = members.Add(fieldSyntax);

            // Add constructor
            IdentifierNameSyntax valueParameter = IdentifierName("value");
            MemberAccessExpressionSyntax fieldAccessExpression = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), fieldIdentifierName);
            members = members.Add(ConstructorDeclaration(name.Identifier)
                .AddModifiers(Token(this.Visibility))
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(fieldInfo.FieldType))
                .WithExpressionBody(ArrowExpressionClause(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, fieldAccessExpression, valueParameter)))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            // public static implicit operator int(HWND value) => value.Value;
            members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), fieldInfo.FieldType)
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(name))
                .WithExpressionBody(ArrowExpressionClause(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, fieldIdentifierName)))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            // public static explicit operator HWND(int value) => new HWND(value);
            // Except make converting char* or byte* to typedefs representing strings implicit.
            SyntaxToken explicitOrImplicitModifier = Token(StringTypeDefNames.Contains(name.Identifier.ValueText) ? SyntaxKind.ImplicitKeyword : SyntaxKind.ExplicitKeyword);
            members = members.Add(ConversionOperatorDeclaration(explicitOrImplicitModifier, name)
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(fieldInfo.FieldType))
                .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(Argument(valueParameter))))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            if (isHandle && fieldInfo.FieldType is not IdentifierNameSyntax { Identifier: { ValueText: nameof(IntPtr) } })
            {
                // Handle types must interop with IntPtr for SafeHandle support, so if IntPtr isn't the field type,
                // we need to create new conversion operators.

                // public static implicit operator IntPtr(MSIHANDLE value) => new IntPtr(value.Value);
                members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), IntPtrTypeSyntax)
                    .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(name))
                    .WithExpressionBody(ArrowExpressionClause(
                        ObjectCreationExpression(IntPtrTypeSyntax).AddArgumentListArguments(Argument(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, fieldIdentifierName)))))
                    .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)) // operators MUST be public
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

                // public static explicit operator MSIHANDLE(IntPtr value) => new MSIHANDLE((uint)value.ToInt32());
                members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ExplicitKeyword), name)
                    .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(IntPtrTypeSyntax))
                    .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(
                        Argument(CastExpression(fieldInfo.FieldType, InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, IdentifierName(nameof(IntPtr.ToInt32)))))))))
                    .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)) // operators MUST be public
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
            }

            // public bool Equals(HWND other) => this.Value == other.Value;
            IdentifierNameSyntax other = IdentifierName("other");
            members = members.Add(MethodDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword)), nameof(IEquatable<int>.Equals))
                .AddModifiers(Token(SyntaxKind.PublicKeyword))
                .AddParameterListParameters(Parameter(other.Identifier).WithType(name))
                .WithExpressionBody(ArrowExpressionClause(
                    BinaryExpression(
                        SyntaxKind.EqualsExpression,
                        fieldAccessExpression,
                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, other, fieldIdentifierName))))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            // public override bool Equals(object obj) => obj is HWND other && this.Equals(other);
            IdentifierNameSyntax objParam = IdentifierName("obj");
            members = members.Add(MethodDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword)), nameof(IEquatable<int>.Equals))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword))
                .AddParameterListParameters(Parameter(objParam.Identifier).WithType(PredefinedType(Token(SyntaxKind.ObjectKeyword))))
                .WithExpressionBody(ArrowExpressionClause(
                    BinaryExpression(
                        SyntaxKind.LogicalAndExpression,
                        IsPatternExpression(objParam, DeclarationPattern(name, SingleVariableDesignation(Identifier("other")))),
                        InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName(nameof(Equals)))).AddArgumentListArguments(Argument(IdentifierName("other"))))))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            // public override int GetHashCode() => unchecked((int)this.Value); // if Value is a pointer
            // public override int GetHashCode() => this.Value.GetHashCode(); // if Value is not a pointer
            ExpressionSyntax hashExpr = fieldInfo.FieldType is PointerTypeSyntax ?
                CheckedExpression(SyntaxKind.UncheckedExpression, CastExpression(PredefinedType(Token(SyntaxKind.IntKeyword)), fieldAccessExpression)) :
                InvocationExpression(
                    MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, fieldAccessExpression, IdentifierName(nameof(object.GetHashCode))),
                    ArgumentList());

            members = members.Add(MethodDeclaration(PredefinedType(Token(SyntaxKind.IntKeyword)), nameof(object.GetHashCode))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(hashExpr))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            switch (name.Identifier.ValueText)
            {
                case "BSTR":
                    members = members.AddRange(this.CreateAdditionalTypeDefBSTRMembers());
                    break;
                case "PWSTR":
                    members = members.AddRange(this.CreateAdditionalTypeDefPWSTRMembers());
                    break;
                case "HRESULT":
                case "NTSTATUS":
                    members = members.AddRange(this.ExtractMembersFromTemplate(name.Identifier.ValueText));
                    break;
                default:
                    break;
            }

            var structModifiers = TokenList(Token(this.Visibility));
            if (RequiresUnsafe(fieldInfo.FieldType))
            {
                structModifiers = structModifiers.Add(Token(SyntaxKind.UnsafeKeyword));
            }

            structModifiers = structModifiers.Add(Token(SyntaxKind.ReadOnlyKeyword)).Add(Token(SyntaxKind.PartialKeyword));
            StructDeclarationSyntax result = StructDeclaration(name.Identifier)
                .AddBaseListTypes(SimpleBaseType(GenericName(nameof(IEquatable<int>)).AddTypeArgumentListArguments(name)))
                .WithMembers(members)
                .WithModifiers(structModifiers)
                .AddAttributeLists(AttributeList().AddAttributes(DebuggerDisplay("{" + fieldName + "}")));

            result = AddApiDocumentation(name.Identifier.ValueText, result);
            return result;
        }

        private IEnumerable<MemberDeclarationSyntax> ExtractMembersFromTemplate(string name) => ((TypeDeclarationSyntax)this.FetchTemplate($"{name}.cs")).Members;

        /// <summary>
        /// Promotes an <see langword="internal" /> member to be <see langword="public"/> if <see cref="Visibility"/> indicates that generated APIs should be public.
        /// This change is applied recursively.
        /// </summary>
        /// <param name="member">The member to potentially make public.</param>
        /// <returns>The modified or original <paramref name="member"/>.</returns>
        private MemberDeclarationSyntax ElevateVisibility(MemberDeclarationSyntax member)
        {
            if (this.Visibility == SyntaxKind.PublicKeyword)
            {
                int indexOfInternal = member.Modifiers.IndexOf(SyntaxKind.InternalKeyword);
                if (indexOfInternal >= 0)
                {
                    MemberDeclarationSyntax publicMember = member.WithModifiers(member.Modifiers.Replace(member.Modifiers[indexOfInternal], Token(this.Visibility)));

                    // Apply change recursively.
                    if (publicMember is TypeDeclarationSyntax memberContainer)
                    {
                        publicMember = memberContainer.WithMembers(List(memberContainer.Members.Select(this.ElevateVisibility)));
                    }

                    return publicMember;
                }
            }

            return member;
        }

        private IEnumerable<MemberDeclarationSyntax> CreateAdditionalTypeDefBSTRMembers()
        {
            ExpressionSyntax thisValue = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("Value"));

            // public override string ToString() => Marshal.PtrToStringBSTR(this.Value);
            yield return MethodDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), nameof(this.ToString))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName(nameof(Marshal)),
                            IdentifierName(nameof(Marshal.PtrToStringBSTR))))
                .AddArgumentListArguments(Argument(thisValue))))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

            // public static implicit operator ReadOnlySpan<char>(BSTR bstr) => bstr.Value != IntPtr.Zero ? new ReadOnlySpan<char>(bstr.Value.ToPointer(), *((int*)bstr.Value.ToPointer() - 1) / 2) : default;
            TypeSyntax rosChar = MakeReadOnlySpanOfT(PredefinedType(Token(SyntaxKind.CharKeyword)));
            IdentifierNameSyntax bstrParam = IdentifierName("bstr");
            ExpressionSyntax bstrValue = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, bstrParam, IdentifierName("Value"));
            ExpressionSyntax bstrPointer = InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, bstrValue, IdentifierName(nameof(IntPtr.ToPointer))), ArgumentList());
            ExpressionSyntax length = BinaryExpression(
                SyntaxKind.DivideExpression,
                PrefixUnaryExpression(
                    SyntaxKind.PointerIndirectionExpression,
                    ParenthesizedExpression(
                        BinaryExpression(
                            SyntaxKind.SubtractExpression,
                            CastExpression(PointerType(PredefinedType(Token(SyntaxKind.IntKeyword))), bstrPointer),
                            LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(1))))),
                LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(2)));
            ExpressionSyntax rosCreation = ObjectCreationExpression(rosChar).AddArgumentListArguments(Argument(bstrPointer), Argument(length));
            ExpressionSyntax bstrNotZero = BinaryExpression(SyntaxKind.NotEqualsExpression, bstrValue, DefaultExpression(IntPtrTypeSyntax));
            ExpressionSyntax conditional = ConditionalExpression(bstrNotZero, rosCreation, DefaultExpression(rosChar));
            yield return ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), rosChar)
                .AddParameterListParameters(Parameter(bstrParam.Identifier).WithType(IdentifierName("BSTR")))
                .WithExpressionBody(ArrowExpressionClause(conditional))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.UnsafeKeyword)) // operators MUST be public
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

            // internal ReadOnlySpan<char> AsSpan() => this;
            yield return MethodDeclaration(rosChar, "AsSpan")
                .AddModifiers(Token(this.Visibility))
                .WithExpressionBody(ArrowExpressionClause(ThisExpression()))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
        }

        private IEnumerable<MemberDeclarationSyntax> CreateAdditionalTypeDefPWSTRMembers()
        {
#pragma warning disable SA1114 // Parameter list should follow declaration
            ExpressionSyntax thisValue = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("Value"));
            ExpressionSyntax thisValueIsNull = IsPatternExpression(thisValue, ConstantPattern(LiteralExpression(SyntaxKind.NullLiteralExpression)));

            // internal int Length { get; }
            IdentifierNameSyntax localPointer = IdentifierName("p");
            yield return PropertyDeclaration(PredefinedType(Token(SyntaxKind.IntKeyword)), "Length")
                .AddModifiers(Token(this.Visibility))
                .AddAccessorListAccessors(AccessorDeclaration(
                    SyntaxKind.GetAccessorDeclaration,
                    Block().AddStatements(
                        //// char* p = this.Value;
                        LocalDeclarationStatement(
                            VariableDeclaration(PointerType(PredefinedType(Token(SyntaxKind.CharKeyword))))
                                .AddVariables(VariableDeclarator(localPointer.Identifier).WithInitializer(EqualsValueClause(thisValue)))),
                        //// if (p is null) return 0;
                        IfStatement(
                            IsPatternExpression(localPointer, ConstantPattern(LiteralExpression(SyntaxKind.NullLiteralExpression))),
                            ReturnStatement(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)))),
                        //// while (*p != '\0') p++;
                        WhileStatement(
                            BinaryExpression(SyntaxKind.NotEqualsExpression, PrefixUnaryExpression(SyntaxKind.PointerIndirectionExpression, localPointer), LiteralExpression(SyntaxKind.CharacterLiteralExpression, Literal('\0'))),
                            ExpressionStatement(PostfixUnaryExpression(SyntaxKind.PostIncrementExpression, localPointer))),
                        //// return checked((int)(p - this.Value));
                        ReturnStatement(
                            CheckedExpression(
                                SyntaxKind.CheckedExpression,
                                CastExpression(
                                    PredefinedType(Token(SyntaxKind.IntKeyword)),
                                    ParenthesizedExpression(BinaryExpression(SyntaxKind.SubtractExpression, localPointer, thisValue))))))));

            // public override string? ToString() => this.Value is null ? null : new string(this.Value);
            yield return MethodDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), nameof(this.ToString))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword))
                .WithExpressionBody(ArrowExpressionClause(
                    ConditionalExpression(
                        thisValueIsNull,
                        LiteralExpression(SyntaxKind.NullLiteralExpression),
                        ObjectCreationExpression(PredefinedType(Token(SyntaxKind.StringKeyword)))
                            .AddArgumentListArguments(Argument(thisValue)))))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

            // internal Span<char> AsSpan() => this.Value is null ? default : new Span<char>(this.Value, this.Length);
            TypeSyntax spanChar = MakeSpanOfT(PredefinedType(Token(SyntaxKind.CharKeyword)));
            ExpressionSyntax thisLength = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("Length"));
            ExpressionSyntax spanCreation = ObjectCreationExpression(spanChar).AddArgumentListArguments(Argument(thisValue), Argument(thisLength));
            ExpressionSyntax conditional = ConditionalExpression(thisValueIsNull, DefaultExpression(spanChar), spanCreation);
            yield return MethodDeclaration(spanChar, "AsSpan")
                .AddModifiers(Token(this.Visibility))
                .WithExpressionBody(ArrowExpressionClause(conditional))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
#pragma warning restore SA1114 // Parameter list should follow declaration
        }

        private StructDeclarationSyntax DeclareTypeDefBOOLStruct(TypeDefinition typeDef)
        {
            IdentifierNameSyntax name = IdentifierName("BOOL");

            FieldDefinition fieldDef = this.mr.GetFieldDefinition(typeDef.GetFields().Single());
            var fieldAttributes = fieldDef.GetCustomAttributes();
            string fieldName = this.mr.GetString(fieldDef.Name);
            VariableDeclaratorSyntax fieldDeclarator = VariableDeclarator("value");
            (TypeSyntax FieldType, SyntaxList<MemberDeclarationSyntax> AdditionalMembers) fieldInfo =
                this.ReinterpretFieldType(fieldDef, fieldDeclarator.Identifier.ValueText, fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null).ToTypeSyntax(this.fieldTypeSettings, fieldAttributes).Type, fieldAttributes);
            SyntaxList<MemberDeclarationSyntax> members = List<MemberDeclarationSyntax>();

            FieldDeclarationSyntax fieldSyntax = FieldDeclaration(
                VariableDeclaration(fieldInfo.FieldType).AddVariables(fieldDeclarator))
                .AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ReadOnlyKeyword));
            members = members.Add(fieldSyntax);
            MemberAccessExpressionSyntax fieldAccessExpression = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("value"));

            // Add property accessor
            members = members.Add(PropertyDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword)), "Value")
                .WithExpressionBody(ArrowExpressionClause(BinaryExpression(SyntaxKind.NotEqualsExpression, fieldAccessExpression, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0))))).WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                .AddModifiers(Token(this.Visibility)));

            // BOOL(bool value) => this.value = value ? 1 : 0;
            IdentifierNameSyntax valueParameter = IdentifierName("value");
            ExpressionSyntax boolToInt = ConditionalExpression(valueParameter, LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(1)), LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)));
            members = members.Add(ConstructorDeclaration(name.Identifier)
                .AddModifiers(Token(this.Visibility))
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(PredefinedType(Token(SyntaxKind.BoolKeyword))))
                .WithExpressionBody(ArrowExpressionClause(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, fieldAccessExpression, boolToInt)))
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            // public static implicit operator bool(BOOL value) => value.Value;
            members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), PredefinedType(Token(SyntaxKind.BoolKeyword)))
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(name))
                .WithExpressionBody(ArrowExpressionClause(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, valueParameter, IdentifierName(fieldName))))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            // public static implicit operator BOOL(bool value) => new BOOL(value);
            members = members.Add(ConversionOperatorDeclaration(Token(SyntaxKind.ImplicitKeyword), name)
                .AddParameterListParameters(Parameter(valueParameter.Identifier).WithType(PredefinedType(Token(SyntaxKind.BoolKeyword))))
                .WithExpressionBody(ArrowExpressionClause(ObjectCreationExpression(name).AddArgumentListArguments(Argument(valueParameter))))
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)) // operators MUST be public
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

            StructDeclarationSyntax result = StructDeclaration(name.Identifier)
                .WithMembers(members)
                .WithModifiers(TokenList(Token(this.Visibility), Token(SyntaxKind.ReadOnlyKeyword), Token(SyntaxKind.PartialKeyword)));

            result = AddApiDocumentation(name.Identifier.ValueText, result);
            return result;
        }

        private EnumDeclarationSyntax DeclareEnum(TypeDefinition typeDef)
        {
            bool flagsEnum = false;
            foreach (CustomAttributeHandle attributeHandle in typeDef.GetCustomAttributes())
            {
                CustomAttribute attribute = this.mr.GetCustomAttribute(attributeHandle);
                if (this.IsAttribute(attribute, nameof(System), "FlagsAttribute"))
                {
                    flagsEnum = true;
                    break;
                }
            }

            var enumValues = new List<SyntaxNodeOrToken>();
            TypeSyntax? enumBaseType = null;
            foreach (FieldDefinitionHandle fieldDefHandle in typeDef.GetFields())
            {
                FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldDefHandle);
                string enumValueName = this.mr.GetString(fieldDef.Name);
                ConstantHandle valueHandle = fieldDef.GetDefaultValue();
                if (valueHandle.IsNil)
                {
                    enumBaseType = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null).ToTypeSyntax(this.enumTypeSettings, null).Type;
                    continue;
                }

                Constant value = this.mr.GetConstant(valueHandle);
                ExpressionSyntax enumValue = flagsEnum ? this.ToHexExpressionSyntax(value) : this.ToExpressionSyntax(value);
                EnumMemberDeclarationSyntax enumMember = EnumMemberDeclaration(SafeIdentifier(enumValueName))
                    .WithEqualsValue(EqualsValueClause(enumValue));
                enumValues.Add(enumMember);
                enumValues.Add(Token(SyntaxKind.CommaToken));
            }

            if (enumBaseType is null)
            {
                throw new NotSupportedException("Unknown enum type.");
            }

            var name = this.mr.GetString(typeDef.Name);
            EnumDeclarationSyntax result = EnumDeclaration(name)
                .WithMembers(SeparatedList<EnumMemberDeclarationSyntax>(enumValues.ToArray()))
                .WithModifiers(TokenList(Token(this.Visibility)));

            if (!(enumBaseType is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.IntKeyword } }))
            {
                result = result.AddBaseListTypes(SimpleBaseType(enumBaseType));
            }

            if (flagsEnum)
            {
                result = result.AddAttributeLists(
                    AttributeList().AddAttributes(FlagsAttributeSyntax));
            }

            result = AddApiDocumentation(name, result);

            return result;
        }

        private enum FriendlyOverloadOf
        {
            ExternMethod,
            StructMethod,
            InterfaceMethod,
        }

        private IEnumerable<MethodDeclarationSyntax> DeclareFriendlyOverloads(MethodDefinition methodDefinition, MethodDeclarationSyntax externMethodDeclaration, string declaringTypeName, FriendlyOverloadOf overloadOf)
        {
#pragma warning disable SA1114 // Parameter list should follow declaration
            static ParameterSyntax StripAttributes(ParameterSyntax parameter) => parameter.WithAttributeLists(List<AttributeListSyntax>());
            static ExpressionSyntax GetSpanLength(ExpressionSyntax span) => MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, span, IdentifierName(nameof(Span<int>.Length)));
            bool isReleaseMethod = this.releaseMethods.Contains(externMethodDeclaration.Identifier.ValueText);

            var originalSignature = methodDefinition.DecodeSignature(SignatureHandleProvider.Instance, null);
            var parameters = externMethodDeclaration.ParameterList.Parameters.Select(StripAttributes).ToList();
            var lengthParamUsedBy = new Dictionary<int, int>();
            var arguments = externMethodDeclaration.ParameterList.Parameters.Select(p => Argument(IdentifierName(p.Identifier.Text)).WithRefKindKeyword(p.Modifiers.FirstOrDefault(p => p.Kind() is SyntaxKind.RefKeyword or SyntaxKind.OutKeyword or SyntaxKind.InKeyword))).ToList();
            var externMethodReturnType = externMethodDeclaration.ReturnType.WithoutLeadingTrivia();
            var fixedBlocks = new List<VariableDeclarationSyntax>();
            var leadingOutsideTryStatements = new List<StatementSyntax>();
            var leadingStatements = new List<StatementSyntax>();
            var trailingStatements = new List<StatementSyntax>();
            var finallyStatements = new List<StatementSyntax>();
            bool signatureChanged = false;
            foreach (ParameterHandle paramHandle in methodDefinition.GetParameters())
            {
                var param = this.mr.GetParameter(paramHandle);
                if (param.SequenceNumber == 0 || param.SequenceNumber - 1 >= parameters.Count)
                {
                    continue;
                }

                bool isOptional = (param.Attributes & ParameterAttributes.Optional) == ParameterAttributes.Optional;
                bool isIn = (param.Attributes & ParameterAttributes.In) == ParameterAttributes.In;
                bool isConst = param.GetCustomAttributes().Any(ah => this.IsAttribute(this.mr.GetCustomAttribute(ah), InteropDecorationNamespace, "ConstAttribute"));
                bool isComOutPtr = param.GetCustomAttributes().Any(ah => this.IsAttribute(this.mr.GetCustomAttribute(ah), InteropDecorationNamespace, "ComOutPtrAttribute"));
                bool isOut = isComOutPtr || (param.Attributes & ParameterAttributes.Out) == ParameterAttributes.Out;

                // TODO:
                // * Review double/triple pointer scenarios.
                //   * Consider CredEnumerateA, which is a "pointer to an array of pointers" (3-asterisks!). How does FriendlyAttribute improve this, if at all? The memory must be freed through another p/invoke.
                ParameterSyntax externParam = parameters[param.SequenceNumber - 1];
                if (this.IsManagedType(originalSignature.ParameterTypes[param.SequenceNumber - 1]) && (externParam.Modifiers.Any(SyntaxKind.OutKeyword) || externParam.Modifiers.Any(SyntaxKind.RefKeyword)))
                {
                    bool hasOut = externParam.Modifiers.Any(SyntaxKind.OutKeyword);
                    arguments[param.SequenceNumber - 1] = arguments[param.SequenceNumber - 1].WithRefKindKeyword(Token(hasOut ? SyntaxKind.OutKeyword : SyntaxKind.RefKeyword));
                }
                else if (isOut && !isIn && !isReleaseMethod && externParam.Type is PointerTypeSyntax { ElementType: IdentifierNameSyntax outTypeId } && this.TryGetHandleReleaseMethod(outTypeId.Identifier.ValueText, out string? outReleaseMethod) && !this.mr.StringComparer.Equals(methodDefinition.Name, outReleaseMethod))
                {
                    if (this.RequestSafeHandle(outReleaseMethod) is TypeSyntax safeHandleType)
                    {
                        signatureChanged = true;

                        IdentifierNameSyntax origName = IdentifierName(externParam.Identifier.ValueText);
                        IdentifierNameSyntax typeDefHandleName = IdentifierName(externParam.Identifier.ValueText + "Local");

                        // out SafeHandle
                        parameters[param.SequenceNumber - 1] = externParam
                            .WithType(safeHandleType)
                            .WithModifiers(TokenList(Token(SyntaxKind.OutKeyword)));

                        // HANDLE SomeLocal;
                        leadingStatements.Add(LocalDeclarationStatement(VariableDeclaration(outTypeId).AddVariables(
                            VariableDeclarator(typeDefHandleName.Identifier))));

                        // Argument: &SomeLocal
                        arguments[param.SequenceNumber - 1] = Argument(PrefixUnaryExpression(SyntaxKind.AddressOfExpression, typeDefHandleName));

                        // Some = new SafeHandle(SomeLocal, ownsHandle: true);
                        trailingStatements.Add(ExpressionStatement(AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression,
                            origName,
                            ObjectCreationExpression(safeHandleType).AddArgumentListArguments(
                                Argument(typeDefHandleName),
                                Argument(LiteralExpression(SyntaxKind.TrueLiteralExpression)).WithNameColon(NameColon("ownsHandle"))))));
                    }
                }
                else if (isIn && !isOut && !isReleaseMethod && externParam.Type is IdentifierNameSyntax typeId && this.TryGetHandleReleaseMethod(typeId.Identifier.ValueText, out string? releaseMethod) && !this.mr.StringComparer.Equals(methodDefinition.Name, releaseMethod))
                {
                    IdentifierNameSyntax origName = IdentifierName(externParam.Identifier.ValueText);
                    IdentifierNameSyntax typeDefHandleName = IdentifierName(externParam.Identifier.ValueText + "Local");
                    signatureChanged = true;

                    IdentifierNameSyntax refAddedName = IdentifierName(externParam.Identifier.ValueText + "AddRef");

                    // bool hParamNameAddRef = false;
                    leadingOutsideTryStatements.Add(LocalDeclarationStatement(
                        VariableDeclaration(PredefinedType(Token(SyntaxKind.BoolKeyword))).AddVariables(
                            VariableDeclarator(refAddedName.Identifier).WithInitializer(EqualsValueClause(LiteralExpression(SyntaxKind.FalseLiteralExpression))))));

                    // HANDLE hTemplateFileLocal;
                    leadingStatements.Add(LocalDeclarationStatement(VariableDeclaration(externParam.Type).AddVariables(
                        VariableDeclarator(typeDefHandleName.Identifier))));

                    // if (hTemplateFile is object)
                    leadingStatements.Add(IfStatement(
                        BinaryExpression(SyntaxKind.IsExpression, origName, PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                        Block().AddStatements(
                        //// hTemplateFile.DangerousAddRef(ref hTemplateFileAddRef);
                        ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName(nameof(SafeHandle.DangerousAddRef))))
                            .AddArgumentListArguments(Argument(refAddedName).WithRefKindKeyword(Token(SyntaxKind.RefKeyword)))),
                        //// hTemplateFileLocal = (HANDLE)hTemplateFile.DangerousGetHandle();
                        ExpressionStatement(AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression,
                            typeDefHandleName,
                            CastExpression(
                                externParam.Type,
                                InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName(nameof(SafeHandle.DangerousGetHandle))), ArgumentList()))))),
                        //// else hTemplateFileLocal = default;
                        ElseClause(ExpressionStatement(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, typeDefHandleName, DefaultExpression(externParam.Type))))));

                    // if (hTemplateFileAddRef) hTemplateFile.DangerousRelease();
                    finallyStatements.Add(IfStatement(
                        refAddedName,
                        ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName(nameof(SafeHandle.DangerousRelease))), ArgumentList()))));

                    // Accept the SafeHandle instead.
                    parameters[param.SequenceNumber - 1] = externParam
                        .WithType(IdentifierName(nameof(SafeHandle)));

                    // hParamNameLocal;
                    arguments[param.SequenceNumber - 1] = Argument(typeDefHandleName);
                }
                else if ((externParam.Type is PointerTypeSyntax { ElementType: TypeSyntax ptrElementType }
                    && !IsVoid(ptrElementType)
                    && !(ptrElementType is IdentifierNameSyntax id && this.IsInterface(id.Identifier.ValueText))) ||
                    externParam.Type is ArrayTypeSyntax)
                {
                    TypeSyntax elementType = externParam.Type is PointerTypeSyntax ptr ? ptr.ElementType
                        : externParam.Type is ArrayTypeSyntax array ? array.ElementType
                        : throw new InvalidOperationException();
                    bool isPointerToPointer = elementType is PointerTypeSyntax or FunctionPointerTypeSyntax;

                    // If there are no SAL annotations at all...
                    if (!isOptional && !isIn && !isOut)
                    {
                        // Consider that const means [In]
                        if (isConst)
                        {
                            isIn = true;
                            isOut = false;
                        }
                        else
                        {
                            // Otherwise assume bidirectional.
                            isIn = isOut = true;
                        }
                    }

                    bool isArray = false;
                    bool isNullTerminated = false; // TODO
                    short? sizeParamIndex = null;
                    int? sizeConst = null;
                    foreach (CustomAttributeHandle attHandle in param.GetCustomAttributes())
                    {
                        CustomAttribute att = this.mr.GetCustomAttribute(attHandle);
                        if (this.IsAttribute(att, InteropDecorationNamespace, NativeArrayInfoAttribute))
                        {
                            var args = att.DecodeValue(CustomAttributeTypeProvider.Instance);
                            isArray = true;
                            sizeParamIndex = (short?)args.NamedArguments.FirstOrDefault(a => a.Name == "SizeParamIndex").Value;
                            sizeConst = (int?)args.NamedArguments.FirstOrDefault(a => a.Name == "SizeConst").Value;

                            break;
                        }
                    }

                    IdentifierNameSyntax origName = IdentifierName(parameters[param.SequenceNumber - 1].Identifier.ValueText);
                    IdentifierNameSyntax localName = IdentifierName(origName + "Local");
                    if (isArray)
                    {
                        // TODO: add support for in/out size parameters. (e.g. RSGetViewports)
                        // TODO: add support for lists of pointers via a generated pointer-wrapping struct (e.g. PSSetSamplers)
                        if (sizeParamIndex.HasValue
                            && !(externMethodDeclaration.ParameterList.Parameters[sizeParamIndex.Value].Type is PointerTypeSyntax)
                            && !isPointerToPointer)
                        {
                            signatureChanged = true;

                            if (lengthParamUsedBy.TryGetValue(sizeParamIndex.Value, out int userIndex))
                            {
                                // Multiple array parameters share a common 'length' parameter.
                                // Since we're making this a little less obvious, add a quick if check in the helper method
                                // that enforces that all such parameters have a common span length.
                                ExpressionSyntax otherUserName = IdentifierName(parameters[userIndex].Identifier.ValueText);
                                leadingStatements.Add(IfStatement(
                                    BinaryExpression(
                                        SyntaxKind.NotEqualsExpression,
                                        GetSpanLength(otherUserName),
                                        GetSpanLength(origName)),
                                    ThrowStatement(ObjectCreationExpression(IdentifierName(nameof(ArgumentException))).WithArgumentList(ArgumentList()))));
                            }
                            else
                            {
                                lengthParamUsedBy.Add(sizeParamIndex.Value, param.SequenceNumber - 1);
                            }

                            if (externParam.Type is PointerTypeSyntax)
                            {
                                parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                    .WithType(isIn && isConst ? MakeReadOnlySpanOfT(elementType) : MakeSpanOfT(elementType));
                                fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                                    VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                                arguments[param.SequenceNumber - 1] = Argument(localName);
                            }

                            ExpressionSyntax sizeArgExpression = GetSpanLength(origName);
                            if (!(parameters[sizeParamIndex.Value].Type is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.IntKeyword } }))
                            {
                                sizeArgExpression = CastExpression(parameters[sizeParamIndex.Value].Type!, sizeArgExpression);
                            }

                            arguments[sizeParamIndex.Value] = Argument(sizeArgExpression);
                        }
                        else if (sizeConst.HasValue && !isPointerToPointer)
                        {
                            // TODO: add support for lists of pointers via a generated pointer-wrapping struct
                            signatureChanged = true;

                            // Accept a span instead of a pointer.
                            parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                .WithType(isIn && isConst ? MakeReadOnlySpanOfT(elementType) : MakeSpanOfT(elementType));
                            fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                                VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                            arguments[param.SequenceNumber - 1] = Argument(localName);

                            // Add a runtime check that the span is at least the required length.
                            leadingStatements.Add(IfStatement(
                                BinaryExpression(
                                    SyntaxKind.LessThanExpression,
                                    GetSpanLength(origName),
                                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(sizeConst.Value))),
                                ThrowStatement(ObjectCreationExpression(IdentifierName(nameof(ArgumentException))).WithArgumentList(ArgumentList()))));
                        }
                        else if (isNullTerminated && isConst && parameters[param.SequenceNumber - 1].Type is PointerTypeSyntax { ElementType: PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.CharKeyword } } })
                        {
                            // replace char* with string
                            signatureChanged = true;
                            parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                                .WithType(PredefinedType(Token(SyntaxKind.StringKeyword)));
                            fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                                VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                            arguments[param.SequenceNumber - 1] = Argument(localName);
                        }
                    }
                    else if (isIn && isOptional && !isOut && !isPointerToPointer)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(NullableType(elementType));
                        leadingStatements.Add(
                            LocalDeclarationStatement(VariableDeclaration(elementType)
                                .AddVariables(VariableDeclarator(localName.Identifier).WithInitializer(
                                    EqualsValueClause(ConditionalExpression(
                                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("HasValue")),
                                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("Value")),
                                        DefaultExpression(elementType)))))));
                        arguments[param.SequenceNumber - 1] = Argument(ConditionalExpression(
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, origName, IdentifierName("HasValue")),
                            PrefixUnaryExpression(SyntaxKind.AddressOfExpression, localName),
                            LiteralExpression(SyntaxKind.NullLiteralExpression)));
                    }
                    else if (isIn && isOut && !isOptional)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(elementType)
                            .WithModifiers(TokenList(Token(SyntaxKind.RefKeyword)));
                        fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                    else if (isOut && !isIn && !isOptional)
                    {
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(elementType)
                            .WithModifiers(TokenList(Token(SyntaxKind.OutKeyword)));
                        fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                    else if (isIn && !isOut && !isOptional)
                    {
                        // Use the "in" modifier to avoid copying the struct.
                        signatureChanged = true;
                        parameters[param.SequenceNumber - 1] = parameters[param.SequenceNumber - 1]
                            .WithType(elementType)
                            .WithModifiers(TokenList(Token(SyntaxKind.InKeyword)));
                        fixedBlocks.Add(VariableDeclaration(externParam.Type).AddVariables(
                            VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(
                                PrefixUnaryExpression(SyntaxKind.AddressOfExpression, origName)))));
                        arguments[param.SequenceNumber - 1] = Argument(localName);
                    }
                }
                else if (isIn && !isOut && isConst && externParam.Type is IdentifierNameSyntax { Identifier: { ValueText: "PCWSTR" } })
                {
                    IdentifierNameSyntax origName = IdentifierName(externParam.Identifier.ValueText);
                    IdentifierNameSyntax localName = IdentifierName(origName + "Local");
                    signatureChanged = true;
                    parameters[param.SequenceNumber - 1] = externParam
                        .WithType(PredefinedType(Token(SyntaxKind.StringKeyword)));
                    fixedBlocks.Add(VariableDeclaration(PointerType(PredefinedType(Token(SyntaxKind.CharKeyword)))).AddVariables(
                        VariableDeclarator(localName.Identifier).WithInitializer(EqualsValueClause(origName))));
                    arguments[param.SequenceNumber - 1] = Argument(localName);
                }
            }

            TypeSyntax? returnSafeHandleType = externMethodReturnType is IdentifierNameSyntax returnType
                && this.TryGetHandleReleaseMethod(returnType.Identifier.ValueText, out string? returnReleaseMethod)
                ? this.RequestSafeHandle(returnReleaseMethod) : null;
            SyntaxToken friendlyMethodName = externMethodDeclaration.Identifier;

            if (returnSafeHandleType is object && !signatureChanged)
            {
                // The parameter types are all the same, but we need a friendly overload with a different return type.
                // Our only choice is to rename the friendly overload.
                friendlyMethodName = Identifier(externMethodDeclaration.Identifier.ValueText + "_SafeHandle");
                signatureChanged = true;
            }

            if (signatureChanged)
            {
                if (lengthParamUsedBy.Count > 0)
                {
                    // Remove in reverse order so as to not invalidate the indexes of elements to remove.
                    // Also take care to only remove each element once, even if it shows up multiple times in the collection.
                    var parameterIndexesToRemove = new SortedSet<int>(lengthParamUsedBy.Keys);
                    foreach (int indexToRemove in parameterIndexesToRemove.Reverse())
                    {
                        parameters.RemoveAt(indexToRemove);
                    }
                }

                TypeSyntax docRefExternName = overloadOf == FriendlyOverloadOf.InterfaceMethod
                    ? QualifiedName(IdentifierName(declaringTypeName), IdentifierName(externMethodDeclaration.Identifier))
                    : IdentifierName(externMethodDeclaration.Identifier);
                var leadingTrivia = Trivia(
                    DocumentationCommentTrivia(SyntaxKind.SingleLineDocumentationCommentTrivia).AddContent(
                        XmlText("/// "),
                        XmlEmptyElement("inheritdoc").AddAttributes(XmlCrefAttribute(NameMemberCref(docRefExternName, ToCref(externMethodDeclaration.ParameterList)))),
                        XmlText().AddTextTokens(XmlTextNewLine(TriviaList(), "\r\n", "\r\n", TriviaList()))));
                InvocationExpressionSyntax externInvocation = InvocationExpression(
                    overloadOf switch
                    {
                        FriendlyOverloadOf.ExternMethod => QualifiedName(IdentifierName(declaringTypeName), IdentifierName(externMethodDeclaration.Identifier.Text)),
                        FriendlyOverloadOf.StructMethod => MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName(externMethodDeclaration.Identifier.Text)),
                        FriendlyOverloadOf.InterfaceMethod => MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("@this"), IdentifierName(externMethodDeclaration.Identifier.Text)),
                        _ => throw new NotSupportedException("Unrecognized friendly overload mode " + overloadOf),
                    })
                    .AddArgumentListArguments(arguments.ToArray());
                bool hasVoidReturn = externMethodReturnType is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.VoidKeyword } };
                var body = Block().AddStatements(leadingStatements.ToArray());
                IdentifierNameSyntax resultLocal = IdentifierName("__result");
                if (returnSafeHandleType is object)
                {
                    //// HANDLE result = invocation();
                    body = body.AddStatements(LocalDeclarationStatement(VariableDeclaration(externMethodReturnType)
                        .AddVariables(VariableDeclarator(resultLocal.Identifier).WithInitializer(EqualsValueClause(externInvocation)))));

                    body = body.AddStatements(trailingStatements.ToArray());

                    //// return new SafeHandle(result, ownsHandle: true);
                    body = body.AddStatements(ReturnStatement(ObjectCreationExpression(returnSafeHandleType).AddArgumentListArguments(
                        Argument(resultLocal),
                        Argument(LiteralExpression(SyntaxKind.TrueLiteralExpression)).WithNameColon(NameColon("ownsHandle")))));
                }
                else if (hasVoidReturn)
                {
                    body = body.AddStatements(ExpressionStatement(externInvocation));
                    body = body.AddStatements(trailingStatements.ToArray());
                }
                else
                {
                    // var result = externInvocation();
                    body = body.AddStatements(LocalDeclarationStatement(VariableDeclaration(externMethodReturnType)
                        .AddVariables(VariableDeclarator(resultLocal.Identifier).WithInitializer(EqualsValueClause(externInvocation)))));

                    body = body.AddStatements(trailingStatements.ToArray());

                    // return result;
                    body = body.AddStatements(ReturnStatement(resultLocal));
                }

                foreach (var fixedExpression in fixedBlocks)
                {
                    body = Block(FixedStatement(fixedExpression, body));
                }

                if (finallyStatements.Count > 0)
                {
                    body = Block()
                        .AddStatements(leadingOutsideTryStatements.ToArray())
                        .AddStatements(TryStatement(body, default, FinallyClause(Block().AddStatements(finallyStatements.ToArray()))));
                }
                else if (leadingOutsideTryStatements.Count > 0)
                {
                    body = body.WithStatements(body.Statements.InsertRange(0, leadingOutsideTryStatements));
                }

                var modifiers = TokenList(Token(this.Visibility), Token(SyntaxKind.UnsafeKeyword));
                if (overloadOf != FriendlyOverloadOf.StructMethod)
                {
                    modifiers = modifiers.Insert(1, Token(SyntaxKind.StaticKeyword));
                }

                if (overloadOf == FriendlyOverloadOf.InterfaceMethod)
                {
                    parameters.Insert(0, Parameter(Identifier("@this")).WithType(IdentifierName(declaringTypeName)).AddModifiers(Token(SyntaxKind.ThisKeyword)));
                }

                MethodDeclarationSyntax friendlyDeclaration = externMethodDeclaration
                    .WithReturnType(externMethodReturnType)
                    .WithIdentifier(friendlyMethodName)
                    .WithModifiers(modifiers)
                    .WithAttributeLists(List<AttributeListSyntax>())
                    .WithParameterList(ParameterList().AddParameters(parameters.ToArray()))
                    .WithLeadingTrivia(leadingTrivia)
                    .WithBody(body)
                    .WithSemicolonToken(default);

                if (returnSafeHandleType is object)
                {
                    friendlyDeclaration = friendlyDeclaration.WithReturnType(returnSafeHandleType);
                }

                yield return friendlyDeclaration;
            }
#pragma warning restore SA1114 // Parameter list should follow declaration
        }

        internal bool IsAttribute(CustomAttribute attribute, string ns, string name) => IsAttribute(this.mr, attribute, ns, name);

        internal static bool IsAttribute(MetadataReader reader, CustomAttribute attribute, string ns, string name)
        {
            StringHandle actualNamespace, actualName;
            if (attribute.Constructor.Kind == HandleKind.MemberReference)
            {
                MemberReference memberReference = reader.GetMemberReference((MemberReferenceHandle)attribute.Constructor);
                TypeReference parentRef = reader.GetTypeReference((TypeReferenceHandle)memberReference.Parent);
                actualNamespace = parentRef.Namespace;
                actualName = parentRef.Name;
            }
            else if (attribute.Constructor.Kind == HandleKind.MethodDefinition)
            {
                MethodDefinition methodDef = reader.GetMethodDefinition((MethodDefinitionHandle)attribute.Constructor);
                TypeDefinition typeDef = reader.GetTypeDefinition(methodDef.GetDeclaringType());
                actualNamespace = typeDef.Namespace;
                actualName = typeDef.Name;
            }
            else
            {
                throw new NotSupportedException("Unsupported attribute constructor kind: " + attribute.Constructor.Kind);
            }

            return reader.StringComparer.Equals(actualName, name) && reader.StringComparer.Equals(actualNamespace, ns);
        }

        private List<MemberDeclarationSyntax> GetModuleMemberList(string moduleName)
        {
            if (!this.modulesAndMembers.TryGetValue(moduleName, out var methodsList))
            {
                this.modulesAndMembers.Add(moduleName, methodsList = new List<MemberDeclarationSyntax>());
            }

            return methodsList;
        }

        private string GetNormalizedModuleName(MethodImport import)
        {
            ModuleReference module = this.mr.GetModuleReference(import.Module);
            string moduleName = this.mr.GetString(module.Name);
            if (CanonicalCapitalizations.TryGetValue(moduleName, out string? canonicalModuleName))
            {
                moduleName = canonicalModuleName;
            }

            return moduleName;
        }

        private ParameterListSyntax CreateParameterList(MethodDefinition methodDefinition, MethodSignature<TypeHandleInfo> signature, TypeSyntaxSettings typeSettings)
            => ParameterList().AddParameters(methodDefinition.GetParameters().Select(this.mr.GetParameter).Where(p => !p.Name.IsNil).Select(p => this.CreateParameter(signature.ParameterTypes[p.SequenceNumber - 1], p, typeSettings)).ToArray());

        private ParameterSyntax CreateParameter(TypeHandleInfo parameterInfo, Parameter parameter, TypeSyntaxSettings typeSettings)
        {
            string name = this.mr.GetString(parameter.Name);
            try
            {
                // TODO:
                // * Notice [Out][RAIIFree] handle producing parameters. Can we make these provide SafeHandle's?
                bool isReturnOrOutParam = parameter.SequenceNumber == 0 || (parameter.Attributes & ParameterAttributes.Out) == ParameterAttributes.Out;
                var parameterTypeSyntax = parameterInfo.ToTypeSyntax(typeSettings, parameter.GetCustomAttributes(), parameter.Attributes);

                // Determine the custom attributes to apply.
                var attributes = AttributeList();
                if (parameterTypeSyntax.Type is PointerTypeSyntax ptr)
                {
                    if ((parameter.Attributes & ParameterAttributes.Optional) == ParameterAttributes.Optional)
                    {
                        attributes = attributes.AddAttributes(OptionalAttributeSyntax);
                    }
                }

                var modifiers = TokenList();
                if (parameterTypeSyntax.ParameterModifier.HasValue)
                {
                    modifiers = modifiers.Add(parameterTypeSyntax.ParameterModifier.Value);
                }

                ParameterSyntax parameterSyntax = Parameter(
                    attributes.Attributes.Count > 0 ? List<AttributeListSyntax>().Add(attributes) : List<AttributeListSyntax>(),
                    modifiers,
                    parameterTypeSyntax.Type,
                    SafeIdentifier(name),
                    @default: null);
                parameterSyntax = parameterTypeSyntax.AddMarshalAs(parameterSyntax);

                if (parameter.GetCustomAttributes().Any(h => this.IsAttribute(this.mr.GetCustomAttribute(h), InteropDecorationNamespace, "RetValAttribute")))
                {
                    parameterSyntax = parameterSyntax.WithAdditionalAnnotations(IsRetValAnnotation);
                }

                return parameterSyntax;
            }
            catch (Exception ex)
            {
                throw new GenerationFailedException("Failed while generating parameter: " + name, ex);
            }
        }

        internal bool TryFindCustomAttribute(CustomAttributeHandleCollection customAttributes, string @namespace, string name, out CustomAttribute customAttribute)
        {
            foreach (CustomAttributeHandle attHandle in customAttributes)
            {
                customAttribute = this.mr.GetCustomAttribute(attHandle);
                if (this.IsAttribute(customAttribute, @namespace, name))
                {
                    return true;
                }
            }

            customAttribute = default;
            return false;
        }

        private (TypeSyntax FieldType, SyntaxList<MemberDeclarationSyntax> AdditionalMembers) ReinterpretFieldType(FieldDefinition fieldDef, string fieldName, TypeSyntax originalType, CustomAttributeHandleCollection customAttributes)
        {
            TypeSyntaxSettings typeSettings = this.fieldTypeSettings;
            TypeHandleInfo fieldTypeHandleInfo = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null);

            ExpressionSyntax GetHiddenFieldAccess() => MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                ThisExpression(),
                IdentifierName(GetHiddenFieldName(fieldName)));

            // If the field is a fixed length array, we have to work some code gen magic since C# does not allow those.
            if (originalType is ArrayTypeSyntax arrayType && arrayType.RankSpecifiers.Count > 0 && arrayType.RankSpecifiers[0].Sizes.Count == 1)
            {
                int length = int.Parse(((LiteralExpressionSyntax)arrayType.RankSpecifiers[0].Sizes[0]).Token.ValueText, CultureInfo.InvariantCulture);
                TypeSyntax elementType = arrayType.ElementType;

                // C# does not allow Span<T> where T is a pointer type.
                if (elementType is PointerTypeSyntax ptr)
                {
                    elementType = IntPtrTypeSyntax;
                }

                var lengthLiteralSyntax = LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(length));

                // internal struct __TheStruct_Count
                // {
                //     internal TheStruct _0, _1, _2, _3, _4, _5, _6, _7, _8;
                //     /// <summary>Always <c>8</c>.</summary>
                //     internal int Length => 8;
                // ...
                IdentifierNameSyntax fixedLengthStructName = IdentifierName($"__{elementType.ToString().Replace('.', '_').Replace(':', '_')}_{length}");
                var fixedLengthStruct = StructDeclaration(fixedLengthStructName.Identifier)
                    .AddModifiers(Token(this.Visibility))
                    .AddMembers(
                        FieldDeclaration(VariableDeclaration(elementType)
                            .AddVariables(Enumerable.Range(0, length).Select(n => VariableDeclarator($"_{n}")).ToArray()))
                            .AddModifiers(Token(this.Visibility)),
                        PropertyDeclaration(PredefinedType(Token(SyntaxKind.IntKeyword)), "Length")
                            .AddModifiers(Token(this.Visibility))
                            .WithExpressionBody(ArrowExpressionClause(lengthLiteralSyntax))
                            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                            .WithLeadingTrivia(Trivia(DocumentationCommentTrivia(SyntaxKind.SingleLineDocumentationCommentTrivia).AddContent(
                                DocCommentStart,
                                XmlElement("summary", List(new XmlNodeSyntax[]
                                {
                                    XmlText("Always "),
                                    XmlElement("c", List(new XmlNodeSyntax[] { XmlText(lengthLiteralSyntax.Token.ValueText) })),
                                    XmlText("."),
                                })),
                                DocCommentEnd))));

                var firstElementFieldName = IdentifierName("_0");
                if (this.canCallCreateSpan)
                {
                    // ...
                    //     internal ref TheStruct this[int index] => ref AsSpan()[index];
                    //     internal Span<TheStruct> AsSpan() => MemoryMarshal.CreateSpan(ref _1, 4);
                    fixedLengthStruct = fixedLengthStruct
                        .AddMembers(
                            IndexerDeclaration(RefType(elementType))
                                .AddModifiers(Token(this.Visibility))
                                .AddParameterListParameters(Parameter(Identifier("index")).WithType(PredefinedType(Token(SyntaxKind.IntKeyword))))
                                .WithExpressionBody(ArrowExpressionClause(RefExpression(
                                    ElementAccessExpression(InvocationExpression(IdentifierName("AsSpan")))
                                        .AddArgumentListArguments(Argument(IdentifierName("index"))))))
                                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                                .WithLeadingTrivia(InlineArrayUnsafeIndexerComment),
                            MethodDeclaration(MakeSpanOfT(elementType), "AsSpan")
                                .AddModifiers(Token(this.Visibility))
                                .WithExpressionBody(ArrowExpressionClause(
                                    InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("MemoryMarshal"), IdentifierName("CreateSpan")))
                                        .AddArgumentListArguments(
                                            Argument(nameColon: null, Token(SyntaxKind.RefKeyword), firstElementFieldName),
                                            Argument(lengthLiteralSyntax))))
                                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                                .WithLeadingTrivia(InlineArrayUnsafeAsSpanComment));
                }

                IdentifierNameSyntax indexParamName = IdentifierName("index");
                IdentifierNameSyntax p0 = IdentifierName("p0");
                IdentifierNameSyntax atThis = IdentifierName("@this");
                TypeSyntax qualifiedElementType = elementType == IntPtrTypeSyntax ? elementType : ((ArrayTypeSyntax)fieldTypeHandleInfo.ToTypeSyntax(this.extensionMethodSignatureTypeSettings, customAttributes).Type).ElementType;

                ////internal static unsafe ref readonly uint ReadOnlyItemRef(this in MainAVIHeader.__dwReserved_4 @this, int index)
                ////{
                ////    fixed (uint* p0 = &@this._1)
                ////        return ref p0[index];
                ////}
                FixedStatementSyntax? fixedStatement = FixedStatement(
                    VariableDeclaration(PointerType(qualifiedElementType)).AddVariables(
                        VariableDeclarator(p0.Identifier).WithInitializer(EqualsValueClause(
                            PrefixUnaryExpression(
                                SyntaxKind.AddressOfExpression,
                                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, atThis, firstElementFieldName))))),
                    ReturnStatement(RefExpression(ElementAccessExpression(p0).AddArgumentListArguments(Argument(indexParamName)))));
                BlockSyntax body = Block().AddStatements(fixedStatement);
                ParameterSyntax thisParameter = Parameter(atThis.Identifier).WithType(QualifiedName((NameSyntax)new HandleTypeHandleInfo(this.mr, fieldDef.GetDeclaringType()).ToTypeSyntax(this.extensionMethodSignatureTypeSettings, customAttributes).Type, fixedLengthStructName)).AddModifiers(Token(SyntaxKind.ThisKeyword));
                ParameterSyntax indexParameter = Parameter(indexParamName.Identifier).WithType(PredefinedType(Token(SyntaxKind.IntKeyword)));
                SyntaxTokenList methodModifiers = TokenList(Token(this.Visibility), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.UnsafeKeyword));
                MethodDeclarationSyntax getAtMethod = MethodDeclaration(RefType(qualifiedElementType).WithReadOnlyKeyword(Token(SyntaxKind.ReadOnlyKeyword)), "ReadOnlyItemRef")
                    .WithModifiers(methodModifiers)
                    .AddParameterListParameters(thisParameter.AddModifiers(Token(SyntaxKind.InKeyword)), indexParameter)
                    .WithBody(body);
                AddExtensionMethod(getAtMethod);

                ////internal static unsafe ref uint ItemRef(this ref MainAVIHeader.__dwReserved_4 @this, int index)
                ////{
                ////    fixed (uint* p0 = &@this._1)
                ////        return ref p0[index];
                ////}
                MethodDeclarationSyntax getOrSetAtMethod = MethodDeclaration(RefType(qualifiedElementType), "ItemRef")
                    .WithModifiers(methodModifiers)
                    .AddParameterListParameters(thisParameter.AddModifiers(Token(SyntaxKind.RefKeyword)), indexParameter)
                    .WithBody(body);
                AddExtensionMethod(getOrSetAtMethod);

                void AddExtensionMethod(MethodDeclarationSyntax extensionMethod)
                {
                    string thisParameter = extensionMethod.ParameterList.Parameters[0].Type!.ToString();
                    if (!this.inlineArrayIndexerExtensionsMembers.Any(m => m.Identifier.ValueText == extensionMethod.Identifier.ValueText && m.ParameterList.Parameters[0].Type!.ToString() == thisParameter))
                    {
                        this.inlineArrayIndexerExtensionsMembers.Add(extensionMethod);
                    }
                }

                return (fixedLengthStructName, List<MemberDeclarationSyntax>().Add(fixedLengthStruct));
            }

            if (this.options.ComInterop.StructsInsteadOfInterfaces)
            {
                // If the field is a delegate type, we have to replace that with a native function pointer to avoid the struct becoming a 'managed type'.
                if (originalType is PointerTypeSyntax { ElementType: IdentifierNameSyntax idName } && this.IsDelegateReference(idName, out TypeDefinition typeDef))
                {
                    return (this.FunctionPointer(typeDef), default);
                }
                else if (originalType is IdentifierNameSyntax idName2 && this.IsDelegateReference(idName2, out typeDef))
                {
                    return (this.FunctionPointer(typeDef), default);
                }
            }

            // If the field is a pointer to a COM interface (and we're using bona fide interfaces),
            // then we must type it as an array.
            if (fieldTypeHandleInfo is PointerTypeHandleInfo ptr3 && this.IsManagedType(ptr3.ElementType))
            {
                return (ArrayType(ptr3.ElementType.ToTypeSyntax(typeSettings, null).Type).AddRankSpecifiers(ArrayRankSpecifier()), default);
            }

            return (originalType, default);
        }

        internal FunctionPointerTypeSyntax FunctionPointer(TypeDefinition delegateType)
        {
            CustomAttribute ufpAtt = delegateType.GetCustomAttributes().Select(ah => this.mr.GetCustomAttribute(ah)).Single(a => this.IsAttribute(a, SystemRuntimeInteropServices, nameof(UnmanagedFunctionPointerAttribute)));
            var attArgs = ufpAtt.DecodeValue(CustomAttributeTypeProvider.Instance);
            CallingConvention callingConvention = (CallingConvention)attArgs.FixedArguments[0].Value!;

            this.GetSignatureForDelegate(delegateType, out MethodDefinition invokeMethodDef, out MethodSignature<TypeHandleInfo> signature, out CustomAttributeHandleCollection? returnTypeAttributes);
            if (returnTypeAttributes?.Any(h => this.IsAttribute(this.mr.GetCustomAttribute(h), SystemRuntimeInteropServices, nameof(MarshalAsAttribute))) is true)
            {
                throw new NotSupportedException("Marshaling is not supported for function pointers.");
            }

            return this.FunctionPointer(invokeMethodDef, signature, this.mr.GetString(delegateType.Name));
        }

        internal bool IsDelegate(TypeDefinition typeDef) => (typeDef.Attributes & TypeAttributes.Class) == TypeAttributes.Class && typeDef.BaseType.Kind == HandleKind.TypeReference && this.mr.StringComparer.Equals(this.mr.GetTypeReference((TypeReferenceHandle)typeDef.BaseType).Name, nameof(MulticastDelegate));

        private bool IsTypeDefStruct(IdentifierNameSyntax? identifierName)
        {
            if (identifierName is object && this.typesByName.TryGetValue(identifierName.Identifier.ValueText, out TypeDefinitionHandle value))
            {
                TypeDefinition typeDef = this.mr.GetTypeDefinition(value);
                return this.IsTypeDefStruct(typeDef);
            }

            return false;
        }

        private bool IsDelegateReference(IdentifierNameSyntax? identifierName, out TypeDefinition delegateTypeDef)
        {
            if (identifierName is object)
            {
                if (this.typesByName.TryGetValue(identifierName.Identifier.ValueText, out TypeDefinitionHandle value))
                {
                    delegateTypeDef = this.mr.GetTypeDefinition(value);
                    return this.IsDelegate(delegateTypeDef);
                }
            }

            delegateTypeDef = default;
            return false;
        }

        internal bool IsManagedType(TypeHandleInfo typeHandleInfo)
        {
            TypeHandleInfo elementType =
                typeHandleInfo is PointerTypeHandleInfo ptr ? ptr.ElementType :
                typeHandleInfo is ArrayTypeHandleInfo array ? array.ElementType :
                typeHandleInfo;
            if (elementType is PointerTypeHandleInfo ptr2)
            {
                return this.IsManagedType(ptr2.ElementType);
            }
            else if (elementType is PrimitiveTypeHandleInfo)
            {
                return false;
            }
            else if (elementType is HandleTypeHandleInfo { Handle: { Kind: HandleKind.TypeDefinition } typeDefHandle })
            {
                return this.IsManagedType((TypeDefinitionHandle)typeDefHandle);
            }
            else if (elementType is HandleTypeHandleInfo { Handle: { Kind: HandleKind.TypeReference } typeRefHandle } handleElement)
            {
                var trh = (TypeReferenceHandle)typeRefHandle;
                if (this.TryGetTypeDefHandle(trh, out TypeDefinitionHandle tdr))
                {
                    return this.IsManagedType(tdr);
                }

                // If the type comes from an external assembly, assume that structs are blittable and anything else is not.
                var tr = this.mr.GetTypeReference(trh);
                if (tr.ResolutionScope.Kind == HandleKind.AssemblyReference && handleElement.RawTypeKind is byte kind)
                {
                    // Structs set 0x1, classes set 0x2.
                    return (kind & 0x1) == 0;
                }
            }

            throw new GenerationFailedException("Unrecognized type.");
        }

        private bool IsManagedType(TypeDefinitionHandle typeDefinitionHandle)
        {
            var visitedTypes = new HashSet<TypeDefinitionHandle>();
            return Helper(typeDefinitionHandle)!.Value;

            bool? Helper(TypeDefinitionHandle typeDefinitionHandle)
            {
                if (!visitedTypes.Add(typeDefinitionHandle))
                {
                    // Avoid recursion. We just don't know the answer yet.
                    return null;
                }

                TypeDefinition typeDef = this.mr.GetTypeDefinition(typeDefinitionHandle);
                try
                {
                    if ((typeDef.Attributes & TypeAttributes.Interface) == TypeAttributes.Interface)
                    {
                        return !this.options.ComInterop.StructsInsteadOfInterfaces;
                    }

                    this.GetBaseTypeInfo(typeDef, out StringHandle baseName, out StringHandle baseNamespace);
                    if (this.mr.StringComparer.Equals(baseName, nameof(ValueType)) && this.mr.StringComparer.Equals(baseNamespace, nameof(System)))
                    {
                        if (this.IsTypeDefStruct(typeDef))
                        {
                            return false;
                        }
                        else
                        {
                            foreach (FieldDefinitionHandle fieldHandle in typeDef.GetFields())
                            {
                                FieldDefinition fieldDef = this.mr.GetFieldDefinition(fieldHandle);
                                try
                                {
                                    TypeHandleInfo elementType = fieldDef.DecodeSignature(SignatureHandleProvider.Instance, null);
                                    while (elementType is ITypeHandleContainer container)
                                    {
                                        elementType = container.ElementType;
                                    }

                                    if (elementType is PrimitiveTypeHandleInfo)
                                    {
                                        // These are never managed.
                                        continue;
                                    }
                                    else if (elementType is HandleTypeHandleInfo { Handle: { Kind: HandleKind.TypeDefinition } fieldTypeDefHandle })
                                    {
                                        if (Helper((TypeDefinitionHandle)fieldTypeDefHandle) is true)
                                        {
                                            return true;
                                        }
                                    }
                                    else if (elementType is HandleTypeHandleInfo { Handle: { Kind: HandleKind.TypeReference } fieldTypeRefHandle })
                                    {
                                        if (this.TryGetTypeDefHandle((TypeReferenceHandle)fieldTypeRefHandle, out TypeDefinitionHandle tdr) && Helper(tdr) is true)
                                        {
                                            return true;
                                        }
                                    }
                                    else
                                    {
                                        throw new GenerationFailedException("Unrecognized type.");
                                    }
                                }
                                catch (Exception ex)
                                {
                                    throw new GenerationFailedException($"Unable to ascertain whether the {this.mr.GetString(fieldDef.Name)} field represents a managed type.", ex);
                                }
                            }

                            return false;
                        }
                    }
                    else if (this.mr.StringComparer.Equals(baseName, nameof(Enum)) && this.mr.StringComparer.Equals(baseNamespace, nameof(System)))
                    {
                        return false;
                    }
                    else if (this.mr.StringComparer.Equals(baseName, nameof(MulticastDelegate)) && this.mr.StringComparer.Equals(baseNamespace, nameof(System)))
                    {
                        // Delegates appear as unmanaged function pointers when using structs instead of COM interfaces.
                        return !this.options.ComInterop.StructsInsteadOfInterfaces;
                    }

                    throw new NotSupportedException();
                }
                catch (Exception ex)
                {
                    throw new GenerationFailedException($"Unable to determine if {new HandleTypeHandleInfo(this.mr, typeDefinitionHandle).ToTypeSyntax(this.errorMessageTypeSettings, null)} is a managed type.", ex);
                }
            }
        }

        private UnmanagedType? GetUnmanagedType(BlobHandle blobHandle)
        {
            if (blobHandle.IsNil)
            {
                return null;
            }

            BlobReader br = this.mr.GetBlobReader(blobHandle);
            UnmanagedType unmgdType = (UnmanagedType)br.ReadByte();
            return unmgdType;
        }

        private MarshalAsAttribute ToMarshalAsAttribute(BlobHandle blobHandle)
        {
            BlobReader br = this.mr.GetBlobReader(blobHandle);
            UnmanagedType unmgdType = (UnmanagedType)br.ReadByte();
            MarshalAsAttribute ma = new MarshalAsAttribute(unmgdType);
            switch (unmgdType)
            {
                case UnmanagedType.Interface:
                case UnmanagedType.IUnknown:
                case UnmanagedType.IDispatch:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.IidParameterIndex = br.ReadCompressedInteger();
                    break;

                case UnmanagedType.ByValArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeConst = br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.ArraySubType = (UnmanagedType)br.ReadCompressedInteger();

                    break;

                case UnmanagedType.SafeArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SafeArraySubType = (VarEnum)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }
                    ////string udtName = br.ReadSerializedString();
                    ////ma.SafeArrayUserDefinedSubType = Helpers.LoadTypeFromAssemblyQualifiedName(udtName, module.GetRoAssembly(), ignoreCase: false, throwOnError: false);
                    break;

                case UnmanagedType.LPArray:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.ArraySubType = (UnmanagedType)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeParamIndex = (short)br.ReadCompressedInteger();

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.SizeConst = br.ReadCompressedInteger();
                    break;

                case UnmanagedType.CustomMarshaler:
                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    br.ReadSerializedString(); // Skip the typelib guid.

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    br.ReadSerializedString(); // Skip name of native type.

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.MarshalType = br.ReadSerializedString();
                    ////ma.MarshalTypeRef = Helpers.LoadTypeFromAssemblyQualifiedName(ma.MarshalType, module.GetRoAssembly(), ignoreCase: false, throwOnError: false);

                    if (br.RemainingBytes == 0)
                    {
                        break;
                    }

                    ma.MarshalCookie = br.ReadSerializedString();
                    break;

                default:
                    break;
            }

            return ma;
        }

        private ExpressionSyntax ToExpressionSyntax(Constant constant)
        {
            var blobReader = this.mr.GetBlobReader(constant.Value);
            return constant.TypeCode switch
            {
                ConstantTypeCode.Boolean => blobReader.ReadBoolean() ? LiteralExpression(SyntaxKind.TrueLiteralExpression) : LiteralExpression(SyntaxKind.FalseLiteralExpression),
                ConstantTypeCode.Char => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadChar())),
                ConstantTypeCode.SByte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadSByte())),
                ConstantTypeCode.Byte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadByte())),
                ConstantTypeCode.Int16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt16())),
                ConstantTypeCode.UInt16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt16())),
                ConstantTypeCode.Int32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt32())),
                ConstantTypeCode.UInt32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt32())),
                ConstantTypeCode.Int64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadInt64())),
                ConstantTypeCode.UInt64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadUInt64())),
                ConstantTypeCode.Single => FloatExpression(blobReader.ReadSingle()),
                ConstantTypeCode.Double => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(blobReader.ReadDouble())),
                ConstantTypeCode.String => blobReader.ReadConstant(constant.TypeCode) is string value ? LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(value)) : LiteralExpression(SyntaxKind.NullLiteralExpression),
                ConstantTypeCode.NullReference => LiteralExpression(SyntaxKind.NullLiteralExpression),
                _ => throw new NotSupportedException("ConstantTypeCode not supported: " + constant.TypeCode),
            };

            static ExpressionSyntax FloatExpression(float value)
            {
                return
                    float.IsPositiveInfinity(value) ? MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, PredefinedType(Token(SyntaxKind.FloatKeyword)), IdentifierName(nameof(float.PositiveInfinity))) :
                    float.IsNegativeInfinity(value) ? MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, PredefinedType(Token(SyntaxKind.FloatKeyword)), IdentifierName(nameof(float.NegativeInfinity))) :
                    float.IsNaN(value) ? MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, PredefinedType(Token(SyntaxKind.FloatKeyword)), IdentifierName(nameof(float.NaN))) :
                    LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(value));
            }
        }

        private ExpressionSyntax ToHexExpressionSyntax(Constant constant)
        {
            var blobReader = this.mr.GetBlobReader(constant.Value);
            var blobReader2 = this.mr.GetBlobReader(constant.Value);
            return constant.TypeCode switch
            {
                ConstantTypeCode.SByte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadSByte()), blobReader2.ReadSByte())),
                ConstantTypeCode.Byte => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadByte()), blobReader2.ReadByte())),
                ConstantTypeCode.Int16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt16()), blobReader2.ReadInt16())),
                ConstantTypeCode.UInt16 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt16()), blobReader2.ReadUInt16())),
                ConstantTypeCode.Int32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt32()), blobReader2.ReadInt32())),
                ConstantTypeCode.UInt32 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt32()), blobReader2.ReadUInt32())),
                ConstantTypeCode.Int64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadInt64()), blobReader2.ReadInt64())),
                ConstantTypeCode.UInt64 => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(ToHex(blobReader.ReadUInt64()), blobReader2.ReadUInt64())),
                _ => throw new NotSupportedException("ConstantTypeCode not supported: " + constant.TypeCode),
            };

            unsafe string ToHex<T>(T value)
                where T : unmanaged
            {
                int fullHexLength = sizeof(T) * 2;
                string hex = string.Format(CultureInfo.InvariantCulture, "0x{0:X" + fullHexLength + "}", value);
                return hex;
            }
        }
    }
}
