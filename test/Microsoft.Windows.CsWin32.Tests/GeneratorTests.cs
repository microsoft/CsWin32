// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Collections.Immutable;
using System.Reflection;
using System.Reflection.Metadata;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using VerifyTest = Microsoft.CodeAnalysis.CSharp.Testing.CSharpSourceGeneratorTest<Microsoft.Windows.CsWin32.SourceGenerator, Microsoft.CodeAnalysis.Testing.Verifiers.XUnitVerifier>;

public class GeneratorTests : IDisposable, IAsyncLifetime
{
    private const string WinRTCustomMarshalerClass = "WinRTCustomMarshaler";
    private const string WinRTCustomMarshalerNamespace = "Windows.Win32.CsWin32.InteropServices";
    private const string WinRTCustomMarshalerFullName = WinRTCustomMarshalerNamespace + "." + WinRTCustomMarshalerClass;

    private static readonly GeneratorOptions DefaultTestGeneratorOptions = new GeneratorOptions { EmitSingleFile = true };
    private static readonly string FileSeparator = new string('=', 140);
    private static readonly string MetadataPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location!)!, "Windows.Win32.winmd");
    ////private static readonly string DiaMetadataPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location!)!, "Microsoft.Dia.winmd");
    private static readonly string ApiDocsPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location!)!, "apidocs.msgpack");
    private static readonly string CsWin32StampContent = $@"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
[assembly: global::System.Reflection.AssemblyMetadata(""Microsoft.Windows.CsWin32"",""{ThisAssembly.AssemblyInformationalVersion}"")]
".Replace("\r\n", "\n");

    private readonly ITestOutputHelper logger;
    private readonly Dictionary<string, CSharpCompilation> starterCompilations = new();
    private readonly Dictionary<string, ImmutableArray<string>> preprocessorSymbolsByTfm = new();
    private CSharpCompilation compilation;
    private CSharpParseOptions parseOptions;
    private Generator? generator;

    public GeneratorTests(ITestOutputHelper logger)
    {
        this.logger = logger;

        this.parseOptions = CSharpParseOptions.Default
            .WithDocumentationMode(DocumentationMode.Diagnose)
            .WithLanguageVersion(LanguageVersion.CSharp9);

        // set in InitializeAsync
        this.compilation = null!;
    }

    public enum MarshalingOptions
    {
        NoMarshaling,
        MarshalingWithoutSafeHandles,
        FullMarshaling,
    }

    public static IEnumerable<object[]> TFMData =>
        new object[][]
        {
            new object[] { "net35" },
            new object[] { "net472" },
            new object[] { "netstandard2.0" },
            new object[] { "net6.0" },
        };

    public static IEnumerable<object[]> TFMDataNoNetFx35 =>
        new object[][]
        {
            new object[] { "net472" },
            new object[] { "netstandard2.0" },
            new object[] { "net6.0" },
        };

    public static Platform[] SpecificCpuArchitectures =>
        new Platform[]
        {
            Platform.X86,
            Platform.X64,
            Platform.Arm64,
        };

    public static Platform[] AnyCpuArchitectures =>
        new Platform[]
        {
            Platform.AnyCpu,
            Platform.X86,
            Platform.X64,
            Platform.Arm64,
        };

    public static IEnumerable<object[]> AvailableMacros => Generator.AvailableMacros.Select(name => new object[] { name });

    public async Task InitializeAsync()
    {
        this.starterCompilations.Add("net35", await this.CreateCompilationAsync(MyReferenceAssemblies.NetFramework.Net35));
        this.starterCompilations.Add("net472", await this.CreateCompilationAsync(MyReferenceAssemblies.NetFramework.Net472));
        this.starterCompilations.Add("netstandard2.0", await this.CreateCompilationAsync(MyReferenceAssemblies.NetStandard20));
        this.starterCompilations.Add("net6.0", await this.CreateCompilationAsync(MyReferenceAssemblies.Net.Net60));
        this.starterCompilations.Add("net6.0-x86", await this.CreateCompilationAsync(MyReferenceAssemblies.Net.Net60, Platform.X86));
        this.starterCompilations.Add("net6.0-x64", await this.CreateCompilationAsync(MyReferenceAssemblies.Net.Net60, Platform.X64));
        this.starterCompilations.Add("net7.0", await this.CreateCompilationAsync(MyReferenceAssemblies.Net.Net70));

        foreach (string tfm in this.starterCompilations.Keys)
        {
            if (tfm.StartsWith("net6") || tfm.StartsWith("net7"))
            {
                AddSymbols("NET5_0_OR_GREATER", "NET6_0_OR_GREATER", "NET6_0");
            }

            if (tfm.StartsWith("net7"))
            {
                AddSymbols("NET7_0_OR_GREATER", "NET7_0");
            }

            // Guarantee we have at least an empty list of symbols for each TFM.
            AddSymbols();

            void AddSymbols(params string[] symbols)
            {
                if (!this.preprocessorSymbolsByTfm.TryAdd(tfm, symbols.ToImmutableArray()))
                {
                    this.preprocessorSymbolsByTfm[tfm] = this.preprocessorSymbolsByTfm[tfm].AddRange(symbols);
                }
            }
        }

        this.compilation = this.starterCompilations["netstandard2.0"];
    }

    public Task DisposeAsync() => Task.CompletedTask;

    public void Dispose()
    {
        this.generator?.Dispose();
    }

    [Theory, PairwiseData]
    public void AssemblyAttributeGenerated(bool emitSingleFile)
    {
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { EmitSingleFile = emitSingleFile });
        Assert.True(this.generator.TryGenerate("GetTickCount", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        IEnumerable<AttributeSyntax> assemblyMetadataAttributes =
            from tree in this.compilation.SyntaxTrees
            from attributeList in tree.GetCompilationUnitRoot().AttributeLists
            where attributeList.Target?.Identifier.IsKind(SyntaxKind.AssemblyKeyword) is true
            from attribute in attributeList.Attributes
            where attribute.Name.ToString() == "global::System.Reflection.AssemblyMetadata"
            select attribute;
        AttributeSyntax cswin32Stamp = Assert.Single(assemblyMetadataAttributes);
        Assert.Equal("Microsoft.Windows.CsWin32", ((LiteralExpressionSyntax?)cswin32Stamp.ArgumentList?.Arguments[0].Expression)?.Token.Value);
        Assert.Equal(ThisAssembly.AssemblyInformationalVersion, ((LiteralExpressionSyntax?)cswin32Stamp.ArgumentList?.Arguments[1].Expression)?.Token.Value);
    }

    [Fact]
    public void NoGeneration()
    {
        this.generator = this.CreateGenerator();
        Assert.Empty(this.generator.GetCompilationUnits(CancellationToken.None));
    }

    [Theory]
    [InlineData("COPYFILE2_CALLBACK_NONE", "COPYFILE2_MESSAGE_TYPE")]
    [InlineData("RTL_RUN_ONCE_ASYNC", null)]
    [InlineData("__zz__not_defined", null)]
    public void TryGetEnumName(string candidate, string? declaringEnum)
    {
        this.generator = this.CreateGenerator();

        Assert.Equal(declaringEnum is object, this.generator.TryGetEnumName(candidate, out string? actualDeclaringEnum));
        Assert.Equal(declaringEnum, actualDeclaringEnum);
    }

    [Theory]
    [MemberData(nameof(TFMData))]
    public void SimplestMethod(string tfm)
    {
        this.compilation = this.starterCompilations[tfm];
        this.generator = this.CreateGenerator(includeDocs: true);
        const string methodName = "GetTickCount";
        Assert.True(this.generator.TryGenerateExternMethod(methodName, out _));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        var generatedMethod = this.FindGeneratedMethod(methodName).Single();
        if (tfm == "net6.0")
        {
            Assert.Contains(generatedMethod.AttributeLists, al => IsAttributePresent(al, "SupportedOSPlatform"));
        }
        else
        {
            Assert.DoesNotContain(generatedMethod.AttributeLists, al => IsAttributePresent(al, "SupportedOSPlatform"));
        }

        if (tfm != "net35")
        {
            Assert.Contains(generatedMethod.AttributeLists, al => IsAttributePresent(al, "DefaultDllImportSearchPaths"));
        }
    }

    [Fact]
    public void DbgHelpExternMethodsCanLoadAppLocal()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerateExternMethod("DbgHelpCreateUserDump", out _));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        MethodDeclarationSyntax method = Assert.Single(this.FindGeneratedMethod("DbgHelpCreateUserDump"), m => m.Modifiers.Any(SyntaxKind.ExternKeyword));
        AttributeSyntax searchPathsAttribute = Assert.Single(method.AttributeLists.SelectMany(al => al.Attributes), a => a.Name is IdentifierNameSyntax { Identifier: { ValueText: "DefaultDllImportSearchPaths" } });
        Assert.NotNull(searchPathsAttribute.ArgumentList);
        Assert.Single(searchPathsAttribute.ArgumentList.DescendantNodes().OfType<IdentifierNameSyntax>(), id => id.Identifier.ValueText == nameof(DllImportSearchPath.ApplicationDirectory));
    }

    [Theory]
    [PairwiseData]
    public void TemplateProvidedMembersMatchVisibilityWithContainingType_Methods(bool generatePublic)
    {
        this.generator = this.CreateGenerator(new GeneratorOptions { Public = generatePublic });
        Assert.True(this.generator.TryGenerate("HRESULT", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        MethodDeclarationSyntax? generatedMethod = this.FindGeneratedMethod("ThrowOnFailure").Single();
        SyntaxKind expectedVisibility = generatePublic ? SyntaxKind.PublicKeyword : SyntaxKind.InternalKeyword;
        Assert.True(generatedMethod.Modifiers.Any(expectedVisibility));
    }

    [Theory]
    [PairwiseData]
    public void TemplateProvidedMembersMatchVisibilityWithContainingType_OtherMemberTypes(bool generatePublic)
    {
        this.generator = this.CreateGenerator(new GeneratorOptions { Public = generatePublic });
        Assert.True(this.generator.TryGenerate("PCSTR", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        StructDeclarationSyntax pcstrType = (StructDeclarationSyntax)this.FindGeneratedType("PCSTR").Single();
        SyntaxKind expectedVisibility = generatePublic ? SyntaxKind.PublicKeyword : SyntaxKind.InternalKeyword;

        // Assert fields
        Assert.Contains(pcstrType.Members.OfType<FieldDeclarationSyntax>(), f => f.Declaration.Variables.Any(v => v.Identifier.ValueText == "Value") && f.Modifiers.Any(expectedVisibility));

        // Assert properties
        Assert.Contains(pcstrType.Members.OfType<PropertyDeclarationSyntax>(), p => p.Identifier.ValueText == "Length" && p.Modifiers.Any(expectedVisibility));

        // Assert constructors
        Assert.All(pcstrType.Members.OfType<ConstructorDeclarationSyntax>(), c => c.Modifiers.Any(expectedVisibility));

        // Assert that private members remain private.
        Assert.Contains(pcstrType.Members.OfType<PropertyDeclarationSyntax>(), p => p.Identifier.ValueText == "DebuggerDisplay" && p.Modifiers.Any(SyntaxKind.PrivateKeyword));
    }

    [Fact]
    public void SupportedOSPlatform_AppearsOnFriendlyOverloads()
    {
        const string methodName = "GetStagedPackagePathByFullName2";
        this.compilation = this.starterCompilations["net6.0"];
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(methodName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.All(this.FindGeneratedMethod(methodName), method => Assert.Contains(method.AttributeLists, al => IsAttributePresent(al, "SupportedOSPlatform")));
    }

    [Theory, PairwiseData]
    public void COMInterfaceWithSupportedOSPlatform(bool net60, bool allowMarshaling)
    {
        this.compilation = this.starterCompilations[net60 ? "net6.0" : "netstandard2.0"];
        const string typeName = "IInkCursors";
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling });
        Assert.True(this.generator.TryGenerateType(typeName));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        var iface = this.FindGeneratedType(typeName).Single();

        if (net60)
        {
            Assert.Contains(iface.AttributeLists, al => IsAttributePresent(al, "SupportedOSPlatform"));
        }
        else
        {
            Assert.DoesNotContain(iface.AttributeLists, al => IsAttributePresent(al, "SupportedOSPlatform"));
        }
    }

    [Theory]
    [CombinatorialData]
    public void InterestingAPIs(
        [CombinatorialValues(
            "PSTR",
            "PWSTR",
            "PCSTR",
            "PCWSTR",
            "PZZSTR",
            "PZZWSTR",
            "PCZZSTR",
            "PCZZWSTR",
            "IRealTimeStylusSynchronization", // uses the `lock` C# keyword.
            "IHTMLInputElement", // has a field named `checked`, a C# keyword.
            "NCryptImportKey", // friendly overload takes SafeHandle backed by a UIntPtr instead of IntPtr
            "IUIAutomation", // non-preservesig retval COM method with a array size index parameter
            "IHTMLWindow2", // contains properties named with C# reserved keywords
            "CreateFile", // built-in SafeHandle use
            "CreateCursor", // 0 or -1 invalid SafeHandle generated
            "PlaySound", // 0 invalid SafeHandle generated
            "SLIST_HEADER", // Union struct that defined uniquely for each CPU architecture
            "PROFILER_HEAP_OBJECT_OPTIONAL_INFO",
            "MI_Instance", // recursive type where managed testing gets particularly tricky
            "CertFreeCertificateChainList", // double pointer extern method
            "D3DGetTraceInstructionOffsets", // SizeParamIndex
            "PlgBlt", // SizeConst
            "IWebBrowser", // Navigate method has an [In, Optional] object parameter
            "ENABLE_TRACE_PARAMETERS_V1", // bad xml created at some point.
            "JsRuntimeVersion", // An enum that has an extra member in a separate header file.
            "ReportEvent", // Failed at one point
            "DISPLAYCONFIG_VIDEO_SIGNAL_INFO", // Union, explicit layout, bitmask, nested structs
            "g_wszStreamBufferRecordingDuration", // Constant string field
            "MFVideoAlphaBitmap", // field named params
            "DDRAWI_DDVIDEOPORT_INT", // field that is never used
            "MainAVIHeader", // dwReserved field is a fixed length array
            "HBMMENU_POPUP_RESTORE", // A HBITMAP handle as a constant
            "RpcServerRegisterIfEx", // Optional attribute on delegate type.
            "RpcSsSwapClientAllocFree", // Parameters typed as pointers to in delegates and out delegates
            "RPC_DISPATCH_TABLE", // Struct with a field typed as a delegate
            "RPC_SERVER_INTERFACE", // Struct with a field typed as struct with a field typed as a delegate
            "DDHAL_DESTROYDRIVERDATA", // Struct with a field typed as a delegate
            "I_RpcServerInqAddressChangeFn", // p/invoke that returns a function pointer
            "WSPUPCALLTABLE", // a delegate with a delegate in its signature
            "HWND_BOTTOM", // A constant typed as a typedef'd struct
            "BOOL", // a special cased typedef struct
            "uregex_getMatchCallback", // friendly overload with delegate parameter, and out parameters
            "CreateDispatcherQueueController", // References a WinRT type
            "RegOpenKey", // allocates a handle with a release function that returns LSTATUS
            "LsaRegisterLogonProcess", // allocates a handle with a release function that returns NTSTATUS
            "FilterCreate", // allocates a handle with a release function that returns HRESULT
            "DsGetDcOpen", // allocates a handle with a release function that returns HRESULT
            "DXVAHDSW_CALLBACKS", // pointers to handles
            "HBITMAP_UserMarshal", // in+out handle pointer
            "GetDiskFreeSpaceExW", // ULARGE_INTEGER replaced with keyword: ulong.
            "MsiGetProductPropertyW", // MSIHANDLE (a 32-bit handle)
            "TCP_OPT_SACK", // nested structs with inline arrays with nested struct elements
            "HANDLETABLE", // nested structs with inline arrays with nint element
            "SYSTEM_POLICY_INFORMATION", // nested structs with inline arrays with IntPtr element
            "D3D11_BLEND_DESC1", // nested structs with inline arrays with element that is NOT nested
            "RTM_DEST_INFO", // nested structs with inline arrays with element whose name collides with another
            "DISPPARAMS",
            "PICTYPE", // An enum with -1 as an enum value
            "CoCreateInstance", // a hand-written friendly overload
            "JsVariantToValue",
            "D2D1_DEFAULT_FLATTENING_TOLERANCE", // a float constant
            "WIA_CATEGORY_FINISHED_FILE", // GUID constant
            "DEVPKEY_MTPBTH_IsConnected", // DEVPROPKEY constant
            "PKEY_AudioEndpoint_FormFactor", // PROPERTYKEY constant
            "RT_CURSOR", // PCWSTR constant
            "IOleUILinkContainerW", // An IUnknown-derived interface with no GUID
            "FILE_TYPE_NOTIFICATION_INPUT",
            "DS_SELECTION_LIST", // A struct with a fixed-length inline array of potentially managed structs
            "ISpellCheckerFactory", // COM interface that includes `ref` parameters
            "LocalSystemTimeToLocalFileTime", // small step
            "WSAHtons", // A method that references SOCKET (which is typed as UIntPtr) so that a SafeHandle will be generated.
            "IDelayedPropertyStoreFactory", // interface inheritance across namespaces
            "D3D9ON12_ARGS", // Contains an inline array of IUnknown objects
            "NCryptOpenKey", // Generates a SafeHandle based on a UIntPtr
            "X509_CERT", // A constant defined as PCSTR
            "CIDLData_CreateFromIDArray", // Method with out parameter of a possibly marshaled interop type shared with the BCL,
            "ID3D12Resource", // COM interface with base types
            "OpenTrace", // the CloseTrace method called by the SafeHandle returns WIN32_ERROR. The handle is ALWAYS 64-bits.
            "QueryTraceProcessingHandle", // uses a handle that is always 64-bits, even in 32-bit processes
            "ID2D1RectangleGeometry")] // COM interface with base types
        string api,
        bool allowMarshaling)
    {
        var options = DefaultTestGeneratorOptions with
        {
            WideCharOnly = false,
            AllowMarshaling = allowMarshaling,
        };
        this.compilation = this.compilation.WithOptions(this.compilation.Options.WithPlatform(Platform.X64));
        this.generator = this.CreateGenerator(options);
        Assert.True(this.generator.TryGenerate(api, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    /// <summary>
    /// Verifies that GetLastError is never generated.
    /// Users should call <see cref="Marshal.GetLastWin32Error"/> instead.
    /// </summary>
    [Fact]
    public void GetLastErrorNotIncludedInBulkGeneration()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("kernel32.*", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        Assert.True(this.IsMethodGenerated("CreateFile"));
        Assert.False(this.IsMethodGenerated("GetLastError"));
    }

    [Theory, PairwiseData]
    public void WildcardForConstants(bool withNamespace)
    {
        this.generator = this.CreateGenerator();
        string ns = withNamespace ? "Windows.Win32.Security.Cryptography." : string.Empty;
        Assert.True(this.generator.TryGenerate(ns + "ALG_SID_MD*", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Single(this.FindGeneratedConstant("ALG_SID_MD2"));
        Assert.Single(this.FindGeneratedConstant("ALG_SID_MD4"));
        Assert.Empty(this.FindGeneratedConstant("ALG_SID_HMAC"));
    }

    [Fact]
    public void WildcardForConstants_NoMatch()
    {
        this.generator = this.CreateGenerator();
        Assert.False(this.generator.TryGenerate("IDONTEXIST*", out IReadOnlyList<string> preciseApi, CancellationToken.None));
        Assert.Empty(preciseApi);
    }

    [Theory, PairwiseData]
    public void UnionWithRefAndValueTypeFields(
        [CombinatorialValues("VARDESC", "VARIANT")] string typeName,
        [CombinatorialValues("net6.0", "net472", "netstandard2.0")] string tfm)
    {
        this.compilation = this.starterCompilations[tfm];
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(typeName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    /// <summary>
    /// Generate APIs that depend on common APIs but in both marshalable and non-marshalable contexts.
    /// </summary>
    [Fact]
    public void UnionWithRefAndValueTypeFields2()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("MI_MethodDecl", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("MI_Value", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Fact]
    public void TypeDefConstantsDeclaredWithinTypeDef()
    {
        const string constant = "S_OK";
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(constant, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        FieldDeclarationSyntax field = this.FindGeneratedConstant(constant).Single();
        StructDeclarationSyntax declaringStruct = Assert.IsType<StructDeclarationSyntax>(field.Parent);
        Assert.Equal("HRESULT", declaringStruct.Identifier.ToString());
    }

    [Fact]
    public void TypeDefConstantsRedirectedToPInvokeWhenTypeDefAlreadyInRefAssembly()
    {
        CSharpCompilation referencedProject = this.compilation.WithAssemblyName("refdProj");

        using var referencedGenerator = this.CreateGenerator(new GeneratorOptions { Public = true }, referencedProject);
        Assert.True(referencedGenerator.TryGenerate("HRESULT", CancellationToken.None));
        referencedProject = this.AddGeneratedCode(referencedProject, referencedGenerator);
        this.AssertNoDiagnostics(referencedProject);

        // Now produce more code in a referencing project that includes at least one of the same types as generated in the referenced project.
        const string constant = "S_OK";
        this.compilation = this.compilation.AddReferences(referencedProject.ToMetadataReference());
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(constant, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        FieldDeclarationSyntax field = this.FindGeneratedConstant(constant).Single();
        ClassDeclarationSyntax declaringClass = Assert.IsType<ClassDeclarationSyntax>(field.Parent);
        Assert.Equal("PInvoke", declaringClass.Identifier.ToString());
    }

    [Theory]
    [InlineData("IDC_ARROW")] // PCWSTR / PWSTR
    public void SpecialTypeDefsDoNotContainTheirOwnConstants(string constantName)
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(constantName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        FieldDeclarationSyntax field = this.FindGeneratedConstant(constantName).Single();
        ClassDeclarationSyntax declaringClass = Assert.IsType<ClassDeclarationSyntax>(field.Parent);
        Assert.Equal("PInvoke", declaringClass.Identifier.ToString());
    }

    [Fact]
    public void FriendlyOverloadOfCOMInterfaceRemovesParameter()
    {
        const string ifaceName = "IEnumDebugPropertyInfo";
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Contains(this.FindGeneratedMethod("Next"), m => m.ParameterList.Parameters.Count == 3 && m.ParameterList.Parameters[0].Modifiers.Any(SyntaxKind.ThisKeyword));
    }

    [Fact]
    public void IDispatchDerivedInterface()
    {
        const string ifaceName = "IInkRectangle";
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
#pragma warning disable CS0618 // Type or member is obsolete
        Assert.Contains(this.FindGeneratedType(ifaceName), t => t.BaseList is null && t.AttributeLists.Any(al => al.Attributes.Any(a => a.Name is IdentifierNameSyntax { Identifier: { ValueText: "InterfaceType" } } && a.ArgumentList?.Arguments[0].Expression is MemberAccessExpressionSyntax { Name: IdentifierNameSyntax { Identifier: { ValueText: nameof(ComInterfaceType.InterfaceIsIDispatch) } } })));
#pragma warning restore CS0618 // Type or member is obsolete
    }

    [Fact]
    public void IInpectableDerivedInterface()
    {
        const string ifaceName = "IUserConsentVerifierInterop";
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Contains(this.FindGeneratedType(ifaceName), t => t.BaseList is null && ((InterfaceDeclarationSyntax)t).Members.Count == 1 && t.AttributeLists.Any(al => al.Attributes.Any(a => a.Name is IdentifierNameSyntax { Identifier: { ValueText: "InterfaceType" } } && a.ArgumentList?.Arguments[0].Expression is MemberAccessExpressionSyntax { Name: IdentifierNameSyntax { Identifier: { ValueText: nameof(ComInterfaceType.InterfaceIsIInspectable) } } })));

        // Make sure the WinRT marshaler was not brought in
        Assert.Empty(this.FindGeneratedType(WinRTCustomMarshalerClass));
    }

    [Theory, PairwiseData]
    public void COMPropertiesAreGeneratedAsInterfaceProperties(bool allowMarshaling)
    {
        const string ifaceName = "IADsClass";
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling });
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        InterfaceDeclarationSyntax ifaceSyntax;
        if (allowMarshaling)
        {
            ifaceSyntax = Assert.Single(this.FindGeneratedType(ifaceName).OfType<InterfaceDeclarationSyntax>());
        }
        else
        {
            StructDeclarationSyntax structSyntax = (StructDeclarationSyntax)Assert.Single(this.FindGeneratedType(ifaceName));
            ifaceSyntax = Assert.Single(structSyntax.Members.OfType<InterfaceDeclarationSyntax>(), m => m.Identifier.ValueText == "Interface");
        }

        // Check a property where we expect just a getter.
        Assert.NotNull(FindAccessor(ifaceSyntax, "PrimaryInterface", SyntaxKind.GetAccessorDeclaration));
        Assert.Null(FindAccessor(ifaceSyntax, "PrimaryInterface", SyntaxKind.SetAccessorDeclaration));

        // Check a property where we expect both a getter and setter.
        Assert.NotNull(FindAccessor(ifaceSyntax, "CLSID", SyntaxKind.GetAccessorDeclaration));
        Assert.NotNull(FindAccessor(ifaceSyntax, "CLSID", SyntaxKind.SetAccessorDeclaration));
    }

    [Theory, PairwiseData]
    public void COMPropertiesAreGeneratedAsInterfaceProperties_NonConsecutiveAccessors(bool allowMarshaling)
    {
        const string ifaceName = "IUIAutomationProxyFactoryEntry";
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling });
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        InterfaceDeclarationSyntax ifaceSyntax;
        if (allowMarshaling)
        {
            ifaceSyntax = Assert.Single(this.FindGeneratedType(ifaceName).OfType<InterfaceDeclarationSyntax>());
        }
        else
        {
            StructDeclarationSyntax structSyntax = (StructDeclarationSyntax)Assert.Single(this.FindGeneratedType(ifaceName));
            ifaceSyntax = Assert.Single(structSyntax.Members.OfType<InterfaceDeclarationSyntax>(), m => m.Identifier.ValueText == "Interface");
        }

        // Check for a property where the interface declares the getter and setter in non-consecutive rows of the VMT.
        Assert.Null(FindAccessor(ifaceSyntax, "ClassName", SyntaxKind.GetAccessorDeclaration));
        Assert.Null(FindAccessor(ifaceSyntax, "ClassName", SyntaxKind.SetAccessorDeclaration));
    }

    [Fact]
    public void COMPropertiesAreGeneratedAsStructProperties()
    {
        const string ifaceName = "IADsClass";
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = false });
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        StructDeclarationSyntax structSyntax = Assert.Single(this.FindGeneratedType(ifaceName).OfType<StructDeclarationSyntax>());

        // Check a property where we expect just a getter.
        Assert.NotNull(FindAccessor(structSyntax, "PrimaryInterface", SyntaxKind.GetAccessorDeclaration));
        Assert.Null(FindAccessor(structSyntax, "PrimaryInterface", SyntaxKind.SetAccessorDeclaration));

        // Check a property where we expect both a getter and setter.
        Assert.NotNull(FindAccessor(structSyntax, "CLSID", SyntaxKind.GetAccessorDeclaration));
        Assert.NotNull(FindAccessor(structSyntax, "CLSID", SyntaxKind.SetAccessorDeclaration));
    }

    [Fact]
    public void COMPropertiesAreGeneratedAsStructProperties_NonConsecutiveAccessors()
    {
        const string ifaceName = "IUIAutomationProxyFactoryEntry";
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = false });
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        StructDeclarationSyntax structSyntax = Assert.Single(this.FindGeneratedType(ifaceName).OfType<StructDeclarationSyntax>());

        // Check for a property where the interface declares the getter and setter in non-consecutive rows of the VMT.
        // For structs, we can still declare both as accessors because we implement them, provided they have the same type.
        Assert.NotNull(FindAccessor(structSyntax, "CanCheckBaseClass", SyntaxKind.GetAccessorDeclaration));
        Assert.NotNull(FindAccessor(structSyntax, "CanCheckBaseClass", SyntaxKind.SetAccessorDeclaration));

        // And in some cases, the types are *not* the same, so don't generate any property.
        Assert.Null(FindAccessor(structSyntax, "ClassName", SyntaxKind.GetAccessorDeclaration));
        Assert.Null(FindAccessor(structSyntax, "ClassName", SyntaxKind.SetAccessorDeclaration));
        Assert.NotEmpty(structSyntax.Members.OfType<MethodDeclarationSyntax>().Where(m => m.Identifier.ValueText == "get_ClassName"));
        Assert.NotEmpty(structSyntax.Members.OfType<MethodDeclarationSyntax>().Where(m => m.Identifier.ValueText == "put_ClassName"));
    }

    /// <summary>
    /// Verifies that IPicture can be generated.
    /// It is a special case because of <see href="https://github.com/microsoft/win32metadata/issues/1367">this metadata bug</see>.
    /// </summary>
    [Fact]
    public void COMPropertiesAreGeneratedAsStructProperties_NonConsecutiveAccessors_IPicture()
    {
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = false });
        Assert.True(this.generator.TryGenerate("IPicture", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Theory, PairwiseData]
    public void COMPropertiesAreGeneratedAsMethodsWhenTheirReturnTypesDiffer([CombinatorialValues(0, 1, 2)] int marshaling)
    {
        const string ifaceName = "IHTMLImgElement";
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = marshaling > 0, ComInterop = new GeneratorOptions.ComInteropOptions { UseIntPtrForComOutPointers = marshaling == 1 } });
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        InterfaceDeclarationSyntax ifaceSyntax;
        if (marshaling > 0)
        {
            ifaceSyntax = Assert.Single(this.FindGeneratedType(ifaceName).OfType<InterfaceDeclarationSyntax>());
        }
        else
        {
            StructDeclarationSyntax structSyntax = (StructDeclarationSyntax)Assert.Single(this.FindGeneratedType(ifaceName));
            ifaceSyntax = Assert.Single(structSyntax.Members.OfType<InterfaceDeclarationSyntax>(), m => m.Identifier.ValueText == "Interface");
        }

        if (marshaling == 1)
        {
            Assert.Empty(ifaceSyntax.Members.OfType<PropertyDeclarationSyntax>().Where(m => m.Identifier.ValueText == "border"));
            Assert.NotEmpty(ifaceSyntax.Members.OfType<MethodDeclarationSyntax>().Where(m => m.Identifier.ValueText == "put_border"));
            Assert.NotEmpty(ifaceSyntax.Members.OfType<MethodDeclarationSyntax>().Where(m => m.Identifier.ValueText == "get_border"));
        }
        else
        {
            Assert.NotNull(FindAccessor(ifaceSyntax, "border", SyntaxKind.GetAccessorDeclaration));
            Assert.NotNull(FindAccessor(ifaceSyntax, "border", SyntaxKind.SetAccessorDeclaration));
        }
    }

    [Fact]
    public void WinRTInterfaceDoesntBringInMarshalerIfParamNotObject()
    {
        const string WinRTInteropInterfaceName = "IGraphicsEffectD2D1Interop";

        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(WinRTInteropInterfaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        // Make sure the WinRT marshaler was not brought in
        Assert.Empty(this.FindGeneratedType(WinRTCustomMarshalerClass));
    }

    [Fact]
    public void WinRTInterfaceWithWinRTOutObjectUsesMarshaler()
    {
        const string WinRTInteropInterfaceName = "ICompositorDesktopInterop";
        const string WinRTClassName = "Windows.UI.Composition.Desktop.DesktopWindowTarget";

        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(WinRTInteropInterfaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        InterfaceDeclarationSyntax interfaceDeclaration = (InterfaceDeclarationSyntax)Assert.Single(this.FindGeneratedType(WinRTInteropInterfaceName));
        MethodDeclarationSyntax method = (MethodDeclarationSyntax)interfaceDeclaration.Members.First();
        ParameterSyntax lastParam = method.ParameterList.Parameters.Last();

        Assert.Equal($"global::{WinRTClassName}", lastParam.Type?.ToString());
        Assert.True(lastParam.Modifiers.Any(SyntaxKind.OutKeyword));

        AttributeSyntax marshalAsAttr = Assert.Single(FindAttribute(lastParam.AttributeLists, "MarshalAs"));

        Assert.True(marshalAsAttr.ArgumentList?.Arguments[0].ToString() == "UnmanagedType.CustomMarshaler");
        Assert.Single(marshalAsAttr.ArgumentList.Arguments.Where(arg => arg.ToString() == $"MarshalCookie = \"{WinRTClassName}\""));
        Assert.Single(marshalAsAttr.ArgumentList.Arguments.Where(arg => arg.ToString() == $"MarshalType = \"{WinRTCustomMarshalerFullName}\""));

        // Make sure the WinRT marshaler was brought in
        Assert.Single(this.FindGeneratedType(WinRTCustomMarshalerClass));
    }

    [Fact]
    public void ComOutPtrTypedAsOutObject()
    {
        const string methodName = "CoCreateInstance";
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(methodName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Contains(this.FindGeneratedMethod(methodName), m => m.ParameterList.Parameters.Last() is { } last && last.Modifiers.Any(SyntaxKind.OutKeyword) && last.Type is PredefinedTypeSyntax { Keyword: { RawKind: (int)SyntaxKind.ObjectKeyword } });
    }

    [Theory, CombinatorialData]
    public void Decimal([CombinatorialValues("net472", "net6.0")] string tfm)
    {
        this.compilation = this.starterCompilations[tfm];
        this.parseOptions = this.parseOptions.WithPreprocessorSymbols(this.preprocessorSymbolsByTfm[tfm]);
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("DECIMAL", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Fact]
    public void ComOutPtrTypedAsIntPtr()
    {
        const string methodName = "CoCreateInstance";
        this.generator = this.CreateGenerator(new GeneratorOptions { ComInterop = new() { UseIntPtrForComOutPointers = true } });
        Assert.True(this.generator.TryGenerate(methodName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Contains(this.FindGeneratedMethod(methodName), m => m.ParameterList.Parameters.Last() is { } last && last.Modifiers.Any(SyntaxKind.OutKeyword) && last.Type is IdentifierNameSyntax { Identifier: { ValueText: "IntPtr" } });
    }

    [Fact]
    public void AmbiguousApiName()
    {
        this.generator = this.CreateGenerator();
        Assert.False(this.generator.TryGenerate("IDENTITY_TYPE", out IReadOnlyList<string> preciseApi, CancellationToken.None));
        Assert.Equal(2, preciseApi.Count);
        Assert.Contains("Windows.Win32.NetworkManagement.NetworkPolicyServer.IDENTITY_TYPE", preciseApi);
        Assert.Contains("Windows.Win32.Security.Authentication.Identity.Provider.IDENTITY_TYPE", preciseApi);
    }

    [Fact]
    public void ObsoleteAttributePropagated()
    {
        const string StructName = "IMAGE_OPTIONAL_HEADER32";
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(StructName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        StructDeclarationSyntax structDecl = (StructDeclarationSyntax)this.FindGeneratedType(StructName).Single();
        (FieldDeclarationSyntax Field, VariableDeclaratorSyntax Variable)? field = this.FindFieldDeclaration(structDecl, "LoaderFlags");
        Assert.NotNull(field);
        Assert.Contains(field!.Value.Field.AttributeLists, al => IsAttributePresent(al, "Obsolete"));
    }

    [Fact]
    public void ReleaseMethodGeneratedWithHandleStruct()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("HANDLE", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.True(this.IsMethodGenerated("CloseHandle"));
    }

    [Theory]
    [InlineData("HANDLE")]
    [InlineData("HGDIOBJ")]
    public void HandleStructsHaveIsNullProperty(string handleName)
    {
        // A null HGDIOBJ has a specific meaning beyond just the concept of an invalid handle:
        // https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject#return-value
        this.AssertGeneratedMember(handleName, "IsNull", "internal bool IsNull => Value == default;");
    }

    [Theory]
    [InlineData("HANDLE")]
    [InlineData("HGDIOBJ")]
    [InlineData("HINSTANCE")]
    public void HandleStructsHaveStaticNullMember(string handleName)
    {
        // A null HGDIOBJ has a specific meaning beyond just the concept of an invalid handle:
        // https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject#return-value
        this.AssertGeneratedMember(handleName, "Null", $"internal static {handleName} Null => default;");
    }

    [Theory, PairwiseData]
    public void MacroAPIsGenerateWithAppropriateVisibility(bool publicVisibility)
    {
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { Public = publicVisibility });
        Assert.True(this.generator.TryGenerate("HRESULT_FROM_WIN32", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        var method = Assert.Single(this.FindGeneratedMethod("HRESULT_FROM_WIN32"));

        Assert.True(method.Modifiers.Any(publicVisibility ? SyntaxKind.PublicKeyword : SyntaxKind.InternalKeyword));
    }

    [Theory]
    [MemberData(nameof(AvailableMacros))]
    public void MacroAPIsGenerate(string macro)
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(macro, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Single(this.FindGeneratedMethod(macro));
    }

    [Theory]
    [InlineData("BOOL")]
    [InlineData("BOOLEAN")]
    [InlineData("HRESULT")]
    [InlineData("NTSTATUS")]
    [InlineData("PCSTR")]
    [InlineData("PCWSTR")]
    [InlineData("RECT")]
    [InlineData("SIZE")]
    [InlineData("SYSTEMTIME")]
    public void TemplateAPIsGenerate(string handleType)
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(handleType, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Theory]
    [InlineData("HANDLE")]
    [InlineData("HGDIOBJ")]
    [InlineData("HWND")]
    public void HandleTypeDefsUseIntPtrAsFieldType(string handleType)
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(handleType, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        StructDeclarationSyntax hwnd = Assert.IsType<StructDeclarationSyntax>(this.FindGeneratedType(handleType).Single());
        FieldDeclarationSyntax field = hwnd.Members.OfType<FieldDeclarationSyntax>().Single();
        Assert.Equal(nameof(IntPtr), Assert.IsType<IdentifierNameSyntax>(field.Declaration.Type).Identifier.ValueText);
    }

    [Fact]
    public void HasGeneratedCodeAttribute()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("IDebugDocumentInfo", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("HANDLE", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("INPUT_RECORD", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("GetTickCount", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("ACTIVATE_KEYBOARD_LAYOUT_FLAGS", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("PAINTSTRUCT", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        InterfaceDeclarationSyntax interfaceDecl = Assert.IsType<InterfaceDeclarationSyntax>(this.FindGeneratedType("IDebugDocumentInfo").Single());
        Assert.Contains(interfaceDecl.AttributeLists, al => al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode")));

        StructDeclarationSyntax handle = Assert.IsType<StructDeclarationSyntax>(this.FindGeneratedType("HANDLE").Single());
        Assert.Contains(handle.AttributeLists, al => al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode")));

        StructDeclarationSyntax structDecl = Assert.IsType<StructDeclarationSyntax>(this.FindGeneratedType("INPUT_RECORD").Single());
        Assert.Contains(structDecl.AttributeLists, al => al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode")));

        IEnumerable<ClassDeclarationSyntax> pInvokeClass = this.FindGeneratedType("PInvoke").OfType<ClassDeclarationSyntax>();
        Assert.Contains(pInvokeClass, c => c.AttributeLists.Any(al => al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode"))));

        EnumDeclarationSyntax enumDecl = Assert.IsType<EnumDeclarationSyntax>(this.FindGeneratedType("ACTIVATE_KEYBOARD_LAYOUT_FLAGS").Single());
        Assert.Contains(enumDecl.AttributeLists, al => al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode")));

        ClassDeclarationSyntax arrayExtensions = Assert.IsType<ClassDeclarationSyntax>(this.FindGeneratedType("InlineArrayIndexerExtensions").Single());
        Assert.Contains(arrayExtensions.AttributeLists, al => al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode")));

        ClassDeclarationSyntax overloadsExtensions = Assert.IsType<ClassDeclarationSyntax>(this.FindGeneratedType("FriendlyOverloadExtensions").Single());
        Assert.Contains(overloadsExtensions.AttributeLists, al => al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode")));

        ClassDeclarationSyntax sysFreeStringSafeHandleClass = Assert.IsType<ClassDeclarationSyntax>(this.FindGeneratedType("SysFreeStringSafeHandle").Single());
        Assert.Contains(overloadsExtensions.AttributeLists, al => al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode")));
    }

    [Fact]
    public void NamespaceHandleGetsNoSafeHandle()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("CreatePrivateNamespace", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Empty(this.FindGeneratedType("ClosePrivateNamespaceSafeHandle"));
    }

    [Fact]
    public void CreateFileUsesSafeHandles()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("CreateFile", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        Assert.Contains(
            this.FindGeneratedMethod("CreateFile"),
            createFileMethod => createFileMethod!.ReturnType.ToString() == "Microsoft.Win32.SafeHandles.SafeFileHandle"
                && createFileMethod.ParameterList.Parameters.Last().Type?.ToString() == "SafeHandle");
    }

    /// <summary>
    /// GetMessage should return BOOL rather than bool because it actually returns any of THREE values.
    /// </summary>
    [Fact]
    public void GetMessageW_ReturnsBOOL()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("GetMessage", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.All(this.FindGeneratedMethod("GetMessage"), method => Assert.True(method.ReturnType is QualifiedNameSyntax { Right: { Identifier: { ValueText: "BOOL" } } }));
    }

    [Theory, PairwiseData]
    public void NativeArray_OfManagedTypes_MarshaledAsLPArray(bool allowMarshaling)
    {
        const string ifaceName = "ID3D11DeviceContext";
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling });
        Assert.True(this.generator.TryGenerate(ifaceName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        var generatedMethod = this.FindGeneratedMethod("OMSetRenderTargets").Where(m => m.ParameterList.Parameters.Count == 3 && m.ParameterList.Parameters[0].Identifier.ValueText == "NumViews").FirstOrDefault();
        Assert.NotNull(generatedMethod);

        if (allowMarshaling)
        {
            Assert.Contains(generatedMethod!.ParameterList.Parameters[1].AttributeLists, al => IsAttributePresent(al, "MarshalAs"));
        }
        else
        {
            Assert.DoesNotContain(generatedMethod!.ParameterList.Parameters[1].AttributeLists, al => IsAttributePresent(al, "MarshalAs"));
        }
    }

    [Theory, PairwiseData]
    public void NativeArray_SizeParamIndex_ProducesSimplerFriendlyOverload(bool allowMarshaling)
    {
        var options = DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling };
        this.generator = this.CreateGenerator(options);
        Assert.True(this.generator.TryGenerate("EvtNext", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        IEnumerable<MethodDeclarationSyntax> overloads = this.FindGeneratedMethod("EvtNext");
        Assert.NotEmpty(overloads.Where(o => o.ParameterList.Parameters.Count == 5 && (o.ParameterList.Parameters[1].Type?.ToString().StartsWith("Span<", StringComparison.Ordinal) ?? false)));
    }

    [Theory, PairwiseData]
    public void NonCOMInterfaceReferences(bool allowMarshaling)
    {
        var options = DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling };
        this.generator = this.CreateGenerator(options);
        const string methodName = "D3DCompile"; // A method whose signature references non-COM interface ID3DInclude
        Assert.True(this.generator.TryGenerate(methodName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        // The generated methods MUST reference the "interface" (which must actually be generated as a struct) by pointer.
        Assert.Contains(this.FindGeneratedType("ID3DInclude"), t => t is StructDeclarationSyntax);
        Assert.All(this.FindGeneratedMethod(methodName), m => Assert.True(m.ParameterList.Parameters[4].Type is PointerTypeSyntax { ElementType: QualifiedNameSyntax { Right: IdentifierNameSyntax { Identifier: { ValueText: "ID3DInclude" } } } }));
    }

    [Theory, PairwiseData]
    public void BOOL_ReturnType_InCOMInterface(bool allowMarshaling)
    {
        var options = DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling };
        this.generator = this.CreateGenerator(options);
        Assert.True(this.generator.TryGenerate("ISpellCheckerFactory", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        if (allowMarshaling)
        {
            Assert.Contains(this.FindGeneratedMethod("IsSupported"), method => method.ReturnType is QualifiedNameSyntax { Right: IdentifierNameSyntax { Identifier: { ValueText: "BOOL" } } });
        }
        else
        {
            Assert.Contains(this.FindGeneratedMethod("IsSupported"), method => method.ParameterList.Parameters.Last().Type is PointerTypeSyntax { ElementType: QualifiedNameSyntax { Right: IdentifierNameSyntax { Identifier: { ValueText: "BOOL" } } } });
        }
    }

    [Theory, PairwiseData]
    public void GenerateByNamespace(bool correctCase)
    {
        this.generator = this.CreateGenerator();
        string ns = "Windows.Win32.Foundation";
        if (!correctCase)
        {
            ns = ns.ToUpperInvariant();
        }

        Assert.True(this.generator.TryGenerate(ns, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.NotEmpty(this.FindGeneratedType("BOOL"));
        Assert.NotEmpty(this.FindGeneratedType("SIZE"));
    }

    /// <summary>
    /// Verifies that fields are not converted from BOOL to bool.
    /// </summary>
    [Fact]
    public void BOOL_FieldRemainsBOOL()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("ICONINFO", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        var theStruct = (StructDeclarationSyntax)this.FindGeneratedType("ICONINFO").Single();
        VariableDeclarationSyntax field = theStruct.Members.OfType<FieldDeclarationSyntax>().Select(m => m.Declaration).Single(d => d.Variables.Any(v => v.Identifier.ValueText == "fIcon"));
        Assert.Equal("BOOL", Assert.IsType<QualifiedNameSyntax>(field.Type).Right.Identifier.ValueText);
    }

    [Theory, PairwiseData]
    public void BSTR_FieldsDoNotBecomeSafeHandles(bool allowMarshaling)
    {
        var options = DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling };
        this.generator = this.CreateGenerator(options);
        Assert.True(this.generator.TryGenerate("DebugPropertyInfo", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        StructDeclarationSyntax structDecl = Assert.IsType<StructDeclarationSyntax>(this.FindGeneratedType("DebugPropertyInfo").Single());
        var bstrField = structDecl.Members.OfType<FieldDeclarationSyntax>().First(m => m.Declaration.Variables.Any(v => v.Identifier.ValueText == "m_bstrName"));
        Assert.Equal("BSTR", Assert.IsType<QualifiedNameSyntax>(bstrField.Declaration.Type).Right.Identifier.ValueText);
    }

    [Fact]
    public void TypeNameCollisionsDoNotCauseTooMuchCodeGen()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("TYPEDESC", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Empty(this.FindGeneratedType("D3DMATRIX"));
    }

    /// <summary>
    /// Verifies that MSIHANDLE is wrapped with a SafeHandle even though it is a 32-bit handle.
    /// This is safe because we never pass SafeHandle directly to extern methods, so we can fix the length of the parameter or return value.
    /// </summary>
    [Fact]
    public void MSIHANDLE_BecomesSafeHandle()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("MsiGetLastErrorRecord", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        Assert.Contains(
            this.FindGeneratedMethod("MsiGetLastErrorRecord"),
            method => method!.ReturnType is QualifiedNameSyntax { Right: { Identifier: { ValueText: "MSIHANDLE" } } });

        Assert.Contains(
            this.FindGeneratedMethod("MsiGetLastErrorRecord_SafeHandle"),
            method => method!.ReturnType?.ToString() == "MsiCloseHandleSafeHandle");

        MethodDeclarationSyntax releaseMethod = this.FindGeneratedMethod("MsiCloseHandle").Single();
        Assert.Equal("MSIHANDLE", Assert.IsType<QualifiedNameSyntax>(releaseMethod!.ParameterList.Parameters[0].Type).Right.Identifier.ValueText);
    }

    [Fact]
    public void OutHandleParameterBecomesSafeHandle()
    {
        this.generator = this.CreateGenerator();
        const string methodName = "TcAddFilter";
        Assert.True(this.generator.TryGenerate(methodName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        Assert.Contains(
            this.FindGeneratedMethod(methodName),
            method => method!.ParameterList.Parameters[2].Type is QualifiedNameSyntax { Right: { Identifier: { ValueText: nameof(Microsoft.Win32.SafeHandles.SafeFileHandle) } } });

        Assert.Contains(
            this.FindGeneratedMethod(methodName),
            method => method!.ParameterList.Parameters[0].Type is IdentifierNameSyntax { Identifier: { ValueText: nameof(SafeHandle) } });
    }

    [Fact]
    public void Const_PWSTR_Becomes_PCWSTR_and_String()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("StrCmpLogical", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        bool foundPCWSTROverload = false;
        bool foundStringOverload = false;
        IEnumerable<MethodDeclarationSyntax> overloads = this.FindGeneratedMethod("StrCmpLogical");
        foreach (MethodDeclarationSyntax method in overloads)
        {
            foundPCWSTROverload |= method!.ParameterList.Parameters[0].Type is QualifiedNameSyntax { Right: { Identifier: { ValueText: "PCWSTR" } } };
            foundStringOverload |= method!.ParameterList.Parameters[0].Type?.ToString() == "string";
        }

        Assert.True(foundPCWSTROverload, "PCWSTR overload is missing.");
        Assert.True(foundStringOverload, "string overload is missing.");
        Assert.Equal(2, overloads.Count());
    }

    ////[Fact]
    ////public void CrossWinmdTypeReference()
    ////{
    ////    this.generator = this.CreateGenerator();
    ////    using Generator diaGenerator = this.CreateGenerator(DiaMetadataPath);
    ////    var super = SuperGenerator.Combine(this.generator, diaGenerator);
    ////    Assert.True(diaGenerator.TryGenerate("E_PDB_NOT_FOUND", CancellationToken.None));
    ////    this.CollectGeneratedCode(this.generator);
    ////    this.CollectGeneratedCode(diaGenerator);
    ////    this.AssertNoDiagnostics();

    ////    Assert.Single(this.FindGeneratedType("HRESULT"));
    ////    Assert.Single(this.FindGeneratedConstant("E_PDB_NOT_FOUND"));
    ////}

    [Theory, CombinatorialData]
    public void ArchitectureSpecificAPIsTreatment(
        [CombinatorialValues("MEMORY_BASIC_INFORMATION", "SP_PROPCHANGE_PARAMS", "JsCreateContext", "IShellBrowser")] string apiName,
        [CombinatorialValues(Platform.AnyCpu, Platform.X64, Platform.X86)] Platform platform,
        bool allowMarshaling)
    {
        this.compilation = this.compilation.WithOptions(this.compilation.Options.WithPlatform(platform));
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling });
        if (platform == Platform.AnyCpu)
        {
            // AnyCPU targets should throw an exception with a helpful error message when asked for arch-specific APIs
            var ex = Assert.ThrowsAny<GenerationFailedException>(() => this.generator.TryGenerate(apiName, CancellationToken.None));
            this.logger.WriteLine(ex.Message);
            this.CollectGeneratedCode(this.generator);
            this.AssertNoDiagnostics();
        }
        else
        {
            // Arch-specific compilations should generate the requested APIs.
            Assert.True(this.generator.TryGenerate(apiName, CancellationToken.None));
            this.CollectGeneratedCode(this.generator);
            this.AssertNoDiagnostics();
        }
    }

    [Fact]
    public void MultipleEntrypointsToOmittedArchSpecificApis()
    {
        this.compilation = this.compilation.WithOptions(this.compilation.Options.WithPlatform(Platform.AnyCpu));
        this.generator = this.CreateGenerator();

        // Request a struct that depends on arch-specific IP6_ADDRESS.
        Assert.ThrowsAny<GenerationFailedException>(() => this.generator.TryGenerate("DNS_SERVICE_INSTANCE", CancellationToken.None));

        // Request a struct that depends on DNS_SERVICE_INSTANCE.
        Assert.ThrowsAny<GenerationFailedException>(() => this.generator.TryGenerate("DNS_SERVICE_REGISTER_REQUEST", CancellationToken.None));

        // Verify that no uncompilable code was generated.
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Theory, CombinatorialData]
    public void TypeRefsToArchSpecificApis(
        [CombinatorialValues(Platform.X64, Platform.X86)] Platform platform)
    {
        this.compilation = this.compilation.WithOptions(this.compilation.Options.WithPlatform(platform));
        this.generator = this.CreateGenerator();

        // Request a struct directly, and indirectly through another that references it.
        // This verifies that even if the metadata references a particular arch of the structure,
        // the right one for the CPU architecture is generated.
        Assert.True(this.generator.TryGenerate("SP_PROPCHANGE_PARAMS", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("SP_CLASSINSTALL_HEADER", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        // Verify that [Pack = 1] appears on both structures.
        foreach (string structName in new[] { "SP_CLASSINSTALL_HEADER", "SP_PROPCHANGE_PARAMS" })
        {
            var header = this.FindGeneratedType(structName).Single();
            SeparatedSyntaxList<AttributeArgumentSyntax> attributes = header.AttributeLists.SelectMany(al => al.Attributes).FirstOrDefault(att => att.Name is IdentifierNameSyntax { Identifier: { ValueText: "StructLayout" } })?.ArgumentList?.Arguments ?? default;
            Predicate<AttributeArgumentSyntax> matchPredicate = att => att.NameEquals is { Name: { Identifier: { ValueText: "Pack" } } };
            if (platform == Platform.X86)
            {
                Assert.Contains(attributes, matchPredicate);
            }
            else
            {
                Assert.DoesNotContain(attributes, matchPredicate);
            }
        }
    }

    [Theory]
    [InlineData("BOOL")]
    [InlineData("HRESULT")]
    [InlineData("MEMORY_BASIC_INFORMATION")]
    public void StructsArePartial(string structName)
    {
        this.compilation = this.starterCompilations["net6.0-x64"]; // MEMORY_BASIC_INFORMATION is arch-specific
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(structName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        StructDeclarationSyntax structDecl = Assert.IsType<StructDeclarationSyntax>(this.FindGeneratedType(structName).Single());
        Assert.True(structDecl.Modifiers.Any(SyntaxKind.PartialKeyword));
    }

    [Fact]
    public void PartialStructsAllowUserContributions()
    {
        const string structName = "HRESULT";
        this.compilation = this.compilation.AddSyntaxTrees(
            CSharpSyntaxTree.ParseText("namespace Microsoft.Windows.Sdk { partial struct HRESULT { void Foo() { } } }", this.parseOptions, "myHRESULT.cs"));

        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(structName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        bool hasFooMethod = false;
        bool hasValueProperty = false;
        foreach (StructDeclarationSyntax structDecl in this.FindGeneratedType(structName))
        {
            hasFooMethod |= structDecl.Members.OfType<MethodDeclarationSyntax>().Any(m => m.Identifier.ValueText == "Foo");
            hasValueProperty |= structDecl.Members.OfType<FieldDeclarationSyntax>().Any(p => p.Declaration.Variables.FirstOrDefault()?.Identifier.ValueText == "Value");
        }

        Assert.True(hasFooMethod, "User-defined method not found.");
        Assert.True(hasValueProperty, "Projected members not found.");
    }

    [Theory]
    [CombinatorialData]
    public void COMInterfaceIIDInterfaceOnAppropriateTFMs(
        bool allowMarshaling,
        [CombinatorialValues(LanguageVersion.CSharp10, LanguageVersion.CSharp11)] LanguageVersion langVersion,
        [CombinatorialValues("net6.0", "net7.0")] string tfm)
    {
        const string structName = "IEnumBstr";
        this.compilation = this.starterCompilations[tfm];
        this.parseOptions = this.parseOptions.WithLanguageVersion(langVersion);
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling });
        Assert.True(this.generator.TryGenerate(structName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        BaseTypeDeclarationSyntax type = this.FindGeneratedType(structName).Single();
        IEnumerable<BaseTypeSyntax> actual = type.BaseList?.Types ?? Enumerable.Empty<BaseTypeSyntax>();
        Predicate<BaseTypeSyntax> predicate = t => t.Type.ToString().Contains("IComIID");

        // Static interface members requires C# 11 and .NET 7.
        // And COM *interfaces* are not allowed to have them, so assert we only generate them on structs.
        if (tfm == "net7.0" && langVersion >= LanguageVersion.CSharp11 && type is StructDeclarationSyntax)
        {
            Assert.Contains(actual, predicate);
        }
        else
        {
            Assert.DoesNotContain(actual, predicate);
        }
    }

    [Fact]
    public void PROC_GeneratedAsStruct()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("PROC", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        BaseTypeDeclarationSyntax type = Assert.Single(this.FindGeneratedType("PROC"));
        Assert.IsType<StructDeclarationSyntax>(type);
    }

    [Theory]
    [MemberData(nameof(TFMData))]
    public void FARPROC_GeneratedAsStruct(string tfm)
    {
        this.compilation = this.starterCompilations[tfm];
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("FARPROC", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        BaseTypeDeclarationSyntax type = Assert.Single(this.FindGeneratedType("FARPROC"));
        Assert.IsType<StructDeclarationSyntax>(type);
    }

    [Theory, PairwiseData]
    public void FARPROC_AsFieldType(bool allowMarshaling)
    {
        this.generator = this.CreateGenerator(new GeneratorOptions { AllowMarshaling = allowMarshaling });
        Assert.True(this.generator.TryGenerate("EXTPUSH", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        StructDeclarationSyntax type = Assert.IsType<StructDeclarationSyntax>(Assert.Single(this.FindGeneratedType("_Anonymous1_e__Union")));
        var callback = (FieldDeclarationSyntax)type.Members[1];
        Assert.True(callback.Declaration.Type is QualifiedNameSyntax { Right: { Identifier: { ValueText: "FARPROC" } } }, "Field type was " + callback.Declaration.Type);
    }

    [Fact]
    public void GetLastErrorGenerationThrowsWhenExplicitlyCalled()
    {
        this.generator = this.CreateGenerator();
        Assert.Throws<NotSupportedException>(() => this.generator.TryGenerate("GetLastError", CancellationToken.None));
    }

    [Fact(Skip = "https://github.com/microsoft/win32metadata/issues/129")]
    public void DeleteObject_TakesTypeDefStruct()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("DeleteObject", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        MethodDeclarationSyntax? deleteObjectMethod = this.FindGeneratedMethod("DeleteObject").FirstOrDefault();
        Assert.NotNull(deleteObjectMethod);
        Assert.Equal("HGDIOBJ", Assert.IsType<IdentifierNameSyntax>(deleteObjectMethod!.ParameterList.Parameters[0].Type).Identifier.ValueText);
    }

    [Fact]
    public void CollidingStructNotGenerated()
    {
        const string test = @"
namespace Microsoft.Windows.Sdk
{
    internal enum FILE_CREATE_FLAGS
    {
        CREATE_NEW = 1,
        CREATE_ALWAYS = 2,
        OPEN_EXISTING = 3,
        OPEN_ALWAYS = 4,
        TRUNCATE_EXISTING = 5,
    }
}
";
        this.compilation = this.compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(test, this.parseOptions, "test.cs"));
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("CreateFile", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Theory]
    [InlineData("BOOL")]
    [InlineData("BSTR")]
    [InlineData("HRESULT")]
    [InlineData("NTSTATUS")]
    [InlineData("PCSTR")]
    [InlineData("PCWSTR")]
    [InlineData("PWSTR")]
    public void SynthesizedTypesCanBeDirectlyRequested(string synthesizedTypeName)
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(synthesizedTypeName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Single(this.FindGeneratedType(synthesizedTypeName));
    }

    [Theory]
    [InlineData("BOOL")]
    [InlineData("BSTR")]
    [InlineData("HRESULT")]
    [InlineData("NTSTATUS")]
    [InlineData("PCSTR")]
    [InlineData("PCWSTR")]
    [InlineData("PWSTR")]
    public void SynthesizedTypesWorkInNet35(string synthesizedTypeName)
    {
        this.compilation = this.starterCompilations["net35"];
        this.generator = this.CreateGenerator();

        Assert.True(this.generator.TryGenerate(synthesizedTypeName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.Single(this.FindGeneratedType(synthesizedTypeName));
    }

    [Theory, PairwiseData]
    public void NoFriendlyOverloadsWithSpanInNet35(bool allowMarshaling)
    {
        this.compilation = this.starterCompilations["net35"];
        var options = DefaultTestGeneratorOptions with { AllowMarshaling = allowMarshaling };
        this.generator = this.CreateGenerator(options);
        Assert.True(this.generator.TryGenerate("EvtNext", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Theory, PairwiseData]
    public void FixedLengthInlineArray(
        bool allowMarshaling,
        bool multitargetingAPIs,
        [CombinatorialValues("net35", "net472", "net6.0")] string tfm,
        [CombinatorialValues(/*char*/"RM_PROCESS_INFO", /*custom unmanaged*/"ARRAYDESC")] string api,
        [CombinatorialValues(LanguageVersion.CSharp8, LanguageVersion.CSharp9)] LanguageVersion langVersion)
    {
        this.compilation = this.starterCompilations[tfm];
        this.parseOptions = this.parseOptions.WithLanguageVersion(langVersion);
        this.generator = this.CreateGenerator(new GeneratorOptions { AllowMarshaling = allowMarshaling, MultiTargetingFriendlyAPIs = multitargetingAPIs });

        // TODO we need to test
        // another IEquatable primitive,
        // a non-IEquatable primitive (e.g. IntPtr before .NET 5),
        // and a custom managed.
        //// TODO: code here

        Assert.True(this.generator.TryGenerate(api, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Theory, PairwiseData]
    public void FixedLengthInlineArray_Pointers(
        bool allowMarshaling,
        bool multitargetingAPIs,
        [CombinatorialValues("net35", "net472", "net6.0")] string tfm)
    {
        this.compilation = this.starterCompilations[tfm];
        this.generator = this.CreateGenerator(new GeneratorOptions { AllowMarshaling = allowMarshaling, MultiTargetingFriendlyAPIs = multitargetingAPIs });
        Assert.True(this.generator.TryGenerate("RTM_ENTITY_EXPORT_METHODS", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Fact]
    public void FixedLengthInlineArray_TwoRequested()
    {
        this.generator = this.CreateGenerator();

        // These two APIs are specially selected because they are both char arrays, and thus would both request the SliceAtNull extension method's generation.
        Assert.True(this.generator.TryGenerate("RM_PROCESS_INFO", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("WER_REPORT_INFORMATION", CancellationToken.None));

        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        // Verify that inline arrays that share the same length and type are only declared once and shared with all users.
        Assert.Single(this.FindGeneratedType("__char_64"));
    }

    [Theory, PairwiseData]
    public void FixedLengthInlineArrayIn_MODULEENTRY32(bool allowMarshaling)
    {
        this.generator = this.CreateGenerator(new GeneratorOptions { AllowMarshaling = allowMarshaling });
        Assert.True(this.generator.TryGenerate("MODULEENTRY32", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        var decl = (StructDeclarationSyntax)Assert.Single(this.FindGeneratedType("MODULEENTRY32"));
        var field = this.FindFieldDeclaration(decl, "szModule");
        Assert.True(field.HasValue);
        var fieldType = Assert.IsType<QualifiedNameSyntax>(field!.Value.Field.Declaration.Type);
        Assert.IsType<StructDeclarationSyntax>(Assert.Single(this.FindGeneratedType(fieldType.Right.Identifier.ValueText)));
    }

    [Fact]
    public void InOutPWSTRGetsRefSpanCharFriendlyOverload()
    {
        const string MethodName = "PathParseIconLocation";
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(MethodName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        IEnumerable<MethodDeclarationSyntax> generatedMethods = this.FindGeneratedMethod(MethodName);
        Assert.Contains(generatedMethods, m => m.ParameterList.Parameters.Count == 1 && m.ParameterList.Parameters[0].Modifiers.Any(SyntaxKind.RefKeyword) && m.ParameterList.Parameters[0].Type?.ToString() == "Span<char>");
    }

    [Fact]
    public void UnicodeExtenMethodsGetCharSet()
    {
        const string MethodName = "VkKeyScan";
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(MethodName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        MethodDeclarationSyntax generatedMethod = this.FindGeneratedMethod(MethodName).Single();
        Assert.Contains(
            generatedMethod.AttributeLists.SelectMany(al => al.Attributes),
            a => a.Name.ToString() == "DllImport" &&
            a.ArgumentList?.Arguments.Any(arg => arg is
            {
                NameEquals.Name.Identifier.ValueText: nameof(DllImportAttribute.CharSet),
                Expression: MemberAccessExpressionSyntax { Name: IdentifierNameSyntax { Identifier.ValueText: nameof(CharSet.Unicode) } }
            }) is true);
    }

    [Fact]
    public void NullMethodsClass()
    {
        Assert.Throws<InvalidOperationException>(() => this.CreateGenerator(new GeneratorOptions { ClassName = null! }));
    }

    [Fact]
    public void RenamedMethodsClass()
    {
        this.generator = this.CreateGenerator(new GeneratorOptions { ClassName = "MyPInvoke" });
        Assert.True(this.generator.TryGenerate("GetTickCount", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("CDB_REPORT_BITS", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        Assert.NotEmpty(this.FindGeneratedType("MyPInvoke"));
        Assert.Empty(this.FindGeneratedType("PInvoke"));
    }

    [Theory, PairwiseData]
    public void TBButton([CombinatorialMemberData(nameof(SpecificCpuArchitectures))] Platform platform)
    {
        this.compilation = this.compilation.WithOptions(this.compilation.Options.WithPlatform(platform));
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("TBBUTTON", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    [Theory, PairwiseData]
    public void FullGeneration(MarshalingOptions marshaling, bool useIntPtrForComOutPtr, [CombinatorialMemberData(nameof(AnyCpuArchitectures))] Platform platform)
    {
        var generatorOptions = new GeneratorOptions
        {
            AllowMarshaling = marshaling >= MarshalingOptions.MarshalingWithoutSafeHandles,
            UseSafeHandles = marshaling == MarshalingOptions.FullMarshaling,
            ComInterop = new() { UseIntPtrForComOutPointers = useIntPtrForComOutPtr },
        };
        this.compilation = this.compilation.WithOptions(this.compilation.Options.WithPlatform(platform));
        this.generator = this.CreateGenerator(generatorOptions);
        this.generator.GenerateAll(CancellationToken.None);
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics(logAllGeneratedCode: false);
    }

    [Theory, PairwiseData]
    public void ProjectReferenceBetweenTwoGeneratingProjects(bool internalsVisibleTo)
    {
        CSharpCompilation referencedProject = this.compilation
            .WithAssemblyName("refdProj");
        if (internalsVisibleTo)
        {
            referencedProject = referencedProject.AddSyntaxTrees(
                CSharpSyntaxTree.ParseText($@"[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(""{this.compilation.AssemblyName}"")]", this.parseOptions));
        }

        using var referencedGenerator = this.CreateGenerator(new GeneratorOptions { ClassName = "P1" }, referencedProject);
        Assert.True(referencedGenerator.TryGenerate("LockWorkStation", CancellationToken.None));
        Assert.True(referencedGenerator.TryGenerate("CreateFile", CancellationToken.None));
        Assert.True(referencedGenerator.TryGenerate("RAWHID", CancellationToken.None));
        referencedProject = this.AddGeneratedCode(referencedProject, referencedGenerator);
        this.AssertNoDiagnostics(referencedProject);

        // Now produce more code in a referencing project that includes at least one of the same types as generated in the referenced project.
        this.compilation = this.compilation.AddReferences(referencedProject.ToMetadataReference());
        this.generator = this.CreateGenerator(new GeneratorOptions { ClassName = "P2" });
        Assert.True(this.generator.TryGenerate("HidD_GetAttributes", CancellationToken.None));
        Assert.True(this.generator.TryGenerate("RAWHID", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
    }

    /// <summary>
    /// Tests that a generating project that references two other generating projects will generate its own types if a unique type isn't available from the referenced projects.
    /// In particular, if a type is generated in <em>both</em> of the referenced projects, that creates an ambiguity problem that <em>may</em> be resolved with <c>extern alias</c>
    /// or perhaps by simply generating types a third time in the local compilation.
    /// </summary>
    /// <param name="internalsVisibleTo">Whether to generate internal APIs and use the <see cref="InternalsVisibleToAttribute"/>.</param>
    /// <param name="externAlias">Whether to specify extern aliases for the references.</param>
    [Theory, PairwiseData]
    public void ProjectReferenceBetweenThreeGeneratingProjects(bool internalsVisibleTo, bool externAlias)
    {
        CSharpCompilation templateCompilation = this.compilation;
        for (int i = 1; i <= 2; i++)
        {
            CSharpCompilation referencedProject = templateCompilation.WithAssemblyName("refdProj" + i);
            LogProject(referencedProject.AssemblyName!);
            if (internalsVisibleTo)
            {
                var ivtSource = CSharpSyntaxTree.ParseText($@"[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(""{this.compilation.AssemblyName}"")]", this.parseOptions);
                referencedProject = referencedProject.AddSyntaxTrees(ivtSource);
            }

            using var referencedGenerator = this.CreateGenerator(new GeneratorOptions { Public = !internalsVisibleTo }, referencedProject);

            // Both will declare HRESULT
            Assert.True(referencedGenerator.TryGenerate("HANDLE", CancellationToken.None));

            // One will declare FILE_SHARE_MODE
            if (i % 2 == 0)
            {
                Assert.True(referencedGenerator.TryGenerate("FILE_SHARE_MODE", CancellationToken.None));
            }

            referencedProject = this.AddGeneratedCode(referencedProject, referencedGenerator);
            this.AssertNoDiagnostics(referencedProject);
            Assert.Single(this.FindGeneratedType("HANDLE", referencedProject));

            ImmutableArray<string> aliases = externAlias ? ImmutableArray.Create("ref" + i) : ImmutableArray<string>.Empty;
            this.compilation = this.compilation.AddReferences(referencedProject.ToMetadataReference(aliases));
        }

        LogProject(this.compilation.AssemblyName!);

        // Now produce more code in a referencing project that needs HANDLE, which is found *twice*, once in each referenced project.
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("CreateFile", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);

        // Consume the API to verify the user experience isn't broken.
        string programCsSource = @"
#pragma warning disable CS0436

using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.Storage.FileSystem;

class Program
{
    static unsafe void Main()
    {
        HANDLE h = PInvoke.CreateFile(
            default(PCWSTR),
            FILE_ACCESS_FLAGS.FILE_ADD_FILE,
            FILE_SHARE_MODE.FILE_SHARE_READ,
            null,
            FILE_CREATION_DISPOSITION.CREATE_NEW,
            FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_ARCHIVE,
            default(HANDLE));
    }
}
";
        this.compilation = this.compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(programCsSource, this.parseOptions, "Program.cs"));

        this.AssertNoDiagnostics();

        // The CreateFile should of course be declared locally.
        Assert.NotEmpty(this.FindGeneratedMethod("CreateFile"));

        // We expect HANDLE to be declared locally, to resolve the ambiguity of it coming from *two* references.
        Assert.Single(this.FindGeneratedType("HANDLE"));

        // We expect FILE_SHARE_MODE to be declared locally only if not using extern aliases, since it can be retrieved from *one* of the references.
        Assert.Equal(externAlias, this.FindGeneratedType("FILE_SHARE_MODE").Any());

        void LogProject(string name)
        {
            this.logger.WriteLine("≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡");
            this.logger.WriteLine("Generating {0}", name);
            this.logger.WriteLine("≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡");
        }
    }

    [Fact]
    public async Task UnparseableNativeMethodsJson()
    {
        await new VerifyTest
        {
            TestState =
            {
                ReferenceAssemblies = MyReferenceAssemblies.NetStandard20,
                AdditionalFiles =
                {
                    ("NativeMethods.txt", "CreateFile"),
                    ("NativeMethods.json", @"{ ""allowMarshaling"": f }"), // the point where the user is typing "false"
                },
                AnalyzerConfigFiles =
                {
                    ("/.globalconfig", ConstructGlobalConfigString()),
                },
                GeneratedSources =
                {
                    // Nothing generated, but no exceptions thrown that would lead Roslyn to disable the source generator in the IDE either.
                },
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(SourceGenerator.OptionsParsingError.Id, DiagnosticSeverity.Error),
                },
            },
        }.RunAsync();
    }

    [Fact]
    public void CocreatableStructs()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("ShellLink", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        ClassDeclarationSyntax classDecl = Assert.IsType<ClassDeclarationSyntax>(this.FindGeneratedType("ShellLink").Single());
        Assert.Contains(classDecl.AttributeLists, al => al.Attributes.Any(a => a.Name.ToString().Contains("ComImport")));
    }

    [Fact]
    public void OpensMetadataForSharedReading()
    {
        using FileStream competingReader = File.OpenRead(MetadataPath);
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("CreateFile", CancellationToken.None));
    }

    [Theory]
    [MemberData(nameof(TFMDataNoNetFx35))]
    public void MiniDumpWriteDump_AllOptionalPointerParametersAreOptional(string tfm)
    {
        // We split on TFMs because the generated code is slightly different depending on TFM.
        this.compilation = this.starterCompilations[tfm].WithOptions(this.compilation.Options.WithPlatform(Platform.X64));
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("MiniDumpWriteDump", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        MethodDeclarationSyntax externMethod = Assert.Single(this.FindGeneratedMethod("MiniDumpWriteDump"), m => !m.Modifiers.Any(SyntaxKind.ExternKeyword));
        Assert.All(externMethod.ParameterList.Parameters.Reverse().Take(3), p => Assert.IsType<NullableTypeSyntax>(p.Type));
    }

    [Fact]
    public void ContainsIllegalCharactersForAPIName_InvisibleCharacters()
    {
        // You can't see them, but there are invisible hyphens in this name.
        // Copy-paste from docs.microsoft.com has been known to include these invisible characters and break matching in NativeMethods.txt.
        Assert.True(Generator.ContainsIllegalCharactersForAPIName("SHGet­Known­Folder­Item"));
    }

    [Fact]
    public void ContainsIllegalCharactersForAPIName_DisallowedVisibleCharacters()
    {
        Assert.True(Generator.ContainsIllegalCharactersForAPIName("Method-1"));
    }

    [Fact]
    public void ContainsIllegalCharactersForAPIName_LegalNames()
    {
        Assert.False(Generator.ContainsIllegalCharactersForAPIName("SHGetKnownFolderItem"));
        Assert.False(Generator.ContainsIllegalCharactersForAPIName("Method1"));
        Assert.False(Generator.ContainsIllegalCharactersForAPIName("Method_1"));
        Assert.False(Generator.ContainsIllegalCharactersForAPIName("Qualified.Name"));
    }

    [Fact]
    public void ContainsIllegalCharactersForAPIName_AllActualAPINames()
    {
        using FileStream metadataStream = File.OpenRead(MetadataPath);
        using System.Reflection.PortableExecutable.PEReader peReader = new(metadataStream);
        MetadataReader metadataReader = peReader.GetMetadataReader();
        foreach (MethodDefinitionHandle methodDefHandle in metadataReader.MethodDefinitions)
        {
            MethodDefinition methodDef = metadataReader.GetMethodDefinition(methodDefHandle);
            string methodName = metadataReader.GetString(methodDef.Name);
            Assert.False(Generator.ContainsIllegalCharactersForAPIName(methodName), methodName);
        }

        foreach (TypeDefinitionHandle typeDefHandle in metadataReader.TypeDefinitions)
        {
            TypeDefinition typeDef = metadataReader.GetTypeDefinition(typeDefHandle);
            string typeName = metadataReader.GetString(typeDef.Name);
            if (typeName == "<Module>")
            {
                // Skip this special one.
                continue;
            }

            Assert.False(Generator.ContainsIllegalCharactersForAPIName(typeName), typeName);
        }

        foreach (FieldDefinitionHandle fieldDefHandle in metadataReader.FieldDefinitions)
        {
            FieldDefinition fieldDef = metadataReader.GetFieldDefinition(fieldDefHandle);
            string fieldName = metadataReader.GetString(fieldDef.Name);
            Assert.False(Generator.ContainsIllegalCharactersForAPIName(fieldName), fieldName);
        }
    }

    [Fact]
    public void AvoidSafeHandles()
    {
        this.generator = this.CreateGenerator(DefaultTestGeneratorOptions with { UseSafeHandles = false });
        Assert.True(this.generator.TryGenerate("GetExitCodeThread", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        MethodDeclarationSyntax friendlyOverload = Assert.Single(this.FindGeneratedMethod("GetExitCodeThread"), m => m.ParameterList.Parameters[^1].Modifiers.Any(SyntaxKind.OutKeyword));
        Assert.Equal("HANDLE", Assert.IsType<QualifiedNameSyntax>(friendlyOverload.ParameterList.Parameters[0].Type).Right.Identifier.ValueText);
    }

    [Fact]
    public void ParametersIncludeSizeParamIndex()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate("IEnumSearchScopeRules", CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        MethodDeclarationSyntax nextMethod = this.FindGeneratedMethod("Next").Single(m => !m.Modifiers.Any(SyntaxKind.StaticKeyword));
        AttributeSyntax marshalAsAttribute = nextMethod.ParameterList.Parameters[1].AttributeLists.SelectMany(al => al.Attributes).Single(a => a.Name.ToString() == "MarshalAs");
        AttributeArgumentSyntax? sizeParamIndex = marshalAsAttribute.ArgumentList?.Arguments.Single(a => a.NameEquals?.Name.ToString() == nameof(MarshalAsAttribute.SizeParamIndex));
        Assert.NotNull(sizeParamIndex);
        Assert.Equal("0", ((LiteralExpressionSyntax)sizeParamIndex!.Expression).Token.ValueText);
    }

    [Fact]
    public void SeekOriginEnumPreferred()
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerateType("IStream"));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();

        MethodDeclarationSyntax seekMethod = Assert.Single(this.FindGeneratedMethod("Seek"));
        QualifiedNameSyntax seekParamType = Assert.IsType<QualifiedNameSyntax>(seekMethod.ParameterList.Parameters[1].Type);
        Assert.Equal(nameof(SeekOrigin), seekParamType.Right.Identifier.ValueText);
    }

    private static string ConstructGlobalConfigString(bool omitDocs = false)
    {
        StringBuilder globalConfigBuilder = new();
        globalConfigBuilder.AppendLine("is_global = true");
        globalConfigBuilder.AppendLine();
        globalConfigBuilder.AppendLine($"build_property.CsWin32InputMetadataPaths = {JoinAssemblyMetadata("ProjectionMetadataWinmd")}");
        if (!omitDocs)
        {
            globalConfigBuilder.AppendLine($"build_property.CsWin32InputDocPaths = {JoinAssemblyMetadata("ProjectionDocs")}");
        }

        return globalConfigBuilder.ToString();

        static string JoinAssemblyMetadata(string name)
        {
            return string.Join(";", typeof(GeneratorTests).Assembly.GetCustomAttributes<AssemblyMetadataAttribute>().Where(metadata => metadata.Key == name).Select(metadata => metadata.Value));
        }
    }

    private static ImmutableArray<Diagnostic> FilterDiagnostics(ImmutableArray<Diagnostic> diagnostics) => diagnostics.Where(d => d.Severity > DiagnosticSeverity.Hidden).ToImmutableArray();

    private static bool IsAttributePresent(AttributeListSyntax al, string attributeName) => al.Attributes.Any(a => a.Name.ToString() == attributeName);

    private static IEnumerable<AttributeSyntax> FindAttribute(SyntaxList<AttributeListSyntax> attributeLists, string name) => attributeLists.SelectMany(al => al.Attributes).Where(a => a.Name.ToString() == name);

    private static void AssertConsistentLineEndings(Compilation compilation)
    {
        foreach (SyntaxTree doc in compilation.SyntaxTrees)
        {
            AssertConsistentLineEndings(doc);
        }
    }

    private static void AssertConsistentLineEndings(SyntaxTree syntaxTree)
    {
        SourceText sourceText = syntaxTree.GetText();
        int firstLineBreakLength = default;
        int lineCount = 1;
        foreach (TextLine line in sourceText.Lines)
        {
            int thisLineBreakLength = line.EndIncludingLineBreak - line.End;
            if (lineCount == 1)
            {
                firstLineBreakLength = thisLineBreakLength;
            }
            else
            {
                if (firstLineBreakLength != thisLineBreakLength && thisLineBreakLength > 0)
                {
                    Assert.False(true, $"{syntaxTree.FilePath} Line {lineCount} had a {thisLineBreakLength}-byte line ending but line 1's line ending was {firstLineBreakLength} bytes long.");
                }
            }

            lineCount++;
        }
    }

    private static AccessorDeclarationSyntax? FindAccessor(BaseTypeDeclarationSyntax typeSyntax, string propertyName, SyntaxKind kind)
    {
        SyntaxList<MemberDeclarationSyntax> members = typeSyntax switch
        {
            InterfaceDeclarationSyntax iface => iface.Members,
            StructDeclarationSyntax s => s.Members,
            _ => throw new NotSupportedException(),
        };
        PropertyDeclarationSyntax? property = members.OfType<PropertyDeclarationSyntax>().SingleOrDefault(p => p.Identifier.ValueText == propertyName);
        return FindAccessor(property, kind);
    }

    private static AccessorDeclarationSyntax? FindAccessor(PropertyDeclarationSyntax? property, SyntaxKind kind) => property?.AccessorList?.Accessors.SingleOrDefault(a => a.IsKind(kind));

    private CSharpCompilation AddGeneratedCode(CSharpCompilation compilation, Generator generator)
    {
        var compilationUnits = generator.GetCompilationUnits(CancellationToken.None);
        var syntaxTrees = new List<SyntaxTree>(compilationUnits.Count);
        foreach (var unit in compilationUnits)
        {
            // Our syntax trees aren't quite right. And anyway the source generator API only takes text anyway so it doesn't _really_ matter.
            // So render the trees as text and have C# re-parse them so we get the same compiler warnings/errors that the user would get.
            syntaxTrees.Add(CSharpSyntaxTree.ParseText(unit.Value.ToFullString(), this.parseOptions, path: unit.Key));
        }

        // Add namespaces that projects may define to ensure we prefix types with "global::" everywhere.
        compilation = compilation.AddSyntaxTrees(
            CSharpSyntaxTree.ParseText("namespace Microsoft.System { }", this.parseOptions, path: "Microsoft.System.cs"),
            CSharpSyntaxTree.ParseText("namespace Windows.Win32.System { }", this.parseOptions, path: "Windows.Win32.System.cs"));

        return compilation.AddSyntaxTrees(syntaxTrees);
    }

    private void CollectGeneratedCode(Generator generator) => this.compilation = this.AddGeneratedCode(this.compilation, generator);

    private IEnumerable<MethodDeclarationSyntax> FindGeneratedMethod(string name, Compilation? compilation = null) => (compilation ?? this.compilation).SyntaxTrees.SelectMany(st => st.GetRoot().DescendantNodes().OfType<MethodDeclarationSyntax>()).Where(md => md.Identifier.ValueText == name);

    private IEnumerable<BaseTypeDeclarationSyntax> FindGeneratedType(string name, Compilation? compilation = null) => (compilation ?? this.compilation).SyntaxTrees.SelectMany(st => st.GetRoot().DescendantNodes().OfType<BaseTypeDeclarationSyntax>()).Where(btd => btd.Identifier.ValueText == name);

    private IEnumerable<FieldDeclarationSyntax> FindGeneratedConstant(string name, Compilation? compilation = null) => (compilation ?? this.compilation).SyntaxTrees.SelectMany(st => st.GetRoot().DescendantNodes().OfType<FieldDeclarationSyntax>()).Where(fd => (fd.Modifiers.Any(SyntaxKind.StaticKeyword) || fd.Modifiers.Any(SyntaxKind.ConstKeyword)) && fd.Declaration.Variables.Any(vd => vd.Identifier.ValueText == name));

    private (FieldDeclarationSyntax Field, VariableDeclaratorSyntax Variable)? FindFieldDeclaration(TypeDeclarationSyntax type, string fieldName)
    {
        foreach (FieldDeclarationSyntax field in type.Members.OfType<FieldDeclarationSyntax>())
        {
            foreach (VariableDeclaratorSyntax variable in field.Declaration.Variables)
            {
                if (variable.Identifier.ValueText == fieldName)
                {
                    return (field, variable);
                }
            }
        }

        return null;
    }

    private bool IsMethodGenerated(string name) => this.FindGeneratedMethod(name).Any();

    private void AssertNoDiagnostics(bool logAllGeneratedCode = true) => this.AssertNoDiagnostics(this.compilation, logAllGeneratedCode);

    private void AssertNoDiagnostics(CSharpCompilation compilation, bool logAllGeneratedCode = true)
    {
        var diagnostics = FilterDiagnostics(compilation.GetDiagnostics());
        this.LogDiagnostics(diagnostics);

        var emitDiagnostics = ImmutableArray<Diagnostic>.Empty;
        bool? emitSuccessful = null;
        if (diagnostics.IsEmpty)
        {
            var emitResult = compilation.Emit(peStream: Stream.Null, xmlDocumentationStream: Stream.Null);
            emitSuccessful = emitResult.Success;
            emitDiagnostics = FilterDiagnostics(emitResult.Diagnostics);
            this.LogDiagnostics(emitDiagnostics);
        }

        if (logAllGeneratedCode)
        {
            this.LogGeneratedCode(compilation);
        }
        else
        {
            foreach (SyntaxTree? fileWithDiagnosticts in diagnostics.Select(d => d.Location.SourceTree).Distinct())
            {
                if (fileWithDiagnosticts is object)
                {
                    this.LogGeneratedCode(fileWithDiagnosticts);
                }
            }
        }

        Assert.Empty(diagnostics);
        if (emitSuccessful.HasValue)
        {
            Assert.Empty(emitDiagnostics);
            Assert.True(emitSuccessful);
        }

        AssertConsistentLineEndings(compilation);
    }

    private void LogDiagnostics(ImmutableArray<Diagnostic> diagnostics)
    {
        foreach (var diagnostic in diagnostics)
        {
            this.logger.WriteLine(diagnostic.ToString());
        }
    }

    private void LogGeneratedCode(CSharpCompilation compilation)
    {
        foreach (SyntaxTree tree in compilation.SyntaxTrees)
        {
            this.LogGeneratedCode(tree);
        }
    }

    private void LogGeneratedCode(SyntaxTree tree)
    {
        this.logger.WriteLine(FileSeparator);
        this.logger.WriteLine($"{tree.FilePath} content:");
        this.logger.WriteLine(FileSeparator);
        using var lineWriter = new NumberedLineWriter(this.logger);
        tree.GetRoot().WriteTo(lineWriter);
        lineWriter.WriteLine(string.Empty);
    }

    private void AssertGeneratedType(string apiName, string expectedSyntax, string? expectedExtensions = null)
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(apiName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        BaseTypeDeclarationSyntax syntax = Assert.Single(this.FindGeneratedType(apiName));
        Assert.Equal(TestUtils.NormalizeToExpectedLineEndings(expectedSyntax), TestUtils.NormalizeToExpectedLineEndings(syntax.ToFullString()));

        var extensionsClass = (ClassDeclarationSyntax?)this.FindGeneratedType("InlineArrayIndexerExtensions").SingleOrDefault();
        if (expectedExtensions is string)
        {
            Assert.NotNull(extensionsClass);
            string extensionsClassString = extensionsClass!.ToFullString();
            Assert.Equal(TestUtils.NormalizeToExpectedLineEndings(expectedExtensions), TestUtils.NormalizeToExpectedLineEndings(extensionsClassString));
        }
        else
        {
            // Assert that no indexer was generated.
            Assert.Null(extensionsClass);
        }
    }

    private void AssertGeneratedMember(string apiName, string memberName, string expectedSyntax)
    {
        this.generator = this.CreateGenerator();
        Assert.True(this.generator.TryGenerate(apiName, CancellationToken.None));
        this.CollectGeneratedCode(this.generator);
        this.AssertNoDiagnostics();
        BaseTypeDeclarationSyntax typeSyntax = Assert.Single(this.FindGeneratedType(apiName));
        var semanticModel = this.compilation.GetSemanticModel(typeSyntax.SyntaxTree, ignoreAccessibility: false);
        var member = Assert.Single(semanticModel.GetDeclaredSymbol(typeSyntax, CancellationToken.None)!.GetMembers(memberName));
        var memberSyntax = member.DeclaringSyntaxReferences.Single().GetSyntax(CancellationToken.None);
        Assert.Equal(
            TestUtils.NormalizeToExpectedLineEndings(expectedSyntax).Trim(),
            TestUtils.NormalizeToExpectedLineEndings(memberSyntax.ToFullString()).Trim());
    }

    private async Task<CSharpCompilation> CreateCompilationAsync(ReferenceAssemblies references, Platform platform = Platform.AnyCpu)
    {
        ImmutableArray<MetadataReference> metadataReferences = await references.ResolveAsync(LanguageNames.CSharp, default);

        // Workaround for https://github.com/dotnet/roslyn-sdk/issues/699
        metadataReferences = metadataReferences.AddRange(
            Directory.GetFiles(Path.Combine(Path.GetTempPath(), "test-packages", "Microsoft.Windows.SDK.Contracts.10.0.19041.1", "ref", "netstandard2.0"), "*.winmd").Select(p => MetadataReference.CreateFromFile(p)));

        // CONSIDER: How can I pass in the source generator itself, with AdditionalFiles, so I'm exercising that code too?
        var compilation = CSharpCompilation.Create(
            assemblyName: "test",
            references: metadataReferences,
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, platform: platform, allowUnsafe: true));

        return compilation;
    }

    private Generator CreateGenerator(GeneratorOptions? options = null, CSharpCompilation? compilation = null, bool includeDocs = false) => this.CreateGenerator(MetadataPath, options, compilation, includeDocs);

    private Generator CreateGenerator(string path, GeneratorOptions? options = null, CSharpCompilation? compilation = null, bool includeDocs = false) => new Generator(path, includeDocs ? Docs.Get(ApiDocsPath) : null, options ?? DefaultTestGeneratorOptions, compilation ?? this.compilation, this.parseOptions);

    private static class MyReferenceAssemblies
    {
#pragma warning disable SA1202 // Elements should be ordered by access
        private static readonly ImmutableArray<PackageIdentity> AdditionalLegacyPackages = ImmutableArray.Create(
            new PackageIdentity("Microsoft.Windows.SDK.Contracts", "10.0.19041.1"));

        private static readonly ImmutableArray<PackageIdentity> AdditionalModernPackages = AdditionalLegacyPackages.AddRange(ImmutableArray.Create(
            new PackageIdentity("System.Runtime.CompilerServices.Unsafe", "6.0.0"),
            new PackageIdentity("System.Memory", "4.5.5"),
            new PackageIdentity("Microsoft.Win32.Registry", "5.0.0")));

        internal static readonly ReferenceAssemblies NetStandard20 = ReferenceAssemblies.NetStandard.NetStandard20.AddPackages(AdditionalModernPackages);

        internal static class NetFramework
        {
            internal static readonly ReferenceAssemblies Net35 = ReferenceAssemblies.NetFramework.Net35.Default.AddPackages(AdditionalLegacyPackages);
            internal static readonly ReferenceAssemblies Net472 = ReferenceAssemblies.NetFramework.Net472.Default.AddPackages(AdditionalModernPackages);
        }

        internal static class Net
        {
            internal static readonly ReferenceAssemblies Net60 = ReferenceAssemblies.Net.Net60.AddPackages(AdditionalModernPackages);
            internal static readonly ReferenceAssemblies Net70 = ReferenceAssemblies.Net.Net70.AddPackages(AdditionalModernPackages);
        }
#pragma warning restore SA1202 // Elements should be ordered by access
    }
}
